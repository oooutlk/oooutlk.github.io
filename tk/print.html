<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="installing_tk.html"><strong aria-hidden="true">2.</strong> Installing Tk</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installing_tk_on_windows.html"><strong aria-hidden="true">2.1.</strong> Installing Tk On Windows</a></li><li class="chapter-item expanded "><a href="installing_tk_on_linux.html"><strong aria-hidden="true">2.2.</strong> Installing Tk On Linux</a></li><li class="chapter-item expanded "><a href="installing_tk_on_freebsd.html"><strong aria-hidden="true">2.3.</strong> Installing Tk On FreeBSD</a></li></ol></li><li class="chapter-item expanded "><a href="a_first_real_example.html"><strong aria-hidden="true">3.</strong> A First (Real) Example</a></li><li class="chapter-item expanded "><a href="tk_concepts.html"><strong aria-hidden="true">4.</strong> Tk Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.1.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="geometry_management.html"><strong aria-hidden="true">4.2.</strong> Geometry Management</a></li><li class="chapter-item expanded "><a href="event_handling.html"><strong aria-hidden="true">4.3.</strong> Event Handling</a></li></ol></li><li class="chapter-item expanded "><a href="basic_widgets.html"><strong aria-hidden="true">5.</strong> Basic Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="frame.html"><strong aria-hidden="true">5.1.</strong> Frame</a></li><li class="chapter-item expanded "><a href="label.html"><strong aria-hidden="true">5.2.</strong> Label</a></li><li class="chapter-item expanded "><a href="button.html"><strong aria-hidden="true">5.3.</strong> Button</a></li><li class="chapter-item expanded "><a href="checkbutton.html"><strong aria-hidden="true">5.4.</strong> Checkbutton</a></li><li class="chapter-item expanded "><a href="radiobutton.html"><strong aria-hidden="true">5.5.</strong> Radiobutton</a></li><li class="chapter-item expanded "><a href="entry.html"><strong aria-hidden="true">5.6.</strong> Entry</a></li><li class="chapter-item expanded "><a href="combobox.html"><strong aria-hidden="true">5.7.</strong> Combobox</a></li></ol></li><li class="chapter-item expanded "><a href="grid.html"><strong aria-hidden="true">6.</strong> The Grid Geometry Manager</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="columns_and_rows.html"><strong aria-hidden="true">6.1.</strong> Columns and Rows</a></li><li class="chapter-item expanded "><a href="spanning_multiple_cells.html"><strong aria-hidden="true">6.2.</strong> Spanning Multiple Cells</a></li><li class="chapter-item expanded "><a href="layout_within_the_cell.html"><strong aria-hidden="true">6.3.</strong> Layout within the Cell</a></li><li class="chapter-item expanded "><a href="handling_resize.html"><strong aria-hidden="true">6.4.</strong> Handling Resize</a></li><li class="chapter-item expanded "><a href="padding.html"><strong aria-hidden="true">6.5.</strong> Padding</a></li><li class="chapter-item expanded "><a href="additional_grid_features.html"><strong aria-hidden="true">6.6.</strong> Additional Grid Features</a></li><li class="chapter-item expanded "><a href="nested_layouts.html"><strong aria-hidden="true">6.7.</strong> Nested Layouts</a></li></ol></li><li class="chapter-item expanded "><a href="more_widgets.html"><strong aria-hidden="true">7.</strong> More Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="listbox.html"><strong aria-hidden="true">7.1.</strong> Listbox</a></li><li class="chapter-item expanded "><a href="scrollbar.html"><strong aria-hidden="true">7.2.</strong> Scrollbar</a></li><li class="chapter-item expanded "><a href="text.html"><strong aria-hidden="true">7.3.</strong> Text</a></li><li class="chapter-item expanded "><a href="scale.html"><strong aria-hidden="true">7.4.</strong> Scale</a></li><li class="chapter-item expanded "><a href="spinbox.html"><strong aria-hidden="true">7.5.</strong> Spinbox</a></li><li class="chapter-item expanded "><a href="progressbar.html"><strong aria-hidden="true">7.6.</strong> Progressbar</a></li></ol></li><li class="chapter-item expanded "><a href="event_loop.html"><strong aria-hidden="true">8.</strong> Event Loop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blocking_the_event_loop.html"><strong aria-hidden="true">8.1.</strong> Blocking the Event Loop</a></li><li class="chapter-item expanded "><a href="one_step_at_a_time.html"><strong aria-hidden="true">8.2.</strong> One Step at a Time</a></li><li class="chapter-item expanded "><a href="asynchronous_io.html"><strong aria-hidden="true">8.3.</strong> Asynchronous I/O</a></li><li class="chapter-item expanded "><a href="threads_or_processes.html"><strong aria-hidden="true">8.4.</strong> Threads or Processes</a></li><li class="chapter-item expanded "><a href="nested_event_processing.html"><strong aria-hidden="true">8.5.</strong> Nested Event Processing</a></li></ol></li><li class="chapter-item expanded "><a href="menus.html"><strong aria-hidden="true">9.</strong> Menus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="menubars.html"><strong aria-hidden="true">9.1.</strong> Menubars</a></li><li class="chapter-item expanded "><a href="platform_menus.html"><strong aria-hidden="true">9.2.</strong> Platform Menus</a></li><li class="chapter-item expanded "><a href="contextual_menus.html"><strong aria-hidden="true">9.3.</strong> Contextual Menus</a></li></ol></li><li class="chapter-item expanded "><a href="windows_and_dialogs.html"><strong aria-hidden="true">10.</strong> Windows and Dialogs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="creating_and_destroying_windows.html"><strong aria-hidden="true">10.1.</strong> Creating and Destroying Windows</a></li><li class="chapter-item expanded "><a href="window_behavior_and_styles.html"><strong aria-hidden="true">10.2.</strong> Window Behavior and Styles</a></li><li class="chapter-item expanded "><a href="dialog_windows.html"><strong aria-hidden="true">10.3.</strong> Dialog Windows</a></li></ol></li><li class="chapter-item expanded "><a href="organizing_complex_interfaces.html"><strong aria-hidden="true">11.</strong> Organizing Complex Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="separator.html"><strong aria-hidden="true">11.1.</strong> Separator</a></li><li class="chapter-item expanded "><a href="label_frames.html"><strong aria-hidden="true">11.2.</strong> Label Frames</a></li><li class="chapter-item expanded "><a href="paned_windows.html"><strong aria-hidden="true">11.3.</strong> Paned Windows</a></li><li class="chapter-item expanded "><a href="notebook.html"><strong aria-hidden="true">11.4.</strong> Notebook</a></li></ol></li><li class="chapter-item expanded "><a href="fonts_colors_images.html"><strong aria-hidden="true">12.</strong> Fonts, Colors, Images</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fonts.html"><strong aria-hidden="true">12.1.</strong> Fonts</a></li><li class="chapter-item expanded "><a href="colors.html"><strong aria-hidden="true">12.2.</strong> Colors</a></li><li class="chapter-item expanded "><a href="images.html"><strong aria-hidden="true">12.3.</strong> Images</a></li></ol></li><li class="chapter-item expanded "><a href="canvas.html"><strong aria-hidden="true">13.</strong> Canvas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="creating_items.html"><strong aria-hidden="true">13.1.</strong> Creating Items</a></li><li class="chapter-item expanded "><a href="event_bindings.html"><strong aria-hidden="true">13.2.</strong> Event Bindings</a></li><li class="chapter-item expanded "><a href="tags.html"><strong aria-hidden="true">13.3.</strong> Tags</a></li><li class="chapter-item expanded "><a href="scrolling.html"><strong aria-hidden="true">13.4.</strong> Scrolling</a></li></ol></li><li class="chapter-item expanded "><a href="text_chapter.html"><strong aria-hidden="true">14.</strong> Text</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_basics.html"><strong aria-hidden="true">14.1.</strong> The Basics</a></li><li class="chapter-item expanded "><a href="modifying_the_text_in_code.html"><strong aria-hidden="true">14.2.</strong> Modifying the Text in Code</a></li><li class="chapter-item expanded "><a href="formatting_with_tags.html"><strong aria-hidden="true">14.3.</strong> Formatting with Tags</a></li><li class="chapter-item expanded "><a href="events_and_bindings.html"><strong aria-hidden="true">14.4.</strong> Events and Bindings</a></li><li class="chapter-item expanded "><a href="selecting_text.html"><strong aria-hidden="true">14.5.</strong> Selecting Text</a></li><li class="chapter-item expanded "><a href="marks.html"><strong aria-hidden="true">14.6.</strong> Marks</a></li><li class="chapter-item expanded "><a href="images_and_widgets.html"><strong aria-hidden="true">14.7.</strong> Images and Widgets</a></li><li class="chapter-item expanded "><a href="even_more.html"><strong aria-hidden="true">14.8.</strong> Even More</a></li></ol></li><li class="chapter-item expanded "><a href="treeview.html"><strong aria-hidden="true">15.</strong> Treeview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="adding_items_to_the_tree.html"><strong aria-hidden="true">15.1.</strong> Adding Items to the Tree</a></li><li class="chapter-item expanded "><a href="rearranging_items.html"><strong aria-hidden="true">15.2.</strong> Rearranging Items</a></li><li class="chapter-item expanded "><a href="displaying_information_for_each_item.html"><strong aria-hidden="true">15.3.</strong> Displaying Information for each Item</a></li><li class="chapter-item expanded "><a href="item_appearance_and_events.html"><strong aria-hidden="true">15.4.</strong> Item Appearance and Events</a></li><li class="chapter-item expanded "><a href="customizing_the_display.html"><strong aria-hidden="true">15.5.</strong> Customizing the Display</a></li></ol></li><li class="chapter-item expanded "><a href="styles_and_themes.html"><strong aria-hidden="true">16.</strong> Styles and Themes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="using_existing_themes.html"><strong aria-hidden="true">16.1.</strong> Using Existing Themes</a></li><li class="chapter-item expanded "><a href="using_styles.html"><strong aria-hidden="true">16.2.</strong> Using Styles</a></li><li class="chapter-item expanded "><a href="whats_inside_a_style.html"><strong aria-hidden="true">16.3.</strong> What's Inside a Style?</a></li><li class="chapter-item expanded "><a href="manipulating_styles.html"><strong aria-hidden="true">16.4.</strong> Manipulating Styles</a></li><li class="chapter-item expanded "><a href="sound_difficult_to_you.html"><strong aria-hidden="true">16.5.</strong> Sound Difficult to you?</a></li><li class="chapter-item expanded "><a href="advanced_more_on_elements.html"><strong aria-hidden="true">16.6.</strong> Advanced: More on Elements</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This tutorial will quickly get you up and running with Tk 8.6 from Rust. It
provides all the essentials about core Tk concepts, the various widgets,
layout, events and more that you need for your application.</p>
<p>It's not a reference guide. It's not going to cover everything, just the
essentials you need in 95% of applications. The rest you can find in
<a href="https://tcl.tk/man/tcl8.6/TkCmd/contents.htm">reference documentation</a>.</p>
<p>Tk has, for most of its lifetime, gotten a bad rap, to put it mildly. Some of
this has been well deserved, most of it not so much. Like any GUI tool, it can
be used to create absolutely terrible looking and outdated user interfaces.
Still, with the proper care and attention, it can also be used to develop
spectacularly good ones. Most people know about the crappy ones; most of the
good ones people don't even know are done in Tk. In this tutorial, we're going
to focus on what you need to build good user interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-tk"><a class="header" href="#installing-tk">Installing Tk</a></h1>
<p>Before using the <a href="https://crates.io/crates/tk">tk crate</a>, you have to install
the native Tk distribution on your machine. Check your OS and pick the
correspoding chapter to go on.</p>
<h2 id="the-obligatory-first-program"><a class="header" href="#the-obligatory-first-program">The Obligatory First Program</a></h2>
<p>To make sure that everything actually did work, let's try to run a &quot;Hello World&quot;
program in Tk.</p>
<pre><pre class="playground"><code class="language-rust">// cargo run --example the_obligatory_first_program

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();
    root.add_label( -text(&quot;hello,world!&quot;) )?.pack(())?;
    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-tk-on-windows"><a class="header" href="#installing-tk-on-windows">Installing Tk On Windows</a></h1>
<p>On Windows, the easiest way to get Tcl/Tk onto your machine is to install the
&quot;ActiveTcl&quot; distribution from ActiveState. In your web browser, go to
<a href="http://www.activestate.com">activestate</a>, and follow along the links to
download the Community Edition of ActiveTcl for Windows. Make sure you're
downloading an 8.6.x version.  Note that you will need to create an account with
ActiveState (no cost) to download it.</p>
<p>Run the installer, and follow along. You'll end up with a fresh install of
ActiveTcl, usually located in <code>C:\ActiveTcl</code>. From a command prompt, you should
then be able to run a Tcl/Tk 8.6 shell via:</p>
<pre><code>% C:\ActiveTcl\bin\wish
</code></pre>
<p>This should pop up a small window titled &quot;wish&quot;, which will contain your
application. A second, larger window titled &quot;Console&quot; is where you can type in
Tcl/Tk commands. To verify the exact version of Tcl/Tk that you are running,
type the following:</p>
<pre><code>% info patchlevel
</code></pre>
<p>We want this to be returning something like '8.6.9'.</p>
<p>Type &quot;exit&quot; in the console window to exit. You may also want to add
<code>C:\ActiveTcl\bin</code> to your PATH environment variable.</p>
<p>Note: verified install using ActiveTcl 8.6.9.8609-2 on Windows 10.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-tk-on-linux"><a class="header" href="#installing-tk-on-linux">Installing Tk On Linux</a></h1>
<p>Pretty much all Linux distributions have Tcl/Tk packages available via their
package managers, e.g., apt. Usually there are a variety of packages, providing
libraries, command-line tools, development options if you're building
extensions, and many more. On Ubuntu and many other distributions,
<code>apt install tk8.6</code> should be enough.</p>
<p>By the way, you need to install <code>pkg-config</code> to compile the tcl/tk crates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-tk-on-freebsd"><a class="header" href="#installing-tk-on-freebsd">Installing Tk On FreeBSD</a></h1>
<p>Tcl 8.6/Tk 8.6 are available both in ports tree and package repository. To
install Tk 8.6 by downloading binaries from repository, just run
<code>pkg install -y tk86</code> in the shell. To install from source, run
<code>make -C /usr/ports/x11-toolkits/tk86 install</code>.</p>
<p>By the way, you need to install <code>pkg-config</code> to compile the tcl/tk crates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-first-real-example"><a class="header" href="#a-first-real-example">A First (Real) Example</a></h1>
<p>With that out of the way, let's try a slightly more substantial example, which
will give you an initial feel for what the code behind a real Tk program looks
like.</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>We'll create a simple GUI tool to convert a distance in feet to the equivalent
distance in meters. If we were to sketch this out, it might look something like
this:</p>
<table><thead><tr><th style="text-align: center">A sketch of our feet to meters conversion program</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/calcsketch.png" alt="sketch" /></td></tr>
</tbody></table>
<p>So it looks like we have a short text entry widget that will let us type in the
number of feet. A &quot;Calculate&quot; button will get the value out of that entry,
perform the calculation, and put the result in a label below the entry. We've
also got three static labels (&quot;feet,&quot; &quot;is equivalent to,&quot; and &quot;meters&quot;), which
help our user figure out how to work the application.</p>
<p>The next thing we need to do is look at the layout. The widgets that we've
included seem to be naturally divided into a grid with three columns and three
rows. In terms of layout, things seem to naturally divide into three columns and
three rows, as illustrated below:</p>
<table><thead><tr><th style="text-align: center">The layout of our user interface, which follows a 3 x 3 grid</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/calcgrid.png" alt="grid" /></td></tr>
</tbody></table>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example a_first_real_example

use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();
    root.set_wm_title( &quot;Feet to Meters&quot; )?;

    let c = root.add_ttk_frame( &quot;c&quot; -padding(( 3,3,12,12 )))?
        .grid( -column(0) -row(0) -sticky(&quot;nwes&quot;) )?;

    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure( 0, -weight(1) )?;

    let feet = c.add_ttk_entry( &quot;feet&quot; -width(7) -textvariable(&quot;feet&quot;) )?
        .grid( -column(2) -row(1) -sticky(&quot;we&quot;) )?;

    c.add_ttk_label( &quot;meters&quot; -textvariable(&quot;meters&quot;) )?
        .grid( -column(2) -row(2) -sticky(&quot;we&quot;) )?;

    c.add_ttk_button( &quot;calc&quot; -text(&quot;Calculate&quot;) -command(&quot;calculate&quot;) )?
        .grid( -column(3) -row(3) -sticky(&quot;w&quot;) )?;

    c.add_ttk_label( &quot;flbl&quot; -text(&quot;feet&quot;) )?
        .grid( -column(3) -row(1) -sticky(&quot;w&quot;) )?;

    c.add_ttk_label( &quot;islbl&quot; -text(&quot;is equivalent to&quot;) )?
        .grid( -column(1) -row(2) -sticky(&quot;e&quot;) )?;

    c.add_ttk_label( &quot;mlbl&quot; -text(&quot;meters&quot;) )?
        .grid( -column(3) -row(2) -sticky(&quot;w&quot;) )?;

    c.winfo_children()?
        .iter()
        .try_for_each( |child| child.grid_configure( -padx(5) -pady(5) ))?;

    feet.focus()?;

    #[proc]
    fn calculate() -&gt; TkResult&lt;()&gt; {
        let interp = tcl_interp!();
        let feet = interp.get_double(&quot;feet&quot;);
        match feet {
            Ok( feet ) =&gt; {
                let meters = f64::floor( feet * 0.3048 * 10000.0 ) / 10000.0;
                interp.set_double( &quot;meters&quot;, meters )
            },
            Err( _ ) =&gt; interp.set( &quot;meters&quot;, &quot;&quot; ),
        };
        Ok(())
    }

    // it's safe because `fn calculate()` is tagged with `#[proc]`.
    unsafe{ tk.def_proc( &quot;calculate&quot;, calculate ); }

    root.bind_more( event::key_press( TkKey::Return ), &quot;calculate&quot; )?;

    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tk-concepts"><a class="header" href="#tk-concepts">Tk Concepts</a></h1>
<p>With your first example behind you, you now have a basic idea of what a Tk
program looks like and the type of code you need to write to make it work. In
this chapter, we'll step back and look at three broad concepts that you need to
know to understand Tk: widgets, geometry management, and event handling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>Widgets are all the things that you see onscreen. In our example, we had a
button, an entry, a few labels, and a frame. Others are things like checkboxes,
tree views, scrollbars, text areas, and so on. Widgets are often referred to as
&quot;controls.&quot; You'll also sometimes see them referred to as &quot;windows,&quot;
particularly in Tk's documentation. This is a holdover from its X11 roots (under
that terminology, both your toplevel application window and things like a button
would be called windows).</p>
<p>Here is an example showing some of Tk's widgets, which we'll cover individually
shortly.</p>
<table><thead><tr><th style="text-align: center">Several Tk Widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_several_all.png" alt="Several Tk Widgets." /></td></tr>
</tbody></table>
<h2 id="widget-classes"><a class="header" href="#widget-classes">Widget Classes</a></h2>
<p>Widgets are objects, instances of classes that represent buttons, frames, and so
on. When you want to create a widget, the first thing you'll need to do is
identify the specific class of the widget you'd like to instantiate. This
tutorial and the widget roundup will help with that.</p>
<h2 id="widget-hierarchy"><a class="header" href="#widget-hierarchy">Widget Hierarchy</a></h2>
<p>Besides the widget class, you'll need one other piece of information to create
it: its parent. Widgets don't float off in space. Instead, they're contained
within something else, like a window. In Tk, all widgets are part of a widget
(or window) hierarchy, with a single root at the top of the hierarchy.</p>
<p>In our metric conversion example, we had a single frame that was created as a
child of the root window, and that frame had all the other controls as children.
The root window was a container for the frame and was, therefore, the frame's
parent. The complete hierarchy for the example looked like this:</p>
<table><thead><tr><th style="text-align: center">The widget hierarchy of the metric conversion example</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/hierarchy.png" alt="hierarchy.png" /></td></tr>
</tbody></table>
<p>This hierarchy can be arbitrarily deep, so you might have a button in a frame in
another frame within the root window. Even a new window in your application
(often called a toplevel) is part of that same hierarchy. That window and all
its contents form a subtree of the overall widget hierarchy.</p>
<table><thead><tr><th style="text-align: center">Hierarchy of a more substantial application. Leaf nodes (buttons, labels, etc.) omitted</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/deephierarchy.png" alt="deep hierarchy" /></td></tr>
</tbody></table>
<h2 id="creating-widgets-step-by-step"><a class="header" href="#creating-widgets-step-by-step">Creating Widgets, Step By Step</a></h2>
<p>Each separate widget is a Rust struct instance. When instantiating a widget, you
must call corresponding <code>.add_xxx()</code> method of its parent. Each widget is either
given an explicit pathname, or assigned an auto-generated one, which both
differentiates it from other widgets, and also indicates its place in the window
hierarchy.</p>
<p>The root of the hierarchy, the toplevel widget that Tk automatically creates, is
named simply . (dot) and will contain everything else. That is automatically
created when you instantiate Tk. It does not have a parent. For example:</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example creating_widgets_step_by_step

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();
    let content = root
        .add_frame(())? // auto-generated name
        .pack(())?; // make visible
    let _label = content
        .add_label( &quot;lbl&quot; -text(&quot;step by step&quot;) )? // named &quot;lbl&quot;
        .pack(())?; // make visible
    let _button = content
        .add_button( &quot;btn&quot; -text(&quot;quit&quot;) -command(&quot;destroy .&quot;) )? // named &quot;btn&quot;
        .pack(())?; // make visible
    Ok( main_loop() )
}
</code></pre></pre>
<p>Whether or not you save the widget object in a variable is entirely up to you,
depending on whether you'll need to refer to it later.</p>
<h2 id="creating-widgets-in-one-expression-with-geometry"><a class="header" href="#creating-widgets-in-one-expression-with-geometry">Creating Widgets, In One Expression With Geometry</a></h2>
<p>The hierarchy of widget trees, including geometry managers, can be encoded in
one single expression as the argument of <code>tk::Widget::add_widgets()</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example creating_widgets_in_one_expression_with_geometry

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    tk.root().add_widgets(
        -pack( -label( -text(&quot;all in one&quot;) ))
        -pack( -frame( -pack( -button( &quot;btn&quot; -text(&quot;quit&quot;) -command(&quot;destroy .&quot;) ))))
    )?;
    Ok( main_loop() )
}
</code></pre></pre>
<h2 id="creating-widgets-in-one-expression-without-geometry"><a class="header" href="#creating-widgets-in-one-expression-without-geometry">Creating Widgets, In One Expression Without Geometry</a></h2>
<p>Similar with the &quot;All In One&quot; style, except that the geometry managers are
defined separatedly.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example creating_widgets_in_one_expression_without_geometry

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    tk.root().add_widgets(
        -label( &quot;lbl&quot; -text(&quot;geometry managers separated&quot;) )
        -frame( &quot;fr&quot; -button( &quot;btn&quot; -text(&quot;quit&quot;) -command(&quot;destroy .&quot;) ))
    )?;
    tk.pack( &quot;.lbl .fr .fr.btn&quot; )?;
    Ok( main_loop() )
}
</code></pre></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<p>All widgets have several configuration options. These control how the widget is
displayed or how it behaves.</p>
<p>The available options for a widget depend upon the widget class, of course.
There is a lot of consistency between different widget classes, so options that
do pretty much the same thing tend to be named the same. For example, both a
button and a label have a text option to adjust the text that the widget
displays, while a scrollbar would not have a text option since it's not needed.
Similarly, the button has a command option telling it what to do when pushed,
while a label, which holds just static text, does not.</p>
<p>Configuration options can be set when the widget is first created by specifying
their names and values as optional parameters. Later, you can retrieve the
current values of those options, and with a very small number of exceptions,
change them at any time.</p>
<p>This is all best illustrated with the following interactive dialog.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example configuration_options

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    // create a button, passing two options:
    let b = root.add_ttk_button( &quot;b&quot; -text(&quot;Hello&quot;) -command(&quot;button_pressed&quot;) )?.grid(())?;

    // check the current value of the text option:
    assert_eq!( b.cget( text )?.to_string(), &quot;Hello&quot; );

    // check the current value of the command option:
    assert_eq!( b.cget( command )?.to_string(), &quot;button_pressed&quot; );

    // change the value of the text option:
    b.configure( -text(&quot;Goodbye&quot;) )?;

    // check the current value of the text option:
    assert_eq!( b.cget( text )?.to_string(), &quot;Goodbye&quot; );

    Ok( main_loop() )
}
</code></pre></pre>
<h2 id="widget-introspection"><a class="header" href="#widget-introspection">Widget Introspection</a></h2>
<p>Tk exposes a treasure trove of information about each and every widget that your
application can take advantage of. Much of it is available via the winfo
facility; see the winfo command reference for full details.</p>
<p>This short example traverses the widget hierarchy, using each widget's
<code>winfo_children</code> method to identify any child widgets that need to examined. For
each widget, we print some basic information, including it's class (button,
frame, etc.), it's width and height, and it's position relative to it's parent.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example widget_introspection

use tk::*;
use tk::cmd::*;

fn print_hierarchy&lt;TK:TkInstance&gt;( w: &amp;Widget&lt;TK&gt;, depth: usize ) -&gt; TkResult&lt;()&gt; {
    println!( &quot;{}{} w={} h={} x={} y={}&quot;
        , str::repeat( &quot; &quot;, depth )
        , w.winfo_class()?
        , w.winfo_width()?
        , w.winfo_height()?
        , w.winfo_x()?
        , w.winfo_y()?
    );
    for child in w.winfo_children()? {
        print_hierarchy( &amp;child, depth+1 )?;
    }

    Ok(())
}

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    tk.root().add_widgets(
        -pack( -label( -text(&quot;all in one&quot;) ))
        -pack( -frame( -pack( -button( &quot;btn&quot; -text(&quot;quit&quot;) -command(&quot;destroy .&quot;) ))))
    )?;

    print_hierarchy( &amp;tk.root(), 0 )?;

    Ok(())
}
</code></pre></pre>
<p>The following are some of the most useful methods:</p>
<table><thead><tr><th style="text-align: left">Method</th><th style="text-align: left">Functionality</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>winfo_class</code></td><td style="text-align: left">a class identifying the type of widget, e.g. TButton for a themed button</td></tr>
<tr><td style="text-align: left"><code>winfo_children</code></td><td style="text-align: left">a list of widgets that are the direct children of a widget in the hierarchy</td></tr>
<tr><td style="text-align: left"><code>winfo_parent</code></td><td style="text-align: left">parent of the widget in the hierarchy</td></tr>
<tr><td style="text-align: left"><code>winfo_toplevel</code></td><td style="text-align: left">the toplevel window containing this widget</td></tr>
<tr><td style="text-align: left"><code>winfo_width</code></td><td style="text-align: left">current width of the widget; not accurate until appears onscreen</td></tr>
<tr><td style="text-align: left"><code>winfo_height</code></td><td style="text-align: left">current height of the widget; not accurate until appears onscreen</td></tr>
<tr><td style="text-align: left"><code>winfo_reqwidth</code></td><td style="text-align: left">the width the widget requests of the geometry manager (more on this shortly)</td></tr>
<tr><td style="text-align: left"><code>winfo_reqheight</code></td><td style="text-align: left">the height the widget requests of the geometry manager (more on this shortly)</td></tr>
<tr><td style="text-align: left"><code>winfo_x</code></td><td style="text-align: left">the x position of the top-left corner of the widget relative to its parent</td></tr>
<tr><td style="text-align: left"><code>winfo_y</code></td><td style="text-align: left">the y position of the top-left corner of the widget relative to its parent</td></tr>
<tr><td style="text-align: left"><code>winfo_rootx</code></td><td style="text-align: left">the x position of the top-left corner of the widget relative to the entire screen</td></tr>
<tr><td style="text-align: left"><code>winfo_rooty</code></td><td style="text-align: left">the y position of the top-left corner of the widget relative to the entire screen</td></tr>
<tr><td style="text-align: left"><code>winfo_vieweable</code></td><td style="text-align: left">whether the widget is displayed or hidden (all its ancestors in the hierarchy must be viewable for it to be viewable)</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-management"><a class="header" href="#geometry-management">Geometry Management</a></h1>
<p>If you've been running code interactively, you've probably noticed that just by
creating widgets, they didn't appear onscreen. Placing widgets onscreen, and
precisely where they are placed, is a separate step called geometry management.</p>
<p>In our example, positioning each widget was accomplished by the grid command. We
specified the column and row we wanted each widget to go in, how things were to
be aligned within the grid, etc. Grid is an example of a geometry manager (of
which there are several in Tk, grid being the most useful). For now, we'll look
at geometry management in general; we'll talk about grid in a later chapter.</p>
<p>A geometry manager's job is to figure out exactly where those widgets are going
to be put. This turns out to be a complex optimization problem, and a good
geometry manager relies on quite sophisticated algorithms. A good geometry
manager provides the flexibility, power, and ease of use that makes programmers
happy. It also makes it easy to create good looking user interface layouts
without needing to jump through hoops. Tk's grid is, without a doubt, one of the
absolute best. A poor geometry manager... well, all the Java programmers who
have suffered through &quot;GridBagLayout&quot; please raise their hands.</p>
<blockquote>
<p>We'll go into more detail in a later chapter, but grid was introduced several
years after Tk became popular. Before that, an older geometry manager named pack
was most commonly used. It's very powerful, but is much harder to use, and makes
it extremely difficult to create layouts that look appealing today.
Unfortunately, much of the example Tk code and documentation out there uses pack
instead of grid (a good clue to how current it is). The widespread use of pack
is one major reason that so many Tk user interfaces look terrible. Start new
code with grid, and upgrade old code when you can.</p>
</blockquote>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>The problem for a geometry manager is to take all the different widgets the
program creates, plus the program's instructions for where in the window each
should go (explicitly, or more often, relative to other widgets), and then
actually position them in the window.</p>
<p>In doing so, the geometry manager has to balance multiple constraints. Consider
these situations:</p>
<ul>
<li>
<p>The widgets may have a natural size, e.g., the natural width of a label would
depend on the text it displays and the font used to display it. What if the
application window containing all these different widgets isn't big enough to
accommodate them? The geometry manager must decide which widgets to shrink to
fit, by how much, etc.</p>
</li>
<li>
<p>If the application window is bigger than the natural size of all the widgets,
how is the extra space used? Is extra space placed between each widget, and if
so, how is that space distributed? Is it used to make certain widgets larger
than they normally want to be, such as a text entry growing to fill a wider
window? Which widgets should grow?</p>
</li>
<li>
<p>If the application window is resized, how does the size and position of each
widgets inside it change? Will certain areas (e.g., a text entry area) expand or
shrink while other parts stay the same size, or is the area distributed
differently? Do certain widgets have a minimum size that you want to avoid going
below? A maximum size? Does the window itself have a minimum or maximum size?</p>
</li>
<li>
<p>How can widgets in different parts of the user interface be aligned with each
other? How much space should be left between them? This is needed to present a
clean layout and comply with platform-specific user interface guidelines.</p>
</li>
<li>
<p>For a complex user interface, which may have many frames nested in other
frames nested in the window (etc.), how can all the above be accomplished,
trading off the conflicting demands of different parts of the entire user
interface?</p>
</li>
</ul>
<h1 id="how-it-works"><a class="header" href="#how-it-works">How it Works</a></h1>
<p>Geometry management in Tk relies on the concept of master and slave widgets. A
master is a widget, typically a toplevel application window or a frame, which
contains other widgets, called slaves. You can think of a geometry manager
taking control of the master widget and deciding how all the slave widgets will
be displayed within.</p>
<blockquote>
<p>The computing community has embraced the more general societal trend towards
more diversity, sensitivity, and awareness about the impacts of language.
Recognizing this, the Tk core will slowly be adopting a more inclusive set of
terminology. For example, where it makes sense, &quot;parent&quot; and &quot;child&quot; will be
preferred over &quot;master&quot; and &quot;slave.&quot; To preserve backward compatibility, the
current terminology will not be disappearing. This is something to be aware of
for the future. For more details, see <a href="https://tip.tcl.tk/581">TIP #581</a>.</p>
</blockquote>
<p>Your program tells the geometry manager what slaves to manage within the master,
i.e., via calling <code>grid</code>. Your program also provides hints as to how it would
like each slave to be displayed, e.g., via the <code>column</code> and <code>row</code> options. You
can also provide other things to the geometry manager. For example, we used
<code>columnconfigure</code> and <code>rowconfigure</code> to indicate the columns and rows we'd like
to expand if there is extra space available in the window. It's worth noting
that all these parameters and hints are specific to <code>grid</code>; other geometry
managers would use different ones.</p>
<p>The geometry manager takes all the information about the slaves in the master,
as well as information about how large the master is. It then asks each slave
widget for its natural size, i.e., how large it would ideally like to be
displayed. The geometry manager's internal algorithm calculates the area each
slave will be allocated (if any!). The slave is then responsible for rendering
itself within that particular rectangle. And of course, any time the size of the
master changes (e.g., because the toplevel window was resized), the natural size
of a slave changes (e.g., because we've changed the text in a label), or any of
the geometry manager parameters change (e.g., like <code>row</code>, <code>column</code>, or <code>sticky</code>)
we repeat the whole thing.</p>
<p>This all works recursively as well. In our example, we had a content frame
inside the toplevel application window, and then several other widgets inside
the content frame. We, therefore, had to manage the geometry for two different
masters. At the outer level, the toplevel window was the master, and the content
frame was its slave. At the inner level, the content frame was the master, with
each of the other widgets being slaves. Notice that the same widget, e.g., the
content frame, can be both a master and a slave! As we saw previously, this
widget hierarchy can be nested much more deeply.</p>
<blockquote>
<p>While each master can be managed by only one geometry manager (e.g. <code>grid</code>),
different masters can have different geometry managers. While <code>grid</code> is the
right choice most of the time, others may make sense for a particular layout
used in one part of your user interface. Other Tk geometry managers include
<code>pack</code>, which we've mentioned, and <code>place</code>, which leaves all layout decisions
entirely up to you. Some complex widgets like <code>canvas</code> and <code>text</code> let you embed
other widgets, making them de facto geometry managers.</p>
</blockquote>
<blockquote>
<p>Finally, we've been making the assumption that slave widgets are the immediate
children of their master in the widget hierarchy. While this is usually the
case, and mostly there's no good reason to do it any other way, it's also
possible (with some restrictions) to get around this.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h1>
<p>Tk, as with most other user interface toolkits, runs an event loop that receives
events from the operating system. These are things like button presses,
keystrokes, mouse movement, window resizing, and so on.</p>
<p>Generally, Tk takes care of managing this event loop for you. It will figure out
what widget the event applies to (did a user click on this button? if a key was
pressed, which textbox had the focus?), and dispatch it accordingly. Individual
widgets know how to respond to events; for example, a button might change color
when the mouse moves over it, and revert back when the mouse leaves.</p>
<blockquote>
<p>It's critical in event-driven applications that the event loop not be blocked.
The event loop should run continuously, normally executing dozens of steps per
second. At every step, it processes an event. If your program is performing a
long operation, it can potentially block the event loop. In that case, no events
would be processed, no drawing would be done, and it would appear as if your
application is frozen. There are many ways to avoid this happening, mostly
related to the structure of your application. We'll discuss this in more detail
in a later chapter.</p>
</blockquote>
<h2 id="command-callbacks"><a class="header" href="#command-callbacks">Command Callbacks</a></h2>
<p>You often want your program to handle some event in a particular way, e.g., do
something when a button is pushed. For those events that are most frequently
customized (what good is a button without something happening when you press
it?), the widget will allow you to specify a callback as a widget configuration
option. We saw this in the example with the <code>command</code> option of the button.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc] fn calculate() { /* omitted */ }

content.add_ttk_button( &quot;.c.calc&quot; -text(&quot;Calculate&quot;) -command(&quot;calculate&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="binding-to-events"><a class="header" href="#binding-to-events">Binding to Events</a></h2>
<p>For events that don't have a widget-specific command callback associated with
them, you can use Tk's bind to capture any event, and then (like with callbacks)
execute an arbitrary piece of code.</p>
<p>Here's a (silly) example showing a label responding to different events. When an
event occurs, a description of the event is displayed in the label.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example binding_to_events

use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;

    let l = tk.root().add_ttk_label( &quot;l&quot; -text(&quot;Starting...&quot;) )?.grid(())?;

    l.bind( event::enter(), tclosure!( tk, move || l.configure( -text(&quot;Moved mouse inside&quot;) )))?;

    l.bind( event::leave(), tclosure!( tk, move || l.configure( -text(&quot;Moved mouse outside&quot;) )))?;

    l.bind( event::button_press_1(), tclosure!( tk, move || l.configure( -text(&quot;Clicked left mouse button&quot;) )))?;

    l.bind( event::button_press_3(), tclosure!( tk, move || l.configure( -text(&quot;Clicked right mouse button&quot;) )))?;

    l.bind( event::double().button_press_1(), tclosure!( tk, move || l.configure( -text(&quot;Double clicked&quot;) )))?;

    l.bind( event::button_3().motion(), tclosure!( tk, args: &quot;%x %y hello&quot;,
        move |x: i32, y: i32, _z: Obj| -&gt; TkResult&lt;()&gt; {
            Ok( l.configure( -text( format!( &quot;right button drag to {} {}&quot;, x, y )))? )
        }
    ))?;

    Ok( main_loop() )
}
</code></pre></pre>
<p>The first two bindings are pretty straightforward, just watching for simple
events. An <code>event::enter()</code> event means the mouse has moved over top the widget,
while the <code>event::Leave()</code> event is generated when the mouse moves outside the
widget to a different one.</p>
<p>The next binding looks for a mouse click, specifically a <code>event::button_press_1</code>
event. Here, the <code>button_press</code> is the actual event, but the <code>_1</code> is an event
detail specifying the left (main) mouse button on the mouse. The binding will
only trigger when a <code>button_press</code> event is generated involving the main mouse
button. If another mouse button was clicked, this binding would ignore it.</p>
<p>This next binding looks for a <code>event::button_press_3</code> event. It will respond to
events generated when the right mouse button is clicked. The next binding,
<code>event::double().button_press_1()</code> adds another modifier, Double, and so will
respond to the left mouse button being double clicked.</p>
<p>The last binding also uses a modifier: capture mouse movement (Motion), but only
when the right mouse button <code>button_3</code> is held down. This binding also shows an
example of how to use event parameters. Many events, such as mouse clicks or
movement carry additional information like the current position of the mouse. Tk
provides access to these parameters in Tcl callback scripts through the use of
percent substitutions. These percent substitutions let you capture them so they
can be used in your script.</p>
<h2 id="multiple-bindings-for-an-event"><a class="header" href="#multiple-bindings-for-an-event">Multiple Bindings for an Event</a></h2>
<p>We've just seen how event bindings can be set up for an individual widget. When
a matching event is received by that widget, the binding will trigger. But
that's not all you can do.</p>
<p>Your binding can capture not just a single event, but a short sequence of
events. The <code>event::double().button_press_1()</code> binding triggers when two mouse
clicks occur in a short time. You can do the same thing to capture two keys
pressed in a row, e.g., <code>key_press( TkKey::A ).key_press( TkKey::B )</code>.</p>
<p>You can also set up an event binding on a toplevel window. When a matching event
occurs anywhere in that window, the binding will be triggered. In our example,
we set up a binding for the Return key on the main application toplevel window.
If the Return key was pressed when any widget in the toplevel window had the
focus, that binding would fire.</p>
<p>Less commonly, you can create event bindings that are triggered when a matching
event occurs anywhere in the application, or even for events received by any
widget of a given class, e.g., all buttons.</p>
<blockquote>
<p>More than one binding can fire for an event. This keeps event handlers concise
and limited in scope, meaning more modular code. For example, the behavior of
each widget class in Tk is itself defined with script-level event bindings.
These stay separate from event bindings in your application. Event bindings can
also be changed or deleted. They can be modified to alter event handling for
widgets of a certain class or parts of your application. You can reorder,
extend, or change the sequence of event bindings that will be triggered for each
widget; see the bindtags command reference if you're curious.</p>
</blockquote>
<h2 id="available-events"><a class="header" href="#available-events">Available Events</a></h2>
<p>The most commonly used events are described below, along with the circumstances
when they are generated. Some are generated on some platforms and not others.
For a complete description of all the different event names, modifiers, and the
different event parameters that are available with each, the best place to look
is the bind command reference.</p>
<table><thead><tr><th style="text-align: left">event name</th><th style="text-align: left">description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>activate</code></td><td style="text-align: left">Window has become active.</td></tr>
<tr><td style="text-align: left"><code>deactivate</code></td><td style="text-align: left">Window has been deactivated.</td></tr>
<tr><td style="text-align: left"><code>mouse_wheel</code></td><td style="text-align: left">Scroll wheel on mouse has been moved.</td></tr>
<tr><td style="text-align: left"><code>key_press</code></td><td style="text-align: left">Key on keyboard has been pressed down.</td></tr>
<tr><td style="text-align: left"><code>key_release</code></td><td style="text-align: left">Key has been released.</td></tr>
<tr><td style="text-align: left"><code>button_press</code></td><td style="text-align: left">A mouse button has been pressed.</td></tr>
<tr><td style="text-align: left"><code>button_release</code></td><td style="text-align: left">A mouse button has been released.</td></tr>
<tr><td style="text-align: left"><code>motion</code></td><td style="text-align: left">Mouse has been moved.</td></tr>
<tr><td style="text-align: left"><code>configure</code></td><td style="text-align: left">Widget has changed size or position.</td></tr>
<tr><td style="text-align: left"><code>destroy</code></td><td style="text-align: left">Widget is being destroyed.</td></tr>
<tr><td style="text-align: left"><code>focus_in</code></td><td style="text-align: left">Widget has been given keyboard focus.</td></tr>
<tr><td style="text-align: left"><code>focus_out</code></td><td style="text-align: left">Widget has lost keyboard focus.</td></tr>
<tr><td style="text-align: left"><code>enter</code></td><td style="text-align: left">Mouse pointer enters widget.</td></tr>
<tr><td style="text-align: left"><code>leave</code></td><td style="text-align: left">Mouse pointer leaves widget.</td></tr>
</tbody></table>
<p>Event detail for mouse events are the button that was pressed, e.g. <code>1</code>, <code>2</code>, or
<code>3</code>. For keyboard events, it's the specific key, e.g. <code>A</code>, <code>9</code>, <code>space</code>, <code>plus</code>,
<code>comma</code>, <code>equal</code>. A complete list can be found in the keysyms command reference.</p>
<p>Event modifiers for include, e.g. <code>button_1</code> to signify the main mouse button
being held down, <code>double</code> or <code>triple</code> for sequences of the same event. Key
modifiers for when keys on the keyboard are held down inline <code>control</code>, <code>shift</code>,
<code>alt</code>, <code>option</code>, and <code>command</code>.</p>
<h2 id="virtual-events"><a class="header" href="#virtual-events">Virtual Events</a></h2>
<p>The events we've seen so far are low-level operating system events like mouse
clicks and window resizes. Many widgets also generate higher level or semantic
events called virtual events. These are indicated by <code>event::virtual_event()</code>,
e.g., <code>event::virtual_event( &quot;foo&quot; )</code>.</p>
<p>For example, a listbox widget will generate a <code>event::listbox_select()</code>
virtual event whenever its selection changes. The same virtual event is
generated whether a user clicked on an item, moved to it using the arrow keys,
or some other way. Virtual events avoid the problem of setting up multiple,
possibly platform-specific event bindings to capture common changes. The
available virtual events for a widget will be listed in the documentation for
the widget class.</p>
<p>Tk also defines virtual events for common operations that are triggered in
different ways for different platforms. These include <code>event::cut()</code>,
<code>event::copy()</code> and <code>event::paste()</code>.</p>
<p>You can define your own virtual events, which can be specific to your
application. This can be a useful way to keep platform-specific details isolated
in a single module, while you use the virtual event throughout your application.
Your own code can generate virtual events that work in exactly the same way that
virtual events generated by Tk do.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>root.event_generate( event::virtual_event( &quot;MyOwnEvent&quot; ))?;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-widgets"><a class="header" href="#basic-widgets">Basic Widgets</a></h1>
<p>This chapter introduces the basic Tk widgets that you'll find in just about any
user interface: frames, labels, buttons, checkbuttons, radiobuttons, entries,
and comboboxes. By the end, you'll know how to use all the widgets you'd ever
need for a typical fill-in-the-form type of user interface.</p>
<p>You'll find it easiest to read this chapter (and those following that discuss
more widgets) in order. Because there is so much commonality between many
widgets, we'll introduce certain concepts when describing one widget that will
also apply to a widget we describe later. Rather than going over the same ground
multiple times, we'll refer back to when the concept was first introduced.</p>
<p>At each widget is introduced, we'll refer to the widget roundup page for the
specific widget, as well as the Tk reference manual page. As a reminder, this
tutorial highlights the most useful parts of Tk and how to use them to build
effective modern user interfaces. The reference documentation, which details
everything that can be done in Tk, serves a very different purpose.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frame"><a class="header" href="#frame">Frame</a></h1>
<p>A <em>frame</em> is a widget that displays as a simple rectangle. Frames help to
organize your user interface, often both visually and at the coding level.
Frames often act as master widgets for a geometry manager like <code>grid</code>, which
manages the slave widgets contained within the frame.</p>
<table><thead><tr><th style="text-align: center">Frame widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_frame_all.png" alt="Frame widgets." /></td></tr>
</tbody></table>
<p>Frames are created using the <code>add_ttk_frame()</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = root.add_ttk_frame( &quot;frame&quot; )?;
<span class="boring">}
</span></code></pre></pre>
<p>Frames can take several different configuration options, which can alter how
they are displayed.</p>
<h2 id="requested-size"><a class="header" href="#requested-size">Requested Size</a></h2>
<p>Typically, the size of a frame is determined by the size and layout of any
widgets within it. In turn, this is controlled by the geometry manager that
manages the contents of the frame itself.</p>
<p>If, for some reason, you want an empty frame that does not contain other
widgets, you can instead explicitly set its size using the width and/or height
configuration options (otherwise, you'll end up with a very small frame indeed).</p>
<p>Screen distances such as width and height are usually specified as a number of
pixels screen. You can also specify them via one of several suffixes. For
example, 350 means 350 pixels, 350c means 350 centimeters, 350m means 350
millimeters, 350i means 350 inches, and 350p means 350 printer's points (1/72
inch).</p>
<blockquote>
<p>Remember, if you request that a frame (or any widget) to have a given size,
the geometry manager has the final say. If things aren't showing up the way you
want them, make sure to check there too.</p>
</blockquote>
<h2 id="padding"><a class="header" href="#padding">Padding</a></h2>
<p>The padding configuration option is used to request extra space around the
inside of the widget. If you're putting other widgets inside the frame, there
will be a bit of a margin all the way around. You can specify the same padding
for all sides, different horizontal and vertical padding, or padding for each
side separately.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 5 pixels on all sides
frame.configure( -padding( 5 ))?;

// 5 on left and right, 10 on top and bottom
frame.configure( -padding(( 5, 10 )))?;

// left: 5, top: 7, right: 10, bottom: 12
frame.configure( -padding(( 5, 7, 10, 12 )))?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="borders"><a class="header" href="#borders">Borders</a></h2>
<p>You can display a border around a frame widget to visually separate it from its
surroundings. You'll see this often used to make a part of the user interface
look sunken or raised. To do this, you need to set the borderwidth configuration
option (which defaults to 0, i.e., no border), and the relief option, which
specifies the visual appearance of the border. This can be one of: flat
(default), raised, sunken, solid, ridge, or groove.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>frame.configure( -borderwidth(2) -relief(&quot;sunken&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="changing-styles"><a class="header" href="#changing-styles">Changing Styles</a></h2>
<p>Frames have a style configuration option, which is common to all of the themed
widgets. This lets you control many other aspects of their appearance or
behavior. This is a bit more advanced, so we won't go into it in too much detail
right now. But here's a quick example of creating a &quot;Danger&quot; frame with a red
background and a raised border.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let danger = tk.new_ttk_style( &quot;Danger.TFrame&quot;, None );
danger.configure( -background(&quot;red&quot;) -borderwidth(5) -relief(&quot;raised&quot;) )?;

let frame = root
    .add_ttk_frame( &quot;frame&quot; -width(200) -height(200) -style(&amp;danger) )?
    .grid(())?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>What elements of widgets can be changed by styles vary by widget and platform.
On Windows and Linux, it does what you'd expect. On current macOS, the frame
will have a red raised border, but the background will remain the default grey.
Much more on why this is in a later chapter.</p>
</blockquote>
<blockquote>
<p>Styles mark a sharp departure from how most aspects of a widget's visual
appearance were changed in the &quot;classic&quot; Tk widgets. In classic Tk, you could
provide a wide range of options to finely control every aspect of an individual
widget's behavior, e.g., foreground color, background color, font, highlight
thickness, selected foreground color, and padding. When using the new themed
widgets, these changes are made by modifying styles, not adding options to each
widget.
As such, many options you may be familiar with in certain classic widgets are
not present in their themed version. However, overuse of such options was a key
factor undermining the appearance of Tk applications, especially when used
across different platforms. Transitioning from classic to themed widgets
provides an opportune time to review and refine how (and if!) such appearance
changes are made.</p>
</blockquote>
<h2 id="run-example"><a class="header" href="#run-example">Run Example</a></h2>
<p><code>cargo run --example frame</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="label"><a class="header" href="#label">Label</a></h1>
<p>A <em>label</em> is a widget that displays text or images, typically that users will
just view but not otherwise interact with. Labels are used for to identify
controls or other parts of the user interface, provide textual feedback or
results, etc.</p>
<table><thead><tr><th style="text-align: center">Frame widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_label_all.png" alt="Label widgets." /></td></tr>
</tbody></table>
<p>Labels are created using the <code>add_ttk_label()</code> method. Often, the text or image
the label will display are specified via configuration options at the same time:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_label( &quot;label&quot; -text(&quot;Full name&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Like frames, labels can take several different configuration options, which can
alter how they are displayed.</p>
<h2 id="displaying-text"><a class="header" href="#displaying-text">Displaying Text</a></h2>
<p>The text configuration option (shown above when creating the label) is the most
commonly used, particularly when the label is purely decorative or explanatory.
You can change what text is displayed by modifying this configuration option.
This can be done at any time, not only when first creating the label.</p>
<p>You can also have the widget monitor a variable in your script. Anytime the
variable changes, the label will display the new value of the variable. This is
done with the <code>textvariable</code> option:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>label.configure( -textvariable(&quot;resultContents&quot;) )?;
tk.set( &quot;resultContents&quot;, &quot;New value to display&quot; );
<span class="boring">}
</span></code></pre></pre>
<p>Variables must be global, or the fully qualified name given for those within a
namespace.</p>
<h2 id="displaying-images"><a class="header" href="#displaying-images">Displaying Images</a></h2>
<p>Labels can also display an image instead of text. If you just want an image
displayed in your user interface, this is normally the way to do it. We'll go
into images in more detail in a later chapter, but for now, let's assume you
want to display a GIF stored in a file on disk. This is a two-step process.
First, you will create an image &quot;object.&quot; Then, you can tell the label to use
that object via its <code>image</code> configuration option:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let img = image_create_photo( -file(&quot;myimage.gif&quot;) )?;
label.configure( -image(img) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Labels can also display both an image and text at the same time. You'll often
see this in toolbar buttons. To do so, use the <code>compound</code> configuration option.
The default value is <code>none</code>, meaning display only the image if present; if there
is no image, display the <code>text</code> specified by the <code>text</code> or <code>textvariable</code>
options.  Other possible values for the <code>compound</code> option are: <code>text</code> (text
only), <code>image</code> (image only), <code>center</code> (text in the center of image), <code>top</code>
(image above text), <code>left</code>, <code>bottom</code>, and <code>right</code>.</p>
<h2 id="fonts-colors-and-more"><a class="header" href="#fonts-colors-and-more">Fonts, Colors, and More</a></h2>
<p>Like with frames, you normally don't want to change things like fonts and colors
directly. If you need to change them (e.g., to create a special type of label),
the preferred method would be to create a new style, which is then used by the
widget with the style option.</p>
<p>Unlike most themed widgets, the label widget also provides explicit
widget-specific configuration options as an alternative. Again, you should use
these only in special one-off cases when using a style didn't necessarily make
sense.</p>
<p>You can specify the font used to display the label's text using the font
configuration option. While we'll go into fonts in more detail in a later
chapter, here are the names of some predefined fonts you can use:</p>
<table><thead><tr><th style="text-align: left">name</th><th style="text-align: left">description</th></tr></thead><tbody>
<tr><td style="text-align: left">TkDefaultFont</td><td style="text-align: left">Default for all GUI items not otherwise specified.</td></tr>
<tr><td style="text-align: left">TkTextFont</td><td style="text-align: left">Used for entry widgets, listboxes, etc.</td></tr>
<tr><td style="text-align: left">TkFixedFont</td><td style="text-align: left">A standard fixed-width font.</td></tr>
<tr><td style="text-align: left">TkMenuFont</td><td style="text-align: left">The font used for menu items.</td></tr>
<tr><td style="text-align: left">TkHeadingFont</td><td style="text-align: left">A font for column headings in lists and tables.</td></tr>
<tr><td style="text-align: left">TkCaptionFont</td><td style="text-align: left">A font for window and dialog caption bars.</td></tr>
<tr><td style="text-align: left">TkSmallCaptionFont</td><td style="text-align: left">Smaller captions for subwindows or tool dialogs.</td></tr>
<tr><td style="text-align: left">TkIconFont</td><td style="text-align: left">A font for icon captions.</td></tr>
<tr><td style="text-align: left">TkTooltipFont</td><td style="text-align: left">A font for tooltips.</td></tr>
</tbody></table>
<blockquote>
<p>Because font choices are so platform-specific, be careful of hardcoding
specifics (font families, sizes, etc.). This is something else you'll see in
many older Tk programs that can make them look ugly.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>label.configure( -font(&quot;TkDefaultFont&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>The foreground (text) and background color of the label can also be changed via
the <code>foreground</code> and <code>background</code> configuration options. Colors are covered in
detail later, but you can specify them as either color names (e.g., <code>red</code>) or
hex RGB codes (e.g., <code>#ff340a</code>).</p>
<p>Labels also accept the relief configuration option discussed for frames to make
them appear sunken or raised.</p>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>While the overall layout of the label (i.e., where it is positioned within the
user interface, and how large it is) is determined by the geometry manager,
several options can help you control how the label will be displayed within the
rectangle the geometry manager gives it.</p>
<p>If the box given to the label is larger than the label requires for its
contents, you can use the <code>anchor</code> option to specify what edge or corner the label
should be attached to, which would leave any empty space in the opposite edge or
corner. Possible values are specified as compass directions: <code>n</code> (north, or top
edge), <code>ne</code>, (north-east, or top right corner), <code>e</code>, <code>se</code>, <code>s</code>, <code>sw</code>, <code>w</code>, <code>nw</code>
or <code>center</code>.</p>
<blockquote>
<p>Things not appearing where you think they should? It may be that the geometry
manager is not putting the label where you think it is. For example, if you're
using <code>grid</code>, you may need to adjust the <code>sticky</code> options. When debugging, it
can help to change the background color of each widget, so you know exactly
where each is positioned. This is a good example of those &quot;one-off&quot; cases we
just mentioned where you might use configuration options rather than styles to
modify appearance. </p>
</blockquote>
<h2 id="multi-line-labels"><a class="header" href="#multi-line-labels">Multi-line Labels</a></h2>
<p>Labels can display more than one line of text. To do so, embed carriage returns
(<code>\n</code>) in the <code>text</code> (or <code>textvariable</code>) string. Labels can also automatically
wrap your text into multiple lines via the <code>wraplength</code> option, which specifies
the maximum length of a line (in pixels, centimeters, etc.).</p>
<blockquote>
<p>Multi-line labels are a replacement for the older <code>message</code> widgets in classic
Tk.</p>
</blockquote>
<p>You can also control how the text is justified via the <code>justify</code> option. It can
have the values <code>left</code>, <code>center</code>, or <code>right</code>. If you have only a single line of
text, you probably want the <code>anchor</code> option instead.</p>
<h2 id="run-example-1"><a class="header" href="#run-example-1">Run Example</a></h2>
<p><code>cargo run --example label</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<p>A <em>button</em>, unlike a frame or label, is very much there to interact with. Users
press a button to perform an action. Like labels, they can display text or
images, but accept additional options to change their behavior.</p>
<table><thead><tr><th style="text-align: center">Button widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_button_all.png" alt="Button widgets." /></td></tr>
</tbody></table>
<p>Buttons are created using the <code>add_ttk_button</code> method. Typically, their contents
and command callback are specified at the same time:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_button( &quot;button&quot; -text(&quot;Okay&quot;) -command(&quot;submitForm&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Typically, their contents and command callback are specified at the same time.
As with other widgets, buttons can take several different configuration options,
including the standard <code>style</code> option, which can alter their appearance and
behavior.</p>
<h2 id="text-or-image"><a class="header" href="#text-or-image">Text or Image</a></h2>
<p>Buttons take the same <code>text</code>, <code>textvariable</code> (rarely used), <code>image</code>, and
<code>compound</code> configuration options as labels. These control whether the button
displays text and/or an image.</p>
<p>Buttons have a <code>default</code> configuration option. If specified as <code>active</code>, this
tells Tk that the button is the default button in the user interface; otherwise
it is <code>normal</code>. Default buttons are invoked if users hit the Return or Enter
key). Some platforms and styles will draw this default button with a different
border or highlight. Note that setting this option doesn't create an event
binding that will make the Return or Enter key activate the button; that you
have to do yourself.</p>
<h2 id="the-command-callback"><a class="header" href="#the-command-callback">The Command Callback</a></h2>
<p>The <code>command</code> option connects the button's action and your application. When a
user presses the button, the script provided by the option is evaluated by the
interpreter.</p>
<p>You can also ask the button to invoke the command callback from your
application. That way, you don't need to repeat the command to be invoked
several times in your program. If you change the command attached to the button,
you don't need to change it elsewhere too. Sounds like a useful way to add that
event binding on our default button, doesn't it?</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let button = parent
    .add_ttk_button( &quot;action&quot; -text(&quot;Action&quot;) -default(&quot;active&quot;) -command(&quot;myaction&quot;) )?
    .pack(())?;

parent.bind(
    event::key_press( TkKey::Return ),
    tclosure!( tk, move || -&gt; InterpResult&lt;Obj&gt; { button.invoke() })
)?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Standard behavior for dialog boxes and many other windows on most platforms is
to set up a binding on the window for the Return key
(<code>event::key_press( TkKey::Return )</code>, to invoke the active button if it exists,
as we've done here. If there is a &quot;Close&quot; or &quot;Cancel&quot; button, create a binding
to the Escape key (<code>event::key_press( TkKey::Escape )</code>). On macOS, you should
additionally bind the Enter key on the keyboard
(<code>event::key_press( TkKey::Enter )</code>) to the active button, and Command-period
(<code>event::command().key_press( TkKey::period )</code>) to the close or cancel button.</p>
</blockquote>
<h2 id="button-state"><a class="header" href="#button-state">Button State</a></h2>
<p>Buttons and many other widgets start off in a normal state. A button will
respond to mouse movements, can be pressed, and will invoke its command
callback. Buttons can also be put into a disabled state, where the button is
greyed out, does not respond to mouse movements, and cannot be pressed. Your
program would disable the button when its command is not applicable at a given
point in time.</p>
<p>All themed widgets maintain an internal state, represented as a series of binary
flags. Each flag can either be set (on) or cleared (off). You can set or clear
these different flags, and check the current setting using the <code>state</code> and
<code>instate</code> methods. Buttons make use of the <code>disabled</code> flag to control whether or
not users can press the button. For example:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b.set_state(    TtkState::Disabled )?; // set the disabled flag
b.set_state(   !TtkState::Disabled )?; // clear the disabled flag
b.instate(      TtkState::Disabled )?; // 1 if disabled, else 0
b.instate(     !TtkState::Disabled )?; // 1 if not disabled, else 0
b.instate_run( !TtkState::Disabled,
                        &quot;myaction&quot; )?; // execute 'myaction' if not disabled
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-2"><a class="header" href="#run-example-2">Run Example</a></h2>
<p><code>cargo run --example button</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkbutton"><a class="header" href="#checkbutton">Checkbutton</a></h1>
<p>A <em>checkbutton</em> widget is like a regular button that also holds a binary value
of some kind (i.e., a toggle). When pressed, a checkbutton flips the toggle and
then invokes its callback. Checkbutton widgets are frequently used to allow
users to turn an option on or off.</p>
<table><thead><tr><th style="text-align: center">Checkbutton widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_checkbutton_all.png" alt="Checkbutton widgets." /></td></tr>
</tbody></table>
<p>Checkbuttons are created using the <code>add_ttk_checkbutton</code> method. Typically,
their contents and behavior are specified at the same time:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_checkbutton( &quot;check&quot; -text(&quot;Use Metric&quot;) -command( &quot;metricChanged&quot; )
    -variable(&quot;measuresystem&quot;) -onvalue(&quot;metric&quot;) -offvalue(&quot;imperial&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Checkbuttons use many of the same options as regular buttons but add a few more.
The <code>text</code>, <code>textvariable</code>, <code>image</code>, and <code>compound</code> configuration options
control the display of the label (next to the checkbox itself). Similarly, the
<code>command</code> option lets you specify a command to be called every time a user
toggles the checkbutton; and the <code>invoke</code> method will also execute the same
command. The <code>state</code> and <code>instate</code> methods allow you to manipulate the
<code>disabled</code> state flag to enable or disable the checkbutton. </p>
<h2 id="widget-value"><a class="header" href="#widget-value">Widget Value</a></h2>
<p>Unlike regular buttons, checkbuttons also hold a value. We've seen before how
the <code>textvariable</code> option can link the label of a widget to a variable in your
program. The <code>variable</code> option for checkbuttons behaves similarly, except it
links a variable to current value of the widget. The variable is updated
whenever the widget is toggled. By default, checkbuttons use a value of 1 when
the widget is checked, and 0 when not checked. These can be changed to something
else using the <code>onvalue</code> and <code>offvalue</code> options.</p>
<p>A checkbutton doesn't automatically set (or create) the linked variable.
Therefore, your program needs to initialize it to the appropriate starting
value.</p>
<p>What happens when the linked variable contains neither the <code>onvalue</code> or the
<code>offvalue</code> (or even doesn't exist)? In that case, the checkbutton is put into a
special &quot;tristate&quot; or indeterminate mode. When in this mode, the checkbox might
display a single dash, instead of being empty or holding a checkmark.
Internally, the state flag <code>alternate</code> is set, which you can inspect via the
<code>instate</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>check.instate( TtkState::Alternate )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-3"><a class="header" href="#run-example-3">Run Example</a></h2>
<p><code>cargo run --example checkbutton</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="radiobutton"><a class="header" href="#radiobutton">Radiobutton</a></h1>
<p>A <em>radiobutton</em> widget lets you choose between one of several mutually exclusive
choices. Unlike a checkbutton, they are not limited to just two options.
Radiobuttons are always used together in a set, where multiple radiobutton
widgets are tied to a single choice or preference. They are appropriate to use
when the number of options is relatively small, e.g., 3-5.</p>
<table><thead><tr><th style="text-align: center">Radiobutton widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_radiobutton_all.png" alt="Radiobutton widgets." /></td></tr>
</tbody></table>
<p>Radiobuttons are created using the <code>add_ttk_radiobutton</code> method. Typically,
you'll create and initialize several of them at once:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_radiobutton( &quot;home&quot;   -text(&quot;Home&quot;)   -variable(&quot;phone&quot;) -value(&quot;home&quot;)   )?;
parent.add_ttk_radiobutton( &quot;office&quot; -text(&quot;Office&quot;) -variable(&quot;phone&quot;) -value(&quot;office&quot;) )?;
parent.add_ttk_radiobutton( &quot;cell&quot;   -text(&quot;Mobile&quot;) -variable(&quot;phone&quot;) -value(&quot;cell&quot;)   )?;
<span class="boring">}
</span></code></pre></pre>
<p>Radiobuttons share most of the same configuration options as checkbuttons. One
exception is that the <code>onvalue</code> and <code>offvalue</code> options are replaced with a
single <code>value</code> option. Each radiobutton in the set will have the same linked
variable, but a different value. When the variable holds the matching value,
that radiobutton will visually indicate it is selected. If it doesn't match, the
radiobutton will be unselected. If the linked variable doesn't exist, or you
don't specify one with the <code>variable</code> option, radiobuttons also display as
&quot;tristate&quot; or indeterminate. This can be checked via the <code>alternate</code> state flag.</p>
<h2 id="run-example-4"><a class="header" href="#run-example-4">Run Example</a></h2>
<p><code>cargo run --example radiobutton</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entry"><a class="header" href="#entry">Entry</a></h1>
<p>An <em>entry</em> widget presents users with a single line text field where they can
type in a string value. These can be just about anything: a name, a city, a
password, social security number, etc.</p>
<table><thead><tr><th style="text-align: center">Entry widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_entry_all.png" alt="Entry widgets." /></td></tr>
</tbody></table>
<p>Entries are created using the <code>add_ttk_entry</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_entry( &quot;name&quot; -textvariable(&quot;username&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>A <code>width</code> configuration option may be specified to provide the number of
characters wide the entry should be. This allows you, for example, to display a
shorter entry for a zip or postal code.</p>
<h2 id="entry-contents"><a class="header" href="#entry-contents">Entry Contents</a></h2>
<p>We've seen how checkbutton and radiobutton widgets have a value associated with
them. Entries do as well, and that value is usually accessed through a linked
variable specified by the <code>textvariable</code> configuration option. </p>
<blockquote>
<p>Unlike the various buttons, entries don't have a text or image beside them to
identify them. Use a separate label widget for that.</p>
</blockquote>
<p>You can also get or change the value of the entry widget without going through
the linked variable. The <code>get</code> method returns the current value, and the
<code>delete</code> and <code>insert</code> methods let you change the contents, e.g.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!( &quot;current value is {}&quot;, name.get() );
name.delete_range( 0.. )?; // delete between two indices, 0-based
name.insert( 0, &quot;your name&quot; )?; // insert new text at a given index
<span class="boring">}
</span></code></pre></pre>
<h2 id="watching-for-changes"><a class="header" href="#watching-for-changes">Watching for Changes</a></h2>
<p>Entry widgets don't have a <code>command</code> option to invoke a callback whenever the
entry is changed. To watch for changes, you should watch for changes to the
linked variable. See also &quot;Validation&quot;, below.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc] fn it_has_been_written() -&gt; TkResult&lt;()&gt; { Ok(()) }
interpreter.trace_add_variable_write( &quot;username&quot;, &quot;it_has_been_written&quot; )?;
<span class="boring">}
</span></code></pre></pre>
<p>You'll be fine if you stick with simple uses of <code>trace_add_variable_write</code> like
that shown above. You might want to know that this is a small part of a much
more complex system for observing variables and invoking callbacks when they are
read, written, or deleted. You can trigger multiple callbacks, add or delete
them (<code>trace_remove_variable_write</code>), and introspect them
(<code>trace_info_variable</code>).</p>
<h2 id="passwords"><a class="header" href="#passwords">Passwords</a></h2>
<p>Entries can be used for passwords, where the actual contents are displayed as a
bullet or other symbol. To do this, set the <code>show</code> configuration option to the
character you'd like to display.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_entry( &quot;passwd&quot; -textvariable(&quot;password&quot;) -show(&quot;*&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="widget-states"><a class="header" href="#widget-states">Widget States</a></h2>
<p>Like the various buttons, entries can also be put into a disabled state via the
<code>state</code> command (and queried with <code>instate</code>). Entries can also use the state
flag <code>readonly</code>; if set, users cannot change the entry, though they can still
select the text in it (and copy it to the clipboard). There is also an <code>invalid</code>
state, set if the entry widget fails validation, which leads us to...</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Users can type any text they like into an entry widget. However, if you'd like
to restrict what they can type into the entry, you can do so with validation.
For example, an entry might only accept an integer or a valid zip or postal
code.</p>
<p>Your program can specify what makes an entry valid or invalid, as well as when
to check its validity. As we'll see soon, the two are related. We'll start with
a simple example, an entry that can only hold an integer up to five digits long.</p>
<p>The validation criteria is specified via an entry's <code>validatecommand</code>
configuration option. You supply a piece of code whose job is to validate the
entry. It functions like a widget callback or event binding, except that it
returns a value (whether or not the entry is valid). We'll arrange to validate
the entry on any keystroke, which is specified by providing a value of <code>key</code> to
the <code>validate</code> configuration option.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let validate_cmd = tclfn!( &amp;tk, args: &quot;%P&quot;,
    fn check_num( new_val: String ) -&gt; TclResult&lt;bool&gt; {
       Ok( new_val.len() &lt;= 5 &amp;&amp;
           new_val.chars().filter( |&amp;ch| ch &gt;= '0' &amp;&amp; ch &lt;= '9' ).count() &lt;= 5 )
    }
);

root.add_ttk_entry( &quot;e&quot; -textvariable(&quot;num&quot;) -validate(&quot;key&quot;) -validatecommand(validate_cmd) )?
    .grid( -column(0) -row(2) -sticky(&quot;we&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>A few things are worth noting. First, as with event bindings, we can access more
information about the conditions that triggered the validation via percent
substitutions. We used one of these here: `%P  is the new value of the entry if
the validation passes. We'll use a simple regular expression and a length check
to determine if the change is valid. To reject the change, our validation
command can return a false value, and the entry will remain unchanged.</p>
<p>Let's extend our example so that the entry will accept a US zip code, formatted
as &quot;#####&quot; or &quot;#####-####&quot; (&quot;#&quot; can be any digit). We'll still do some
validation on each keystroke (only allowing entry of numbers or a hyphen).
However, We can no longer fully validate the entry on every keystroke; if
they've just typed the first digit, it's not valid yet. So full validation will
only happen when the entry loses focus (e.g., a user tabs away from it). Tk
refers to this as revalidation, in contrast with prevalidation (accepting
changes on each keystroke).</p>
<p>How should we respond to errors? Let's add a message reminding users of the
format. It will appear if they type a wrong key or tab away from the entry when
it's not holding a valid zip code. We'll remove the message when they return to
the entry or type a valid key. We'll also add a (dummy) button to &quot;process&quot; the
zip code, which will be disabled unless the zip entry is valid. Finally, we'll
also add a &quot;name&quot; entry so you can tab away from the zip entry.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FORMATMSG: &amp;'static str = &quot;Zip should be ##### or #####-####&quot;;

let f = root.add_ttk_frame( &quot;f&quot; )?
    .grid( -column(0) -row(3) )?;

f.add_ttk_label( &quot;l1&quot; -text(&quot;Name:&quot;) )?
    .grid( -column(0) -row(4) -padx(5) -pady(5) )?;

let _e1 = f.add_ttk_entry( &quot;e1&quot; )?
    .grid( -column(1) -row(4) -padx(5) -pady(5) )?;

f.add_ttk_label( &quot;l&quot; -text(&quot;Zip:&quot;) )?
    .grid( -column(0) -row(5) -padx(5) -pady(5) )?;

let f_btn = f.add_ttk_button( &quot;btn&quot; -text(&quot;Process&quot;) )?
    .grid( -column(2) -row(5) -padx(5) -pady(5) )?;

f_btn.set_state( TtkState::Disabled )?;

let check_zip_cmd = tclosure!( tk, cmd: &quot;check_zip&quot;, args: &quot;%P %V&quot;,
    move |new_val: String, op: String| -&gt; TkResult&lt;bool&gt; {
        let interp = tcl_interp!();
        interp.set( &quot;errmsg&quot;, &quot;&quot; );

        let re = r#&quot;^[0-9]{5}(\-[0-9]{4})?$&quot;#;
        let regex = Regex::new( re ).unwrap();
        let valid = regex.is_match( &amp;new_val );
        f_btn.set_state( if valid{ !TtkState::Disabled } else{ TtkState::Disabled })?;
        if op == &quot;key&quot; {
            let regex = Regex::new( r#&quot;^[0-9\-]*$&quot;# ).unwrap();
            let ok_so_far = regex.is_match( &amp;new_val ) &amp;&amp; new_val.len() &lt;= 10;
            if !ok_so_far {
                interp.set( &quot;errmsg&quot;, FORMATMSG );
            }
            return Ok( true );
        } else if op == &quot;focusout&quot; {
            if !valid {
                interp.set( &quot;errmsg&quot;, FORMATMSG );
            }
        }
        if valid {
            Ok( true )
        } else {
            Ok( false )
        }
    }
);

f.add_ttk_entry( &quot;e&quot; -textvariable(&quot;zip&quot;) -validate(&quot;all&quot;) -validatecommand(check_zip_cmd) )?
    .grid( -column(1) -row(5) -padx(5) -pady(5) )?;

f.add_ttk_label( &quot;msg&quot; -font(&quot;TkSmallCaptionFont&quot;) -foreground(&quot;red&quot;) -textvariable(&quot;errmsg&quot;) )?
    .grid( -column(1) -row(2) -padx(5) -pady(5) -sticky(&quot;w&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Notice that the <code>validate</code> configuration option has been changed from <code>key</code> to
<code>all</code>. That arranges for the <code>validatecommand</code> callback to be invoked on not
only keystrokes but other triggers. The trigger is passed to the callback using
the %V percent substitution. The callback differentiated between <code>key</code> and
<code>focusout</code> triggers (you can also check for <code>focusin</code>).</p>
<blockquote>
<p>There's a few more things to know about validation. First, if your
<code>validatecommand</code> ever generates an error (or doesn't return a boolean),
validation will be disabled for that widget. Your callback can modify the entry,
e.g., change its textvariable. You can ask the widget to validate at any time by
calling it's <code>validate</code> method, which returns true if validation passes (the
<code>%V</code> substitution is set to <code>forced</code>).</p>
</blockquote>
<blockquote>
<p>There is an <code>invalidcommand</code> configuration option (which works like
<code>validatecommand</code>) that is called whenever validation fails. You can use it to
accomplish nasty things like forcing the focus back on the widget that didn't
validate. In practice, it's rarely used. As mentioned earlier, the entry's
<code>invalid</code> state flag (which can be checked via the <code>instate</code> <code>invalid</code> method)
is automatically updated as validation succeeds or fails.</p>
</blockquote>
<blockquote>
<p>Other percent substitutions allow you to get the entry's contents prior to
editing (<code>%s</code>), differentiate between insert and delete (<code>%d</code>), where an insert
or delete occurs (<code>%i</code>), what is being inserted or deleted (<code>%S</code>), the current
setting of the <code>validate</code> option (<code>%v</code>) and the name of the widget (<code>%W</code>).</p>
</blockquote>
<h2 id="run-example-5"><a class="header" href="#run-example-5">Run Example</a></h2>
<p><code>cargo run --example entry</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combobox"><a class="header" href="#combobox">Combobox</a></h1>
<p>A <em>combobox</em> widget combines an entry with a list of choices. This lets users
either choose from a set of values you've provided (e.g., typical settings), but
also put in their own value (e.g., for less common cases).</p>
<table><thead><tr><th style="text-align: center">Combobox widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_combobox_all.png" alt="Combobox widgets." /></td></tr>
</tbody></table>
<p>Comboboxes are created using the <code>ttk_combobox</code> command:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_combobox( &quot;country&quot; -textvariable(&quot;country&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Like entries, the <code>textvariable</code> option links a variable in your program to the
current value of the combobox. As with other widgets, you should initialize the
linked variable in your own code.</p>
<p>A combobox will generate a <code>event::virtual_event( &quot;ComboboxSelected&quot; )</code> that you
can bind to whenever its value changes. (You could also trace changes on the
<code>textvariable</code>, as we've seen in the previous few widgets we covered. Binding to
the event is more straightforward, and so tends to be our preferred choice.)</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>country.bind( event::virtual_event( &quot;ComboboxSelected&quot; ), script )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="predefined-values"><a class="header" href="#predefined-values">Predefined Values</a></h2>
<p>You can provide a list of values that users can choose from using the <code>values</code>
configuration option:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>country.configure( -values([ &quot;USA&quot;,&quot;Canada&quot;,&quot;Australia&quot; ].as_slice() ))?;
<span class="boring">}
</span></code></pre></pre>
<p>If set, the <code>TtkState::ReadOnly</code> state flag will restrict users to making
choices only from the list of predefined values, but not be able to enter their
own (though if the current value of the combobox is not in the list, it won't be
changed).</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>country.set_state( TtkState::ReadOnly )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>If you're using the combobox in <code>TtkState::ReadOnly</code> mode, I'd recommend that
when the value changes (i.e., on a <code>event::virtual_event(&quot;ComboboxSelected&quot;)</code>),
that you call the <code>selection_clear</code> method. It looks a bit odd visually without
doing that.</p>
</blockquote>
<p>You can also get the current value using the <code>get</code> method, and change the
current value using the <code>set</code> method (which takes a single argument, the new
value).</p>
<p>As a complement to the <code>get</code> and <code>set</code> methods, you can also use the <code>current</code>
method to determine which item in the predefined values list is selected. Call
<code>current</code> with no arguments; it will return a 0-based index into the list, or -1
if the current value is not in the list. You can select an item in the list by
calling <code>current</code> with a single 0-based index argument.</p>
<blockquote>
<p>Want to associate some other value with each item in the list so that your
program can use one value internally, but it gets displayed in the combobox as
something else? You'll want to have a look at the section entitled &quot;Keeping
Extra Item Data&quot; when we get to the discussion of listboxes in a couple of
chapters from now.</p>
</blockquote>
<h2 id="run-example-6"><a class="header" href="#run-example-6">Run Example</a></h2>
<p><code>cargo run --example combobox</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-grid-geometry-manager"><a class="header" href="#the-grid-geometry-manager">The Grid Geometry Manager</a></h1>
<p>We'll take a bit of a break from talking about different widgets (what to put
onscreen) and focus instead on geometry management (where to put those widgets).
We introduced the general idea of geometry management in the &quot;Tk Concepts&quot;
chapter. Here, we focus on one specific geometry manager: <code>grid</code>.</p>
<p>As we've seen, grid lets you layout widgets in columns and rows. If you're
familiar with using HTML tables to do layout, you'll feel right at home here.
This chapter illustrates the various ways you can tweak grid to give you all the
control you need for your user interface.</p>
<p>Grid is one of several geometry managers available in Tk, but its mix of power,
flexibility, and ease of use make it the best choice for general use. Its
constraint model is a natural fit with today's layouts that rely on the
alignment of widgets. There are other geometry managers in Tk: <code>pack</code> is also
quite powerful, but harder to use and understand, while <code>place</code> gives you
complete control of positioning each element. Even widgets like paned windows,
notebooks, canvas, and text that we'll explore later can act as geometry
managers.</p>
<blockquote>
<p>It's worth noting that <code>grid</code> was first introduced to Tk in 1996, several
years after Tk became popular, and it took a while to catch on. Before that,
developers had always used <code>pack</code> to do constraint-based geometry management.
When <code>grid</code> came out, many developers kept using <code>pack</code>, and you'll still find
it used in many Tk programs and documentation. While there's nothing technically
wrong with <code>pack</code>, the algorithm's behavior is often hard to understand. More
importantly, because the order that widgets are packed is significant in
determining layout, modifying existing layouts can be more difficult. Aligning
widgets in different parts of the user interface is also much trickier.</p>
</blockquote>
<blockquote>
<p>Grid has all the power of pack, produces nicer layouts (that align widgets
both horizontally and vertically), and is easier to learn and use. Because of
that, we think grid is the right choice for most developers most of the time.
Start your new programs using grid, and switch old ones to grid as you're making
changes to an existing user interface.</p>
</blockquote>
<p>The <a href="https://tcl.tk/man/tcl8.6/TkCmd/grid.htm">reference documentation</a> for grid
provides an exhaustive description of grid, its behaviors, and all options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="columns-and-rows"><a class="header" href="#columns-and-rows">Columns and Rows</a></h1>
<p>In grid, widgets are assigned a <code>column</code> number and a <code>row</code> number. These
indicate each widget's position relative to other widgets. All widgets in the
same column will be above or below each other. Those in the same row will be to
the left or right of each other.</p>
<p>Column and row numbers must be positive integers (i.e., 0, 1, 2, ...). You don't
have to start at 0 and can leave gaps in column and row numbers (e.g., column 1,
2, 10, 11, 12, 20, 21). This is useful if you plan to add more widgets in the
middle of the user interface later.</p>
<p>The width of each column will vary depending on the width of the widgets
contained within the column. Ditto for the height of each row. This means when
sketching out your user interface and dividing it into rows and columns, you
don't need to worry about each column or row being equal width.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spanning-multiple-cells"><a class="header" href="#spanning-multiple-cells">Spanning Multiple Cells</a></h1>
<p>Widgets can take up more than a single cell in the grid; to do this, we'll use
the <code>columnspan</code> and <code>rowspan</code> options when gridding the widget. These are
analogous to the &quot;colspan&quot; and &quot;rowspan&quot; attribute of HTML tables.</p>
<p>Here is an example of creating a user interface with multiple widgets, some that
take up more than a single cell.</p>
<table><thead><tr><th style="text-align: center">Gridding multiple widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/gridexample1.png" alt="Gridding multiple widgets." /></td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust no_run">/// cargo run --example spanning_multiple_cells

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let c = root.add_ttk_frame( &quot;c&quot; )?;
    c.add_ttk_frame( &quot;f&quot; -borderwidth(5) -relief(&quot;ridge&quot;) -width(200) -height(100) )?;
    c.add_ttk_label( &quot;namelbl&quot; -text(&quot;Name&quot;) )?;
    c.add_ttk_entry( &quot;name&quot; )?;
    c.add_ttk_checkbutton( &quot;one&quot;   -text(&quot;One&quot;)   -variable(&quot;one&quot;)   -onvalue(1) )?; tk.set( &quot;one&quot;  , 1 );
    c.add_ttk_checkbutton( &quot;two&quot;   -text(&quot;Two&quot;)   -variable(&quot;two&quot;)   -onvalue(1) )?; tk.set( &quot;two&quot;  , 0 );
    c.add_ttk_checkbutton( &quot;three&quot; -text(&quot;Three&quot;) -variable(&quot;three&quot;) -onvalue(1) )?; tk.set( &quot;three&quot;, 1 );
    c.add_ttk_button( &quot;ok&quot; -text(&quot;Okay&quot;) )?;
    c.add_ttk_button( &quot;cancel&quot; -text(&quot;Cancel&quot;) )?;

    tk.grid( &quot;.c&quot;         -column(0) -row(0) )?;
    tk.grid( &quot;.c.f&quot;       -column(0) -row(0) -columnspan(3) -rowspan(2) )?;
    tk.grid( &quot;.c.namelbl&quot; -column(3) -row(0) -columnspan(2) )?;
    tk.grid( &quot;.c.name&quot;    -column(3) -row(1) -columnspan(2) )?;
    tk.grid( &quot;.c.one&quot;     -column(0) -row(3) )?;
    tk.grid( &quot;.c.two&quot;     -column(1) -row(3) )?;
    tk.grid( &quot;.c.three&quot;   -column(2) -row(3) )?;
    tk.grid( &quot;.c.ok&quot;      -column(3) -row(3) )?;
    tk.grid( &quot;.c.cancel&quot;  -column(4) -row(3) )?;

    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout-within-the-cell"><a class="header" href="#layout-within-the-cell">Layout within the Cell</a></h1>
<p>Because the width of a column (and height of a row) depends on all the widgets
that have been added to it, the odds are that at least some widgets will have a
smaller width or height than has been allocated for the cell its been placed in.
So the question becomes, where exactly should it be put within the cell?</p>
<p>By default, if a cell is larger than the widget contained in it, the widget will
be centered within it, both horizontally and vertically. The master's background
will display in the empty space around it. In the figure below, the widget in
the top right is smaller than the cell allocated to it. The (white) background
of the master fills the rest of the cell.</p>
<table><thead><tr><th style="text-align: center">Layout within the cell and the 'sticky' option</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/gridlayout.png" alt="Layout within the cell and the 'sticky' option." /></td></tr>
</tbody></table>
<p>The <code>sticky</code> option can change this default behavior. Its value is a string of
0 or more of the compass directions <code>nsew</code>, specifying which edges of the cell
the widget should be &quot;stuck&quot; to. For example, a value of <code>n</code> (north) will jam
the widget up against the top side, with any extra vertical space on the bottom;
the widget will still be centered horizontally. A value of <code>nw</code> (north-west)
means the widget will be stuck to the top left corner, with extra space on the
bottom and right.</p>
<p>Specifying two opposite edges, such as <code>we</code> (west, east) means that the widget
will be stretched. In this case, it will be stuck to both the left and right
edge of the cell. So the widget will then be wider than its &quot;ideal&quot; size.</p>
<p>If you want the widget to expand to fill up the entire cell, grid it with a
sticky value of <code>nsew</code> (north, south, east, west), meaning it will stick to
every side. This is shown in the bottom left widget in the above figure.</p>
<blockquote>
<p>Most widgets have options that can control how they are displayed if they are
larger than needed. For example, a label widget has an <code>anchor</code> option that
controls where the label's text will be positioned within the widget's
boundaries. The bottom left label in the figure above uses the default anchor
(<code>w</code>, i.e., left side, vertically centered).</p>
</blockquote>
<blockquote>
<p>If you're having trouble getting things to line up the way you want them to,
first make sure you know how large the widget is. As we discussed with the
<code>label</code> widget in the previous chapter, changing the widget's background or
border can help. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-resize"><a class="header" href="#handling-resize">Handling Resize</a></h1>
<p>If you've tried to resize the example, you'll notice that nothing moves at all,
as shown below.</p>
<table><thead><tr><th style="text-align: center">Resizing the window</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/gridnoresize.png" alt="Resizing the window." /></td></tr>
</tbody></table>
<p>Even if you took a peek below and added the extra <code>sticky</code> options to our
example, you'd still see the same thing. It looks like <code>sticky</code> may tell Tk how
to react if the cell's row or column does resize, but doesn't actually say that
the row or columns should resize if extra room becomes available. Let's fix
that.</p>
<p>Every column and row in the grid has a <code>weight</code> option associated with it. This
tells <code>grid</code> how much the column or row should grow if there is extra room in
the master to fill. By default, the weight of each column or row is 0, meaning
it won't expand to fill any extra space.</p>
<p>For the user interface to resize then, we'll need to specify a positive weight
to the columns and rows that we'd like to expand. You must provide weights for
at least one column and one row. This is done using the <code>columnconfigure</code> and
<code>rowconfigure</code> methods of <code>grid</code>. This weight is relative. If two columns have
the same weight, they'll expand at the same rate. In our example, we'll give the
three leftmost columns (holding the checkbuttons) a weight of 3, and the two
rightmost columns a weight of 1. For every one pixel the right columns grow, the
left columns will grow by three pixels. So as the window grows larger, most of
the extra space will go to the left side. </p>
<table><thead><tr><th style="text-align: center">Resizing the window after adding weights</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/gridresize.png" alt="Resizing the window after adding weights." /></td></tr>
</tbody></table>
<p>Both <code>columnconfigure</code> and <code>rowconfigure</code> also take a <code>minsize</code> grid option,
which specifies a minimum size which you really don't want the column or row to
shrink beyond.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="padding-1"><a class="header" href="#padding-1">Padding</a></h1>
<p>Normally, each column or row will be directly adjacent to the next, so that
widgets will be right next to each other. This is sometimes what you want (think
of a listbox and its scrollbar), but often you want some space between widgets.
In Tk, this is called padding, and there are several ways you can choose to add
it.</p>
<p>We've already actually seen one way, and that is using a widget's own options to
add the extra space around it. Not all widgets have this, but one that does is a
frame; this is useful because frames are most often used as the master to grid
other widgets. The frame's <code>padding</code> option lets you specify a bit of extra
padding inside the frame, whether the same amount for each of the four sides or
even different for each.</p>
<p>A second way is using the <code>padx</code> and <code>pady</code> grid options when adding the widget.
As you'd expect, <code>padx</code> puts a bit of extra space to the left and right, while
<code>pady</code> adds extra space top and bottom. A single value for the option puts the
same padding on both left and right (or top and bottom), while a two-value list
lets you put different amounts on left and right (or top and bottom). Note that
this extra padding is within the grid cell containing the widget.</p>
<p>If you want to add padding around an entire row or column, the <code>columnconfigure</code>
and <code>rowconfigure</code> methods accept a <code>pad</code> option, which will do this for you.</p>
<p>Let's add the extra sticky, resizing, and padding behavior to our example
(additions in bold).</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example padding

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let c = root.add_ttk_frame( &quot;c&quot; -padding((3,3,12,12)) )?;
    c.add_ttk_frame( &quot;f&quot; -borderwidth(5) -relief(&quot;ridge&quot;) -width(200) -height(100) )?;
    c.add_ttk_label( &quot;namelbl&quot; -text(&quot;Name&quot;) )?;
    c.add_ttk_entry( &quot;name&quot; )?;
    c.add_ttk_checkbutton( &quot;one&quot;   -text(&quot;One&quot;)   -variable(&quot;one&quot;)   -onvalue(1) )?; tk.set( &quot;one&quot;  , 1 );
    c.add_ttk_checkbutton( &quot;two&quot;   -text(&quot;Two&quot;)   -variable(&quot;two&quot;)   -onvalue(1) )?; tk.set( &quot;two&quot;  , 0 );
    c.add_ttk_checkbutton( &quot;three&quot; -text(&quot;Three&quot;) -variable(&quot;three&quot;) -onvalue(1) )?; tk.set( &quot;three&quot;, 1 );
    c.add_ttk_button( &quot;ok&quot; -text(&quot;Okay&quot;) )?;
    c.add_ttk_button( &quot;cancel&quot; -text(&quot;Cancel&quot;) )?;

    tk.grid( &quot;.c&quot;         -column(0) -row(0) -sticky(&quot;nsew&quot;) )?;
    tk.grid( &quot;.c.f&quot;       -column(0) -row(0) -columnspan(3) -rowspan(2) -sticky(&quot;nsew&quot;) )?;
    tk.grid( &quot;.c.namelbl&quot; -column(3) -row(0) -columnspan(2)             -sticky(&quot;nw&quot;)  -padx(5) )?;
    tk.grid( &quot;.c.name&quot;    -column(3) -row(1) -columnspan(2)             -sticky(&quot;new&quot;) -padx(5) -pady(5) )?;
    tk.grid( &quot;.c.one&quot;     -column(0) -row(3) )?;
    tk.grid( &quot;.c.two&quot;     -column(1) -row(3) )?;
    tk.grid( &quot;.c.three&quot;   -column(2) -row(3) )?;
    tk.grid( &quot;.c.ok&quot;      -column(3) -row(3) )?;
    tk.grid( &quot;.c.cancel&quot;  -column(4) -row(3) )?;

    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure(    0, -weight(1) )?;
    c.grid_columnconfigure(    0, -weight(3) )?;
    c.grid_columnconfigure(    1, -weight(3) )?;
    c.grid_columnconfigure(    2, -weight(3) )?;
    c.grid_columnconfigure(    3, -weight(1) )?;
    c.grid_columnconfigure(    4, -weight(1) )?;
    c.grid_rowconfigure(       1, -weight(1) )?;

    Ok( main_loop() )
}
</code></pre></pre>
<p>This looks more promising. Play around with the example to get a feel for the resize behavior.</p>
<p>Grid example, handling in-cell layout and resize.</p>
<table><thead><tr><th style="text-align: center">Grid example, handling in-cell layout and resize</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/gridexample2.png" alt="Grid example, handling in-cell layout and resize." /></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additional-grid-features"><a class="header" href="#additional-grid-features">Additional Grid Features</a></h1>
<p>If you look at the <a href="https://www.tcl.tk/man/tcl/TkCmd/grid.html">documentation</a>
for <code>grid</code>, you'll see many other things you can do with grid. Here are a few of
the more useful ones.</p>
<h2 id="querying-and-changing-grid-options"><a class="header" href="#querying-and-changing-grid-options">Querying and Changing Grid Options</a></h2>
<p>Like widgets themselves, it's easy to introspect the various grid options or
change them. Setting options when you first grid the widget is certainly
convenient, but you can change them anytime you'd like.</p>
<p>The <code>slaves</code> method will tell you all the widgets that have been gridded inside
a master, or optionally those within just a certain column or row. The <code>info</code>
method will return a list of all the grid options for a widget and their values.
Finally, the <code>configure</code> method lets you change one or more grid options on a
widget.</p>
<p>These are illustrated in this interactive session:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let got = c.grid_slaves(())?;
let got = got
    .iter()
    .map( |widget| widget.path() )
    .collect::&lt;Vec&lt;_&gt;&gt;();
let expected = vec![ &quot;.c.cancel&quot;, &quot;.c.ok&quot;, &quot;.c.three&quot;, &quot;.c.two&quot;, &quot;.c.one&quot;, &quot;.c.name&quot;, &quot;.c.namelbl&quot;, &quot;.c.f&quot; ]
    .into_iter()
    .collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!( got, expected );

let got = c.grid_slaves( -row(3) )?;
let got = got
    .iter()
    .map( |widget| widget.path() )
    .collect::&lt;Vec&lt;_&gt;&gt;();
let expected = vec![ &quot;.c.cancel&quot;, &quot;.c.ok&quot;, &quot;.c.three&quot;, &quot;.c.two&quot;, &quot;.c.one&quot; ]
    .into_iter()
    .collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!( got, expected );

let got = c.grid_slaves( -column(0) )?;
let got = got
    .iter()
    .map( |widget| widget.path() )
    .collect::&lt;Vec&lt;_&gt;&gt;();
let expected = vec![ &quot;.c.one&quot;, &quot;.c.f&quot; ]
    .into_iter()
    .collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!( got, expected );

let got = c_namelbl.grid_info()?
    .into_iter()
    .map( |(key, val)| (key, val.get_string() ))
    .collect::&lt;HashMap&lt;_,_&gt;&gt;();

let mut expected = HashMap::new();

expected.insert( &quot;-in&quot;        .to_owned(), &quot;.c&quot;.to_owned() );
expected.insert( &quot;-column&quot;    .to_owned(), &quot;3&quot; .to_owned() );
expected.insert( &quot;-row&quot;       .to_owned(), &quot;0&quot; .to_owned() );
expected.insert( &quot;-columnspan&quot;.to_owned(), &quot;2&quot; .to_owned() );
expected.insert( &quot;-rowspan&quot;   .to_owned(), &quot;1&quot; .to_owned() );
expected.insert( &quot;-ipadx&quot;     .to_owned(), &quot;0&quot; .to_owned() );
expected.insert( &quot;-ipady&quot;     .to_owned(), &quot;0&quot; .to_owned() );
expected.insert( &quot;-padx&quot;      .to_owned(), &quot;5&quot; .to_owned() );
expected.insert( &quot;-pady&quot;      .to_owned(), &quot;0&quot; .to_owned() );
expected.insert( &quot;-sticky&quot;    .to_owned(), &quot;nw&quot;.to_owned() );

assert_eq!( got, expected );

c_namelbl.grid_configure( -sticky(&quot;ew&quot;) )?;

let got = c_namelbl.grid_info()?
    .into_iter()
    .map( |(key, val)| (key, val.get_string() ))
    .collect::&lt;HashMap&lt;_,_&gt;&gt;();

let mut expected = HashMap::new();

expected.insert( &quot;-in&quot;        .to_owned(), &quot;.c&quot;.to_owned() );
expected.insert( &quot;-column&quot;    .to_owned(), &quot;3&quot; .to_owned() );
expected.insert( &quot;-row&quot;       .to_owned(), &quot;0&quot; .to_owned() );
expected.insert( &quot;-columnspan&quot;.to_owned(), &quot;2&quot; .to_owned() );
expected.insert( &quot;-rowspan&quot;   .to_owned(), &quot;1&quot; .to_owned() );
expected.insert( &quot;-ipadx&quot;     .to_owned(), &quot;0&quot; .to_owned() );
expected.insert( &quot;-ipady&quot;     .to_owned(), &quot;0&quot; .to_owned() );
expected.insert( &quot;-padx&quot;      .to_owned(), &quot;5&quot; .to_owned() );
expected.insert( &quot;-pady&quot;      .to_owned(), &quot;0&quot; .to_owned() );
expected.insert( &quot;-sticky&quot;    .to_owned(), &quot;ew&quot;.to_owned() );

assert_eq!( got, expected );
<span class="boring">}
</span></code></pre></pre>
<h2 id="internal-padding"><a class="header" href="#internal-padding">Internal Padding</a></h2>
<p>You saw how the <code>padx</code> and <code>pady</code> grid options added extra space around the
outside of a widget. There's also a less used type of padding called &quot;internal
padding&quot; controlled by the grid options <code>ipadx</code> and <code>ipady</code>.</p>
<p>The difference can be subtle. Let's say you have a frame that's 20x20, and
specify normal (external) padding of 5 pixels on each side. The frame will
request a 20x20 rectangle (its natural size) from the geometry manager.
Normally, that's what it will be granted, so it'll get a 20x20 rectangle for the
frame, surrounded by a 5-pixel border.</p>
<p>With internal padding, the geometry manager will effectively add the extra
padding to the widget when figuring out its natural size, as if the widget has
requested a 30x30 rectangle. If the frame is centered, or attached to a single
side or corner (using <code>sticky</code>), we'll end up with a 20x20 frame with extra
space around it. If, however, the frame is set to stretch (i.e., a <code>sticky</code>
value of <code>we</code>, <code>ns</code>, or <code>nwes</code>), it will fill the extra space, resulting in a
30x30 frame, with no border.</p>
<h2 id="forget-and-remove"><a class="header" href="#forget-and-remove">Forget and Remove</a></h2>
<p>The <code>forget</code> method of grid removes slaves from the grid they're currently part
of. It takes a list of one or more slave widgets as arguments. This does not
destroy the widget altogether but takes it off the screen as if it had not been
gridded in the first place. You can grid it again later, though any grid options
you'd originally assigned will have been lost.</p>
<p>The <code>remove</code> method of grid works the same, except that the grid options will be
remembered if you <code>grid</code> it again later.</p>
<h2 id="run-example-7"><a class="header" href="#run-example-7">Run Example</a></h2>
<p><code>cargo run --example querying_and_changing_grid_options</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-layouts"><a class="header" href="#nested-layouts">Nested Layouts</a></h1>
<p>As your user interface gets more complicated, the grid that you're using to
organize all your widgets can get increasingly complicated. This can make
changing and maintaining your program very difficult.</p>
<p>Luckily, you don't have to manage your entire user interface with a single grid.
If you have one area of your user interface that is fairly independent of
others, create a new frame to hold that area and grid the widgets in area within
that frame. For example, if you were building a graphics editor with multiple
palettes, toolbars, etc., each one of those areas might be a candidate for
putting in its own frame.</p>
<p>In theory, these frames, each with its own grid, can be nested arbitrarily deep,
though, in practice, this usually doesn't go beyond a few levels. This can be a
big help in modularizing your program. If, for example, you have a palette of
drawing tools, you can create the whole thing in a separate function or class.
It would be responsible for creating all the component widgets, gridding them
together, setting up event bindings, etc. The details of how things work inside
that palette can be contained in that one piece of code. From the point of view
of your main program, all it needs to know about is the single frame widget
containing your palette.</p>
<p>Our examples have shown just a hint of this, where a content frame was gridded
into the main window, and then all the other widgets gridded into the content
frame.</p>
<p>As your own programs grow larger, you'll likely run into situations where making
a change in the layout of one part of your interface requires code changes to
the layout of another part. That may be a clue to reconsider how you're using
<code>grid</code> and if splitting out components into separate frames would help.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-widgets"><a class="header" href="#more-widgets">More Widgets</a></h1>
<p>This chapter carries on introducing several more widgets: listbox, scrollbar,
text, scale, spinbox, and progressbar. Some of these are starting to be a bit
more powerful than the basic ones we looked at before. Here we'll also see a few
instances of using the classic Tk widgets, in cases where there isn't (or there
isn't a need for) a themed counterpart.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listbox"><a class="header" href="#listbox">Listbox</a></h1>
<p>A <em>listbox</em> widget displays a list of single-line text items, usually lengthy,
and allows users to browse through the list, selecting one or more.</p>
<p>Listboxes are part of the classic Tk widgets; there is not presently a listbox
in the themed Tk widget set.</p>
<blockquote>
<p>Tk's treeview widget (which is themed) can also be used as a listbox (a one
level deep tree), allowing you to use icons and styles with the list. It's also
likely that a multi-column (table) list widget will make it into Tk at some
point, whether based on treeview or one of the available extensions.</p>
</blockquote>
<table><thead><tr><th style="text-align: center">Listbox widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_listbox_all.png" alt="Listbox widgets." /></td></tr>
</tbody></table>
<p>Listboxes are created using the <code>add_tk_listbox</code> method. A height configuration
option can specify the number of lines the listbox will display at a time
without scrolling:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_listbox( &quot;l&quot; -height(10) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="populating-the-listbox-items"><a class="header" href="#populating-the-listbox-items">Populating the Listbox Items</a></h2>
<p>There's an easy way and a hard way to populate and manage all the items in the
listbox.</p>
<p>Here's the easy way. Each listbox has a <code>listvariable</code> configuration option,
which allows you to link a variable (which must hold a list) to the listbox.
Each element of this list is a string representing one item in the listbox. To
add, remove, or rearrange items in the listbox, you can simply modify this
variable as you would any other list. Similarly, to find out, e.g., which item
is on the third line of the listbox, just look at the third element of the list
variable.</p>
<p>The older, harder way to do things is to use a set of methods that are part of
the listbox widget itself. They operate on the (internal) list of items
maintained by the widget:</p>
<p>The <code>insert( &amp;self, idx: impl Into&lt;ListboxIndex&gt;, elements )</code> method is used to
add one or more items to the list; <code>idx</code> is a 0-based index indicating the
position of the item before which the item(s) should be added; specify
<code>ListboxIndex::End</code> to put the new items at the end of the list.</p>
<p>Use the <code>delete( &amp;self, index: impl Into&lt;Index&gt; )</code> or
<code>delete_range( &amp;self, range: impl Into&lt;TkRange&lt;Index&gt;&gt; )</code> method to delete one
or more items from the list.</p>
<p>Use the <code>get( &amp;self, index: impl Into&lt;Index&gt; )</code> method to return the contents of
a single item at the given position, or use the
<code>get_range( &amp;self, range: impl Into&lt;TkRange&lt;Index&gt;&gt; )</code> method to get a list of
the items in the <code>range</code>. </p>
<p>The <code>size</code> method returns the number of items in the list.</p>
<blockquote>
<p>The reason there is a hard way at all is because the <code>listvariable</code> option was
only introduced in Tk 8.3. Before that, you were stuck with the hard way.
Because using the list variable lets you use all the standard list operations,
it provides a much simpler API. It's certainly an upgrade worth considering if
you have listboxes doing things the older way.</p>
</blockquote>
<h2 id="selecting-items"><a class="header" href="#selecting-items">Selecting Items</a></h2>
<p>You can choose whether users can select only a single item at a time from the
<code>listbox</code>, or if multiple items can simultaneously be selected. This is
controlled by the <code>selectmode</code> option: the default is only being able to select
a single item (<code>browse</code>), while a <code>selectmode</code> of <code>extended</code> allows users to
select multiple items.</p>
<blockquote>
<p>The names <code>browse</code> and <code>extended</code>, again for backward compatibility reasons,
are truly awful. This is made worse by the fact that there are two other modes,
<code>single</code> and <code>multiple</code>, which you <em>should not use</em> (they use an old interaction
style that is inconsistent with modern user interface and platform conventions).</p>
</blockquote>
<p>To find out which item or items in the listbox are currently selected, use the
<code>curselection</code> method. It returns a list of indices of all items currently
selected; this may be an empty list. For lists with a <code>selectmode</code> of <code>browse</code>,
it will never be longer than one item. You can also use the <code>selection_includes</code>
index method to check if the item with the given index is currently selected.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if lbox.selection_includes( 2 ) { /* omitted */ }
<span class="boring">}
</span></code></pre></pre>
<p>To programmatically change the selection, you can use the
<code>selection_clear( &amp;self, values: impl IntoTkValues&lt;ListboxIndex&gt; )</code> method to
deselect either a single item or any within the range of indices specified. To
select an item or all items in a range, use the
<code>selection_set( &amp;self, values: impl IntoTkValues&lt;ListboxIndex&gt; )</code> method. Both
of these will not touch the selection of any items outside the range specified.</p>
<p>If you change the selection, you should also make sure that the newly selected
item is visible (i.e., it is not scrolled out of view). To do this, use the
<code>see_index</code> method.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lbox.selection_set( idx )?;
lbox.see( idx )?;
<span class="boring">}
</span></code></pre></pre>
<p>When a user changes the selection, a <code>event::virtual_event( &quot;ListboxSelect&quot; )</code>
is generated. You can bind to this to take any action you need. Depending on
your application, you may also want to bind to a double-click
<code>event::double().button_press_1()</code> event and use it to invoke an action with the
currently selected item.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lbox.bind( event::virtual_event( &quot;ListboxSelect&quot; ),
    tclosure!( tk, move || -&gt; TkResult&lt;()&gt; {
        Ok( update_details( lbox.curselection()? ))
    }
))?;

lbox.bind( event::double().button_press_1(),
    tclosure!( tk, move || -&gt; TkResult&lt;()&gt; {
        Ok( invoke_action( lbox.curselection()? ))
    }
))?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="stylizing-the-list"><a class="header" href="#stylizing-the-list">Stylizing the List</a></h2>
<p>Like most of the &quot;classic&quot; Tk widgets, you have immense flexibility in modifying
the appearance of a listbox. As described in the
<a href="https://www.tcl.tk/man/tcl/TkCmd/listbox.html"><code>reference manual</code></a>, you can
modify the font the listbox items are displayed in, the foreground (text) and
background colors for items in their normal state, when selected, when the
widget is disabled, etc. There is also an <code>itemconfigure</code> method that allows you
to change the foreground and background colors of individual items.</p>
<p>As is often the case, restraint is useful. Generally, the default values will be
entirely suitable and a good match for platform conventions. In the example
we'll get to momentarily, we'll show how restrained use of these options can be
put to good effect, in this case displaying alternate lines of the listbox in
slightly different colors.</p>
<h2 id="keeping-extra-item-data"><a class="header" href="#keeping-extra-item-data">Keeping Extra Item Data</a></h2>
<p>The <code>listvariable</code> (or the internal list, if you're managing things the old way)
holds the strings that will be shown in the listbox. It's often the case,
though, that each string you're displaying is associated with some other data
item. This might be an internal object that is meaningful to your program, but
not meant to be displayed to users. In other words, what you're really
interested in is not so much the string displayed in the listbox, but the
associated data item. For example, a listbox may display a list of names to
users, but your program is really interested in the underlying user object (or
id number) for each one, not the particular name.</p>
<p>How can we associate this underlying value with the name that is displayed?
Unfortunately, the listbox widget itself doesn't offer any facilities, so it's
something we'll have to manage separately. There are a couple of obvious
approaches. First, if the displayed strings are guaranteed unique, you could use
a hash table to map each name to its associated underlying object. This wouldn't
work well for peoples' names, where duplicates are possible, but could work for
countries, which are unique.</p>
<p>A second approach is to keep a second list, parallel to the list of strings
displayed in the listbox. This second list will hold the underlying object
associated with each item that is displayed. So the first item in the displayed
strings list corresponds to the first item in the underlying objects list, the
second to the second, etc. Any changes that you make in one list (insert,
delete, reorder), you must make in the other. You can then easily map from the
displayed list item to the underlying object, based on their position in the
list.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Here is a silly example showing several of these listbox techniques. We'll have
a list of countries displayed. We'll be able to select only a single country at
a time. As we do so, a status bar will display the population of the country.
You can press a button to send one of several gifts to the selected country's
head of state (well, not really, but use your imagination). Sending a gift can
also be triggered by double-clicking the list or hitting the Return key.</p>
<p>Behind the scenes, we maintain two lists in parallel. The first is a list of
two-letter country codes. The other is the corresponding name for each country
that we will display in the listbox. We also have a simple hash table that
contains the population of each country, indexed by the two-letter country code.</p>
<table><thead><tr><th style="text-align: center">Country selector listbox example</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/country_w.png" alt="Country selector listbox example." /></td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example listbox

use std::collections::HashMap;

use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    // Initialize our country &quot;databases&quot;:
    //  - the list of country codes (a subset anyway)
    //  - parallel list of country names, same order as the country codes
    //  - a hash table mapping country code to population
    tk.set( &quot;countrycodes&quot;, vec![
        &quot;ar&quot;, &quot;au&quot;, &quot;be&quot;, &quot;br&quot;, &quot;ca&quot;, &quot;cn&quot;, &quot;dk&quot;, &quot;fi&quot;, &quot;fr&quot;, &quot;gr&quot;,
        &quot;in&quot;, &quot;it&quot;, &quot;jp&quot;, &quot;mx&quot;, &quot;nl&quot;, &quot;no&quot;, &quot;es&quot;, &quot;se&quot;, &quot;ch&quot; ]);

    tk.set( &quot;countrynames&quot;, vec![
        &quot;Argentina&quot;, &quot;Australia&quot;, &quot;Belgium&quot;, &quot;Brazil&quot;, &quot;Canada&quot;, &quot;China&quot;,
        &quot;Denmark&quot;, &quot;Finland&quot;, &quot;France&quot;, &quot;Greece&quot;, &quot;India&quot;, &quot;Italy&quot;, &quot;Japan&quot;,
        &quot;Mexico&quot;, &quot;Netherlands&quot;, &quot;Norway&quot;, &quot;Spain&quot;, &quot;Sweden&quot;, &quot;Switzerland&quot; ]);

    let mut populations = HashMap::new();

    populations.insert( &quot;ar&quot;,   41000000 );
    populations.insert( &quot;au&quot;,   21179211 );
    populations.insert( &quot;be&quot;,   10584534 );
    populations.insert( &quot;br&quot;,  185971537 );
    populations.insert( &quot;ca&quot;,   33148682 );
    populations.insert( &quot;cn&quot;, 1323128240 );
    populations.insert( &quot;dk&quot;,    5457415 );
    populations.insert( &quot;fi&quot;,    5302000 );
    populations.insert( &quot;fr&quot;,   64102140 );
    populations.insert( &quot;gr&quot;,   11147000 );
    populations.insert( &quot;in&quot;, 1131043000 );
    populations.insert( &quot;it&quot;,   59206382 );
    populations.insert( &quot;jp&quot;,  127718000 );
    populations.insert( &quot;mx&quot;,  106535000 );
    populations.insert( &quot;nl&quot;,   16402414 );
    populations.insert( &quot;no&quot;,    4738085 );
    populations.insert( &quot;es&quot;,   45116894 );
    populations.insert( &quot;se&quot;,    9174082 );
    populations.insert( &quot;ch&quot;,    7508700 );

    tk.set( &quot;populations&quot;, populations );

    // Names of the gifts we can send
    tk.arr_set( &quot;gifts&quot;, &quot;card&quot;     , &quot;Greeting card&quot; );
    tk.arr_set( &quot;gifts&quot;, &quot;flowers&quot;  , &quot;Flowers&quot;       );
    tk.arr_set( &quot;gifts&quot;, &quot;nastygram&quot;, &quot;Nastygram&quot;     );

    // Create and grid the outer content frame
    let c = root.add_ttk_frame( &quot;c&quot; -padding(( 5, 5, 12, 0 )) )?
        .grid( -column(0) -row(0) -sticky(&quot;nwes&quot;) )?;
    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure(    0, -weight(1) )?;

    // Create the different widgets; note the variables that many
    // of them are bound to, as well as the button callback.
    // The listbox is the only widget we'll need to refer to directly
    // later in our program, so for convenience we'll assign it to a variable.
    let lbox = c.add_listbox( &quot;countries&quot; -listvariable(&quot;countrynames&quot;) -height(5) )?;
    c.add_ttk_label( &quot;lbl&quot; -text(&quot;Send to country's leader:&quot;) )?;
    c.add_ttk_radiobutton( &quot;g1&quot; -text( tk.arr_get( &quot;gifts&quot;, &quot;card&quot;      )? ) -variable(&quot;gift&quot;) -value(&quot;card&quot;) )?;
    c.add_ttk_radiobutton( &quot;g2&quot; -text( tk.arr_get( &quot;gifts&quot;, &quot;flowers&quot;   )? ) -variable(&quot;gift&quot;) -value(&quot;flowers&quot;) )?;
    c.add_ttk_radiobutton( &quot;g3&quot; -text( tk.arr_get( &quot;gifts&quot;, &quot;nastygram&quot; )? ) -variable(&quot;gift&quot;) -value(&quot;nastygram&quot;) )?;
    c.add_ttk_button( &quot;send&quot;    -text(&quot;Send Gift&quot;) -command(&quot;send_gift&quot;) -default_(&quot;active&quot;) )?;
    c.add_ttk_label(  &quot;sentlbl&quot; -textvariable(&quot;sentmsg&quot;)   -anchor(&quot;center&quot;) )?;
    c.add_ttk_label(  &quot;status&quot;  -textvariable(&quot;statusmsg&quot;) -anchor(&quot;w&quot;) )?;

    // Grid all the widgets
    tk.grid( &quot;.c.countries&quot; -column(0) -row(0) -rowspan(6) -sticky(&quot;nsew&quot;) )?;
    tk.grid( &quot;.c.lbl&quot;       -column(1) -row(0) -padx(10) -pady(5) )?;
    tk.grid( &quot;.c.g1&quot;        -column(1) -row(1) -sticky(&quot;w&quot;) -padx(20) )?;
    tk.grid( &quot;.c.g2&quot;        -column(1) -row(2) -sticky(&quot;w&quot;) -padx(20) )?;
    tk.grid( &quot;.c.g3&quot;        -column(1) -row(3) -sticky(&quot;w&quot;) -padx(20) )?;
    tk.grid( &quot;.c.send&quot;      -column(2) -row(4) -sticky(&quot;e&quot;) )?;
    tk.grid( &quot;.c.sentlbl&quot;   -column(1) -row(5) -columnspan(2) -sticky(&quot;n&quot;) -pady(5) -padx(5) )?;
    tk.grid( &quot;.c.status&quot;    -column(0) -row(6) -columnspan(2) -sticky(&quot;we&quot;) )?;
    c.grid_columnconfigure( 0, -weight(1) )?;
    c.grid_rowconfigure(    5, -weight(1) )?;

    // Set event bindings for when the selection in the listbox changes,
    // when the user double clicks the list, and when they hit the Return key
    lbox.bind( event::virtual_event( &quot;ListboxSelect&quot; ), &quot;show_population&quot; )?;
    lbox.bind( event::double().button_press_1(), &quot;send_gift&quot; )?;
    root.bind( event::key_press( TkKey::Return ), &quot;send_gift&quot; )?;

    // Called when the selection in the listbox changes; figure out
    // which country is currently selected, and then lookup its country
    // code, and from that, its population.  Update the status message
    // with the new population.  As well, clear the message about the
    // gift being sent, so it doesn't stick around after we start doing
    // other things.
    tclosure!( tk, cmd: &quot;show_population&quot;, move || -&gt; TkResult&lt;()&gt; {
        let interp = tcl_interp!();
        let idx = lbox.curselection()?;
        if idx.len() == 1 {
            let idx = idx[0];
            let code = interp.get( &quot;countrycodes&quot; )?.list_index( idx )?
                .map( |obj| obj.get_string() ).unwrap_or_default();
            let name = interp.get( &quot;countrynames&quot; )?.list_index( idx )?
                .map( |obj| obj.get_string() ).unwrap_or_default();
            let popn = interp.get(&quot;populations&quot;)?.dict_get( code.clone() )?
                .map( |obj| obj.get_string() ).unwrap_or_default();
            interp.set( &quot;statusmsg&quot;,
                format!( &quot;The population of {}({}) is {}&quot;, name, code, popn ));
        }
        interp.set( &quot;sentmsg&quot;, &quot;&quot; );
        Ok(())
    });

    // Called when the user double clicks an item in the listbox, presses
    // the &quot;Send Gift&quot; button, or presses the Return key.  In case the selected
    // item is scrolled out of view, make sure it is visible.
    //
    // Figure out which country is selected, which gift is selected with the
    // radiobuttons, &quot;send the gift&quot;, and provide feedback that it was sent.
    tclosure!( tk, cmd: &quot;send_gift&quot;, move || -&gt; TkResult&lt;()&gt; {
        let interp = tcl_interp!();
        let idx = lbox.curselection()?;
        if idx.len() == 1 {
            let idx = idx[0];
            lbox.see( idx )?;
            let gift = interp.get(&quot;gift&quot;)?;
            let gift = interp.arr_get( &quot;gifts&quot;, gift )?;
            let name = interp
                .get( &quot;countrynames&quot; )?
                .list_index( idx )?
                .map( |obj| obj.get_string() )
                .unwrap_or_default();
            // Gift sending left as an exercise to the reader
            interp.set( &quot;sentmsg&quot;,
                format!( &quot;Sent {} to leader of {}&quot;, gift, name ));
        }
        Ok(())
    });

    // Colorize alternating lines of the listbox
    let len = tk.get( &quot;countrynames&quot; )?.list_length()?;
    (0..len).step_by(2).try_for_each( |i| -&gt; InterpResult&lt;()&gt; {
        Ok( lbox.itemconfigure( i, -background(&quot;#f0f0ff&quot;) )? )
    })?;

    // Set the starting state of the interface, including selecting the
    // default gift to send, and clearing the messages.  Select the first
    // country in the list; because the &lt;&lt;ListboxSelect&gt;&gt; event is only
    // fired when users makes a change, we explicitly call showPopulation.
    tk.set( &quot;gift&quot;, &quot;card&quot; );
    tk.set( &quot;sentmsg&quot;, &quot;&quot; );
    tk.set( &quot;statusmsg&quot;, &quot;&quot; );
    lbox.selection_set_range( 0.. )?;
    tk.run( &quot;show_population&quot; )?;

    Ok( main_loop() )
}
</code></pre></pre>
<p>One obvious thing missing from this example was that while the list of countries
could be quite long, only part of it fits on the screen at once. To show
countries further down in the list, you had to either drag with your mouse or
use the down arrow key. A scrollbar would have been nice. Let's fix that.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrollbar"><a class="header" href="#scrollbar">Scrollbar</a></h1>
<p>A <em>scrollbar</em> widget helps users see all parts of another widget, whose content
is typically much larger than what can be shown in the available screen space.</p>
<table><thead><tr><th style="text-align: center">Scrollbar widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_scrollbar_all.png" alt="Scrollbar widgets." /></td></tr>
</tbody></table>
<p>Scrollbars are created using the <code>add_ttk_scrollbar</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = parent
    .add_ttk_scrollbar( &quot;s&quot;
        -orient( &quot;vertical&quot; )
        -command( tclosure!( tk,
            move |..| -&gt; TkResult&lt;(c_double, c_double)&gt; {
                Ok( l.yview()? )
            }
        ))
    )?;

l.configure( -yscrollcommand( tclosure!( tk,
    move |first:c_double, last:c_double| -&gt; TkResult&lt;()&gt; {
        Ok( s.set( first, last )? )
    }
)))?;
<span class="boring">}
</span></code></pre></pre>
<p>Unlike in some user interface toolkits, Tk scrollbars are not a part of another
widget (e.g., a listbox), but are a separate widget altogether. Instead,
scrollbars communicate with the scrolled widget by calling methods on the
scrolled widget; as it turns out, the scrolled widget also needs to call methods
on the scrollbar. </p>
<blockquote>
<p>If you're using a recent Linux distribution, you've probably noticed that the
scrollbars you see in many applications have changed to look more like what
you'd see on macOS. This newer look isn't supported on Linux by any of the
default themes included with Tk. However, some third-party themes do support it.</p>
</blockquote>
<p>The <code>orient</code> configuration option determines whether the scrollbar will scroll
the scrolled widget in the <code>horizontal</code> or <code>vertical</code> dimension. You then need
to use the <code>command</code> configuration option to specify how to communicate with the
scrolled widget. This is the method to call on the scrolled widget when the
scrollbar moves.</p>
<p>Every widget that can be scrolled vertically includes a method named <code>yview</code>,
while those that can be scrolled horizontally have a method named <code>xview</code>). As
long as this method is present, the scrollbar doesn't need to know anything else
about the scrolled widget. When the scrollbar is manipulated, it appends several
parameters to the method call, indicating how it was scrolled, to what position,
etc.</p>
<p>The scrolled widget also needs to communicate back to the scrollbar, telling it
what percentage of the entire content area is now visible. Besides the <code>yview</code>
and/or <code>xview</code> methods, every scrollable widget also has a <code>yscrollcommand</code>
and/or <code>xscrollcommand</code> configuration option. This is used to specify a method
call, which must be the scrollbar's <code>set</code> method. Again, additional parameters
will be automatically tacked onto the method call.</p>
<blockquote>
<p>If, for some reason, you want to move the scrollbar to a particular position
from within your program, you can call the <code>set( first, last )</code> method yourself.
Pass it two floating-point values (between 0 and 1) indicating the start and end
percentage of the content area that is visible.</p>
</blockquote>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Listboxes are one of several types of widgets that are scrollable. Here, we'll
build a very simple user interface, consisting of a vertically scrollable
listbox that takes up the entire window, with just a status line at the bottom.</p>
<table><thead><tr><th style="text-align: center">Scrolling a listbox</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/scrollbar_l.png" alt="Scrolling a listbox." /></td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example scrollbar

use std::os::raw::c_double;

use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let l = root.add_listbox( &quot;l&quot; -height(5) )?
        .grid( -column(0) -row(0) -sticky(&quot;nwes&quot;) )?;

    let s = root.add_ttk_scrollbar( &quot;s&quot;
            -orient(&quot;vertical&quot;)
            -command( tclosure!( tk,
                move |..| -&gt; TkResult&lt;(c_double, c_double)&gt; { Ok( l.yview()? )})))?
        .grid( -column(1) -row(0) -sticky(&quot;ns&quot;) )?;

    l.configure( -yscrollcommand( tclosure!( tk,
        move |first:c_double, last:c_double| -&gt; TkResult&lt;()&gt; { Ok( s.set( first, last )? )})))?;

    root.add_ttk_label( &quot;stat&quot; -text(&quot;Status message here&quot;) -anchor(&quot;w&quot;) )?
        .grid( -column(0) -columnspan(2) -row(1) -sticky(&quot;we&quot;) )?;

    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure(    0, -weight(1) )?;

    for i in 0..100 {
       l.insert_end( Some( Obj::from( format!( &quot;Line {} of 100&quot;, i ))))?;
    }

    Ok( main_loop() )
}
</code></pre></pre>
<blockquote>
<p>If you've seen an earlier version of this tutorial, you might recall that at
this point we introduced a <code>sizegrip</code> widget. It placed a small handle at the
bottom right of the window, allowing users to resize the window by dragging the
handle. This was commonly seen on some platforms, including older versions of
macOS. Some older versions of Tk even automatically added this handle to the
window for you.</p>
</blockquote>
<blockquote>
<p>Platform conventions tend to evolve faster than long-lived open source GUI
toolkits. Mac OS X 10.7 did away with the size grip in the corner, in favor of
allowing resizing from any window edge, finally catching up with the rest of the
world. Unless there's a pressing need to be visually compatible with 10+ year
old operating systems, if you have a <code>sizegrip</code> in your application, it's
probably best to remove it</p>
</blockquote>
<h2 id="run-example-8"><a class="header" href="#run-example-8">Run Example</a></h2>
<p><code>cargo run --example scrollbar</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p>A <em>text</em> widget provides users with an area so that they can enter multiple
lines of text. Text widgets are part of the classic Tk widgets, not the themed
Tk widgets.</p>
<table><thead><tr><th style="text-align: center">Text widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_text_all.png" alt="Text widgets." /></td></tr>
</tbody></table>
<blockquote>
<p>Tk's text widget is, along with the canvas widget, one of two uber-powerful
widgets that provide amazingly deep but easily programmed features. Text widgets
have formed the basis for full word processors, outliners, web browsers, and
more. We'll get into some of the advanced stuff in a later chapter. Here, we'll
show you how to use the text widget to capture fairly simple, multi-line text
input. </p>
</blockquote>
<p>Text widgets are created using the <code>add_tk_text</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_tk_text( &quot;t&quot; -width(40) -height(10) )?;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>width</code> and <code>height</code> options specify the requested screen size of the text
widget, in characters and rows, respectively. The contents of the text can be
arbitrarily large. You can use the <code>wrap</code> configuration option to control how
line wrapping is handled: values are <code>none</code> (no wrapping, text may horizontally
scroll), char (wrap at any character), and <code>word</code> (wrapping will only occur at
word boundaries).</p>
<p>A text widget can be disabled so that no editing can occur. Because text is not
a themed widget, the usual <code>state</code> and <code>instate</code> methods are not available.
Instead, use the configuration option <code>state</code>, setting it to either <code>disabled</code>
or <code>normal</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.configure( -state(&quot;disabled&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Scrolling works the same way as in listboxes. The <code>xscrollcommand</code> and
<code>yscrollcommand</code> configuration options attach the text widget to horizontal
and/or vertical scrollbars, and the <code>xview</code> and <code>yview</code> methods are called from
scrollbars. To ensure that a given line is visible (i.e., not scrolled out of
view), you can use the <code>see( index )</code> method. </p>
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<p>Text widgets do not have a linked variable associated with them like, for
example, entry widgets do. To retrieve the contents of the entire text widget,
call the method <code>get( text::line_char(1,0).. )</code>; the <code>text::line_char(1,0)</code> is
an index into the text, and means the first character of the first line, and
<code>std::ops::RangeTo</code> is a shortcut for the index of the last character in the
last line. Other indices could be provided to retrieve smaller ranges of text if
needed.</p>
<p>Text can be added to the widget using the <code>insert( index, string )</code> method;
<code>index</code> marks the character before which text is inserted; use <code>Index::end()</code> to
add text to the end of the widget. You can delete a range of text using the
<code>delete( index )</code> or <code>delete( range )</code> method, where <code>range</code> is in the form of
<code>..</code>, <code>start..</code>, <code>start..=end</code>, <code>..=end</code>.</p>
<p>We'll get into the text widget's many additional advanced features in a later
chapter.</p>
<h2 id="run-example-9"><a class="header" href="#run-example-9">Run Example</a></h2>
<p><code>cargo run --example text</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scale"><a class="header" href="#scale">Scale</a></h1>
<p>A <em>scale</em> widget allows users to choose a numeric value through direct
manipulation.</p>
<table><thead><tr><th style="text-align: center">Scale widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_scale_all.png" alt="Scale widgets." /></td></tr>
</tbody></table>
<p>Scale widgets are created using the <code>add_ttk_scale</code> method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_scale( &quot;s&quot;
    -orient(&quot;horizontal&quot;) -length(&quot;200&quot;) -from(&quot;1.0&quot;) -to(&quot;100.0&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>orient</code> option may be either <code>horizontal</code> or <code>vertical</code>. The <code>length</code>
option, which represents the longer axis of either horizontal or vertical
scales, is specified in screen units (e.g., pixels). You should also define the
range of the number that the scale allows users to choose; to do this, set a
floating-point number for each of the <code>from</code> and <code>to</code> configuration options.</p>
<p>There are several different ways you can set the current value of the scale
(which must be a floating-point value between the <code>from</code> and <code>to</code> values). You
can set (or read, to get the current value) the scale's <code>value</code> configuration
option. You can link the scale to a variable using the <code>variable</code> option. Or,
you can call the scale's <code>set( value )</code> method to change the value, or the
<code>get()</code> method to read the current value.</p>
<p>A <code>command</code> configuration option lets you specify a script to call whenever the
scale is changed. Tk will append the current value of the scale as a parameter
each time it calls this script (we saw a similar thing with extra parameters
being added to scrollbar callbacks).</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example scale

use std::os::raw::c_double;
use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    // label tied to the same variable as the scale, so auto-updates
    root.add_ttk_label( &quot;auto&quot; -textvariable(&quot;num&quot;) )?
        .grid( -column(0) -row(0) -sticky(&quot;we&quot;) )?;
    
    // label that we'll manually update via the scale's command callback
    let manual = root.add_ttk_label( &quot;manual&quot; )?
        .grid( -column(0) -row(1) -sticky(&quot;we&quot;) )?;
    
    let scale =
        root.add_ttk_scale( &quot;scale&quot;
            -orient(   &quot;horizontal&quot; )
            -length(   &quot;200&quot;        )
            -from(     1.0          )
            -to(       100.0        )
            -variable( &quot;num&quot;        )
            -command(  tclosure!( tk, move |val: c_double| -&gt; TkResult&lt;()&gt; {
                Ok( manual.configure( -text( format!( &quot;Scale at {}&quot;, val )))? )
            }))
        )?
       .grid( -column(0) -row(2) -sticky(&quot;we&quot;) )?; 
    
    scale.set( 20.0 )?;

    Ok( main_loop() )
}
</code></pre></pre>
<p>As with other themed widgets, you can use the <code>state( TkState::Disabled )</code>,
<code>state( !TkState::Disabled )</code>, and <code>instate( TkState::Disabled )</code> methods to
prevent users from modifying the scale.</p>
<blockquote>
<p>As the scale widget does not display the actual values, you may want to add
those separately, e.g., using label widgets.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spinbox"><a class="header" href="#spinbox">Spinbox</a></h1>
<p>A <em>spinbox</em> widget allows users to choose numbers (or, in fact, items from an
arbitrary list). It does this by combining an entry-like widget showing the
current value with a pair of small up/down arrows, which can be used to step
through the range of possible choices.</p>
<table><thead><tr><th style="text-align: center">Spinbox widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_spinbox_all.png" alt="Spinbox widgets." /></td></tr>
</tbody></table>
<p>Spinbox widgets are created using the <code>add_ttk_spinbox</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_spinbox( &quot;s&quot; -from(1.0) -to(100.0) -textvariable(&quot;spinval&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Like scale widgets, spinboxes let users choose a number between a certain range
(specified using the <code>from</code> and <code>to</code> configuration options), though through a
very different user interface. You can also specify an <code>increment</code>, which
controls how much the value changes every time you click the up or down button.</p>
<p>Like a listbox or combobox, spinboxes can also be used to let users choose an
item from an arbitrary list of strings; these can be specified using the
<code>values</code> configuration option. This works in the same way it does for
comboboxes; specifying a list of values will override to <code>from</code> and <code>to</code>
settings.</p>
<p>In their default state, spinboxes allow users to select values either via the up
and down buttons, or by typing them directly into the entry area that displays
the current value. If you'd like to disable the latter feature, so that only the
up and down buttons are available, you can set the <code>TtkState::ReadOnly</code> state
flag. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>s.set_state( TtkState::ReadOnly )?;
<span class="boring">}
</span></code></pre></pre>
<p>Like other themed widgets, you can also disable spinboxes, via the
<code>TtkState::Disabled</code> state flag, or check the state via the <code>instate</code> method.
Spinboxes also support validation in the same manner as entry widgets, using the
<code>validate</code> and <code>validatecommand</code> configuration options.</p>
<blockquote>
<p>You might be puzzled about when to choose a scale, listbox, combobox, entry,
or a spinbox. Often, several of these can be used for the same types of data.
The answer really depends on what you want users to select, platform user
interface conventions, and the role the value plays in your user interface.</p>
</blockquote>
<blockquote>
<p>For example, both a combobox and a spinbox take up fairly small amounts of
space compared with a listbox. They might make sense for a more peripheral
setting. A more primary and prominent choice in a user interface may warrant the
extra space a listbox occupies. Spinboxes don't make much sense when items don't
have a natural and obvious ordering to them. Be careful about putting too many
items in both comboboxes and spinboxes. This can make it more time consuming to
select an item.</p>
</blockquote>
<p>There is a boolean <code>wrap</code> option that determines whether the value should wrap
around when it goes beyond the starting or ending values. You can also specify a
width for the entry holding the current value of the spinbox.</p>
<p>Again there are choices as to how to set or get the current value in the
spinbox. Normally, you would specify a linked variable with the <code>textvariable</code>
configuration option. As usual, any changes to the variable are reflected in the
spinbox, while any changes in the spinbox are reflected in the linked variable.
As well, the <code>set( value )</code> and <code>get()</code> methods allow you to set or get the
value directly.</p>
<p>Spinboxes generate virtual events when users press up
(<code>event::virtual_event(&quot;Increment&quot;)</code>) or down
(<code>event::virtual_event(&quot;Decrement&quot;)</code>). A <code>command</code> configuration option allows
you to provide a callback that is invoked on any changes.</p>
<h2 id="run-example-10"><a class="header" href="#run-example-10">Run Example</a></h2>
<p><code>cargo run --example spinbox</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progressbar"><a class="header" href="#progressbar">Progressbar</a></h1>
<p>A <em>progressbar</em> widget provides feedback to users about the progress of a
lengthy operation.</p>
<p>In situations where you can estimate how long the operation will take to
complete, you can display what fraction has already been completed. Otherwise,
you can indicate the operation is continuing, but without suggesting how much
longer it will take.</p>
<table><thead><tr><th style="text-align: center">Progressbar widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_progressbar_all.png" alt="Progressbar widgets." /></td></tr>
</tbody></table>
<p>Progressbar widgets are created using the <code>addttk_progressbar</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_progressbar( -orient(&quot;horizontal&quot;) -length(200) -mode(&quot;determinate&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>As with scale widgets, they should be given an orientation (<code>horizontal</code> or
<code>vertical</code>) with the orient configuration option, and can be given an optional
<code>length</code>. The <code>mode</code> configuration option can be set to either <code>determinate</code>,
where the progressbar will indicate relative progress towards completion, or to
<code>indeterminate</code>, where it shows that the operation is still continuing but
without showing relative progress.</p>
<h2 id="determinate-progress"><a class="header" href="#determinate-progress">Determinate Progress</a></h2>
<p>To use determinate mode, estimate the total number of &quot;steps&quot; the operation will
take to complete. This could be an amount of time but doesn't need to be.
Provide this to the progressbar using the <code>maximum</code> configuration option. It
should be a floating-point number and defaults to <code>100.0</code> (i.e., each step is
1%).</p>
<p>As you proceed through the operation, tell the progressbar how far along you are
with the <code>value</code> configuration option. So this would start at 0, and then count
upwards to the maximum value you have set.</p>
<blockquote>
<p>There are two slight variations on this. First, you can just store the current
value for the progressbar in a variable linked to it by the progressbar's
<code>variable</code> configuration option; that way, when you change the variable, the
progressbar will update. The other alternative is to call the progressbar's
<code>step( amount )</code> method. This increments the value by the given amount.</p>
</blockquote>
<h2 id="indeterminate-progress"><a class="header" href="#indeterminate-progress">Indeterminate Progress</a></h2>
<p>Use indeterminate mode when you can't easily estimate how far along in a
long-running task you actually are. However, you still want to provide feedback
that the operation is continuing (and that your program hasn't crashed). At the
start of the operation you'll just call the progressbar's <code>start</code> method. At the
end of the operation, call its <code>stop</code> method. The progressbar will take care of
the rest.</p>
<p>Unfortunately, &quot;the progressbar will take care of the rest&quot; isn't quite so
simple. In fact, if you <code>start</code> the progressbar, call a function that takes
several minutes to complete, and then <code>stop</code> the progressbar, your program will
appear frozen the whole time, with the progressbar not updating. In fact, it
will not likely appear onscreen at all. Yikes!</p>
<p>To learn why that is, and how to address it, the next chapter takes a deeper
dive into Tk's event loop.</p>
<h2 id="run-example-11"><a class="header" href="#run-example-11">Run Example</a></h2>
<p><code>cargo run --example progressbar</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-loop"><a class="header" href="#event-loop">Event Loop</a></h1>
<p>At the end of the last chapter, we explained how to use a progressbar to provide
feedback to users about long-running operations. The progressbar itself was
simple: call it's <code>start</code> method, perform your operation, and then call it's
stop method. Unfortunately, you learned that if you tried this, your application
will most likely appear completely frozen.</p>
<p>To understand why, we need to revisit our discussion of event handling, way back
in the Tk Concepts chapter. As we've seen, after we construct an application's
initial user interface, it enters the Tk event loop. In the event loop, it
continually processes events, pulled from the system event queue, usually dozens
of times a second. It watches for mouse or keyboard events, invoking command
callbacks and event bindings as needed.</p>
<p>Less obviously, all screen updates are processed only in the event loop. For
example, you may change the text of a label widget. However, that change doesn't
appear onscreen immediately. Instead, the widget notifies Tk that it needs to be
redrawn. Later on, in between processing other events, Tk's event loop will ask
the widget to redraw itself. All drawing occurs only in the event loop. The
change appears to happen immediately because the time between making the change
to the widget and the actual redraw in the event loop is so small.</p>
<table><thead><tr><th style="text-align: center">Event loop showing application callbacks and screen updates</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/eventloop.png" alt="Event loop showing application callbacks and screen updates." /></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocking-the-event-loop"><a class="header" href="#blocking-the-event-loop">Blocking the Event Loop</a></h1>
<p>Where you run into problems is when the event loop is prevented from processing
events for a lengthy period of time. Your application won't redraw or respond to
events and will appear to be frozen. The event loop is said to be blocked. How
can this happen?</p>
<p>Let's start by visualizing the event loop as an execution timeline. In a normal
situation, each deviation from the event loop (callback, screen update) takes
only a fraction of a second before returning control to the event loop.</p>
<table><thead><tr><th style="text-align: center">Execution timeline for well-behaved event loop</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/eventtimeline.png" alt="Execution timeline for well-behaved event loop." /></td></tr>
</tbody></table>
<p>In our scenario, the whole thing probably got started from an event like a user
pressing a button. So the event loop calls our application code to handle the
event. Our code creates the progressbar, performs the (lengthy) operations, and
stops the progressbar. Only then does our code return control back to the event
loop. No events have been processed in the meantime. No screen redrawing has
occurred. They've just been piling up in the event queue.</p>
<table><thead><tr><th style="text-align: center">Lengthy callback blocking the event loop</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/blocktimeline.png" alt="Lengthy callback blocking the event loop." /></td></tr>
</tbody></table>
<p>To prevent blocking the event loop, it's essential that event handlers execute
quickly and return control back to the event loop.</p>
<p>If you do have a long-running operation to perform, or anything like network I/O
that could potentially take a long time, there are a few different approaches
you can take.</p>
<blockquote>
<p>For the more technically-inclined, Tk uses a single-threaded, event-driven
programming model. All the GUI code, the event loop, and your application run
within the same thread. Because of this, any calls or computations that block
event handlers are highly discouraged. Some other GUI toolkits use different
models that allow for blocking code, runs the GUI and event handlers in separate
threads from application code, etc. Attempting to shoehorn these models into Tk
can be a recipe for frustration and lead to fragile and hacky code. If you
respect Tk's model rather than try to fight with it, you won't run into
problems. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one-step-at-a-time"><a class="header" href="#one-step-at-a-time">One Step at a Time</a></h1>
<p>If possible, the very best thing you can do is break your operation into very
small steps, each of which can execute very quickly. You let the event loop be
responsible for when the next step occurs. That way, the event loop continues to
run, processing regular events, updating the screen, and, in between all that,
calling your code to perform the next step of the operation.</p>
<p>To do this, we make use of timer events. Our program can ask the event loop to
generate one of these events at some time in the future. As part of its regular
work, when the event loop reaches that time, it will call back into our code to
handle the event. Our code would perform the next step of the operation. It then
schedules another timer event for the next step of the operation and immediately
returns control back to the event loop.</p>
<table><thead><tr><th style="text-align: center">Breaking up a large operation into small steps tied together with timer events</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/aftertimeline.png" alt="Breaking up a large operation into small steps tied together with timer events." /></td></tr>
</tbody></table>
<p>Tcl's <code>after</code> command can be used to generate timer events. You provide the
number of milliseconds to wait until the event should be fired. It may happen
later than that if Tk is busy processing other events but won't happen before
that. You can also ask that an <code>idle</code> event be generated; it will fire when no
other events in the queue need to be processed. (Tk's screen updates and redraws
occur in the context of idle events.) You can find more details on <code>after</code> in
the <a href="https://docs.rs/tcl/after/index.html">reference manual</a>.</p>
<p>In the following example, we'll perform a long operation that is broken up into
20 small steps. While this operation is being performed, we'll update a
progressbar, and also allow users to interrupt the operation.</p>
<p>In the following example, we'll perform a long operation that is broken up into
20 small steps. While this operation is being performed, we'll update a
progressbar, and also allow users to interrupt the operation.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example one_step_at_a_time

use std::os::raw::c_int;
use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let f = root.add_ttk_frame( &quot;f&quot; )?
        .grid(())?;
    let f_b = f.add_ttk_button( &quot;b&quot; -text(&quot;Start!&quot;) )?
        .grid( -column(1) -row(0) -padx(5) -pady(5) )?;
    let f_l = f.add_ttk_label( &quot;l&quot; -text(&quot;No Answer&quot;) )?
        .grid( -column(0) -row(0) -padx(5) -pady(5) )?;
    let f_p = f.add_ttk_progressbar( &quot;p&quot; -orient(&quot;horizontal&quot;) -mode(&quot;determinate&quot;) -maximum(20) )?
        .grid( -column(0) -row(1) -padx(5) -pady(5) )?;

    tclfn!( tk, fn stop() -&gt; TkResult&lt;()&gt; {
        tcl_interp!().set( &quot;interrupt&quot;, 1 );
        Ok(())
    });

    tclosure!( tk, cmd: &quot;result&quot;, move |answer: String| -&gt; TkResult&lt;()&gt; {
        f_p.configure( -value(0) )?;
        f_b.configure( -text(&quot;Start!&quot;) -command(&quot;start&quot;) )?;
        f_l.configure( -text({
            if answer.is_empty() {
                &quot;No Answer&quot;.to_owned()
            } else {
                format!( &quot;Answer: {}&quot;, answer )
            }
        }))?;
        Ok(())
    });

    tclosure!( tk, cmd: &quot;step&quot;, move |count: c_int| -&gt;TkResult&lt;()&gt; {
        let interp = tcl_interp!();

        f_p.configure( -value(count) )?;
        if interp.get_boolean(&quot;interrupt&quot;)? {
            interp.eval( &quot;result {}&quot; )?;
            return Ok(());
        }
        interp.after_ms( 100 )?; // next step in our operation; don't take too long!

        if count == 20 {
            interp.eval( &quot;result 42&quot; )?;
            return Ok(());  // done!
        }

        interp.after( 100, ( tclosure!( tk, move || -&gt; TkResult&lt;()&gt; {
            tcl_interp!().eval(( &quot;step&quot;, count+1 ))?;
            Ok(())
        }), ))?;

        Ok(())
    });

    f_b.configure( -command( tclosure!( tk, cmd:&quot;start&quot;, move || -&gt; TkResult&lt;()&gt; {
        f_b.configure( -text(&quot;Stop&quot;) -command(&quot;stop&quot;) )?;
        f_l.configure( -text(&quot;Working...&quot;) )?;
        let interp = tcl_interp!();
        interp.set( &quot;interrupt&quot;, 0 );
        interp.set( &quot;count&quot;, 1 );
        interp.after( 1, ( &quot;step 0&quot;, ))?;
        Ok(())
    })))?;

    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-io"><a class="header" href="#asynchronous-io">Asynchronous I/O</a></h1>
<p>Timer events take care of breaking up a long-running computation, where you know
that each step can be guaranteed to complete quickly so that your handler will
return to the event loop. What if you have an operation that may not complete
quickly? This can happen when you make a variety of calls to the operating
system. The most common is when we're doing some kind of I/O, whether writing a
file, communicating with a database, or retrieving data from a remote web
server.</p>
<p>Most I/O calls are blocking. They don't return until the operation completes (or
fails). What we want to use instead are non-blocking or asynchronous I/O calls.
When you make an asynchronous I/O call, it returns immediately, before the
operation is completed. Your code can continue running, or in this case, return
back to the event loop. Later on, when the I/O operation completes, your program
is notified and can process the result of the I/O operation.</p>
<p>If this sounds like treating I/O as another type of event, you're exactly right.
In fact, it's also called event-driven I/O. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads-or-processes"><a class="header" href="#threads-or-processes">Threads or Processes</a></h1>
<p>Sometimes it's either not possible or practical to break up a long-running
computation into discrete pieces that each run quickly. Or you may be using a
library that doesn't support asynchronous operations. Or, like Python's asyncio,
it doesn't play nice with Tk's event loop. In cases like these, to keep your Tk
GUI responsive, you'll need to move those time-consuming operations or library
calls out of your event handlers and run them somewhere else. Threads, or even
other processes, can help with that.</p>
<p>Running tasks in threads, communicating with them, etc. is beyond the scope of
this tutorial. However, there are some restrictions on using Tk with threads
that you should be aware of. The main rule is that you must only make Tk calls
from the thread where you loaded Tk. Sometimes it's either not possible or
practical to break up a long-running computation into discrete pieces that each
run quickly. Or you may be using a library that doesn't support asynchronous
operations. Or, like Python's asyncio, it doesn't play nice with Tk's event
loop. In cases like these, to keep your Tk GUI responsive, you'll need to move
those time-consuming operations or library calls out of your event handlers and
run them somewhere else. Threads, or even other processes, can help with that.</p>
<p>Running tasks in threads, communicating with them, etc. is beyond the scope of
this tutorial. However, there are some restrictions on using Tk with threads
that you should be aware of. The main rule is that you must only make Tk calls
from the thread where you loaded Tk. </p>
<p>It can be even more complicated. The Tcl/Tk libraries can be built either with
or without thread support. If you have more than one thread in your application,
make sure you're running in a threaded build. If you're unsure, check the Tcl
variable <code>tcl_platform(threaded)</code>; it should be 1, not 0. </p>
<blockquote>
<p>Most everyone should be running threaded builds. The ability to create
non-threaded builds in Tcl/Tk is likely to go away in future. If you're using a
non-threaded build with threaded code, consider this a bug in your application,
not a challenge to make it work.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-event-processing"><a class="header" href="#nested-event-processing">Nested Event Processing</a></h1>
<p>The previous three approaches are the correct ways to handle long-running
operations while still keeping you Tk GUI responsive. What they have in common
is a single event loop that continuously processes events of all kinds. That
event loop will call event handlers in your application code, which do their
thing and quickly return.</p>
<p>There is one other way. Within your long-running operation, you can invoke the
event loop to process a bunch of events. You can do this with a single command,
<code>update</code>. There's no messing around with timer events or asynchronous I/O.
Instead, you just sprinkle some <code>update</code> calls throughout your operation. If you
want to only keep the screen redrawing but not process other events, there's
even an option for that (<code>update_idletasks</code>).</p>
<p>This approach is seductively easy. And if you're lucky, it might work. At least
for a little while. But sooner or later, you're going to run into serious
difficulties trying to do things that way. Something won't be updating, event
handlers aren't getting called that should be, events are going missing or being
fired out of order, or worse. You'll turn your program's logic inside out and
tear your hair out trying to make it work again.</p>
<blockquote>
<p>When you use <code>update</code>, you're not returning control back to the running event
loop. You're effectively starting a new event loop nested within the existing
one. Remember, the event loop follows a single thread of execution: no threads,
no coroutines. If you're not careful, you're going to end up with event loops
called from within event loops called from... well, you get the idea. If you
even realize you're doing this, unwinding the event loops (each of which may
have different conditions to terminate it) will be an interesting exercise. The
reality won't match with your mental model of a simple event loop dispatching
events one at a time, independent of every other event. It's a classic example
of fighting against Tk's model. In very specific circumstances, it's possible to
make it work. In practice, you're asking for trouble. Don't say you haven't been
warned... </p>
</blockquote>
<table><thead><tr><th style="text-align: center">Nested event loops... this way madness lies</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/nestedeventloop.png" alt="Nested event loops." /></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="menus"><a class="header" href="#menus">Menus</a></h1>
<p>This chapter describes how to handle menubars and popup menus in Tk. For a
polished application, these are areas you particularly want to pay attention to.
Menus need special care if you want your application to fit in with other
applications on your users' platform.</p>
<p>Speaking of which, the recommended way to figure out which platform you're
running on is:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.windowingsystem()?.to_string();  // returns &quot;x11&quot;, &quot;win32&quot; or &quot;aqua&quot;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>This is more useful than examining global variables like <code>tcl_platform</code> or
<code>sys.platform</code>, and older checks that used these methods should be reviewed.
While in the olden days, there was a pretty good correlation between platform
and windowing system, it's less true today. For example, if your platform is
identified as Unix, that might mean Linux under X11, macOS under Aqua, or even
macOS under X11.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="menubars"><a class="header" href="#menubars">Menubars</a></h1>
<p>In this section, we'll look at menubars: how to create them, what goes in them,
how they're used, etc.</p>
<p>Properly designing a menubar and its set of menus is beyond the scope of this
tutorial. However, if you're creating an application for someone other than
yourself, here is a bit of advice. First, if you find yourself with many menus,
very long menus, or deeply nested menus, you may need to rethink how your user
interface is organized. Second, many people use the menus to explore what the
program can do, particularly when they're first learning it, so try to ensure
major features are accessible by the menus. Finally, for each platform you're
targeting, become familiar with how applications use menus, and consult the
platform's human interface guidelines for full details about design,
terminology, shortcuts, and much more. This is an area you will likely have to
customize for each platform.</p>
<table><thead><tr><th style="text-align: center">Menubars</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/menubar_all.png" alt="Menubars." /></td></tr>
</tbody></table>
<blockquote>
<p>You'll notice on some recent Linux distributions that many applications show
their menus at the top of the screen when active, rather than in the window
itself. Tk does not yet support this style of menus.</p>
</blockquote>
<h2 id="menu-widgets-and-hierarchy"><a class="header" href="#menu-widgets-and-hierarchy">Menu Widgets and Hierarchy</a></h2>
<p>Menus are implemented as widgets in Tk, just like buttons and entries. Each menu
widget consists of a number of different items in the menu. Items have various
attributes, such as the text to display for the item, a keyboard accelerator,
and a command to invoke.</p>
<p>Menus are arranged in a hierarchy. The menubar is itself a menu widget. It has
several items (&quot;File,&quot; &quot;Edit,&quot; etc.), each of which is a submenu containing more
items. These items can include things like the &quot;Open...&quot; command in a &quot;File&quot;
menu, but also separators between other items. It can even have items that open
up their own submenu (so-called cascading menus). As you'd expect from other
things you've seen already in Tk, anytime you have a submenu, it must be created
as a child of its parent menu.</p>
<p>Menus are part of the classic Tk widgets; there is not presently a menu in the
themed Tk widget set.Menus are implemented as widgets in Tk, just like buttons
and entries. Each menu widget consists of a number of different items in the
menu. Items have various attributes, such as the text to display for the item, a
keyboard accelerator, and a command to invoke.</p>
<p>Menus are arranged in a hierarchy. The menubar is itself a menu widget. It has
several items (&quot;File,&quot; &quot;Edit,&quot; etc.), each of which is a submenu containing more
items. These items can include things like the &quot;Open...&quot; command in a &quot;File&quot;
menu, but also separators between other items. It can even have items that open
up their own submenu (so-called cascading menus). As you'd expect from other
things you've seen already in Tk, anytime you have a submenu, it must be created
as a child of its parent menu.</p>
<p>Menus are part of the classic Tk widgets; there is not presently a menu in the
themed Tk widget set.</p>
<h2 id="before-you-start"><a class="header" href="#before-you-start">Before you Start</a></h2>
<p>It's essential to put the following line in your application somewhere before
you start creating menus.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.option_add( &quot;*tearOff&quot;, 0 )?;
<span class="boring">}
</span></code></pre></pre>
<p>Without it, each of your menus (on Windows and X11) will start with what looks
like a dashed line and allows you to &quot;tear off&quot; the menu, so it appears in its
own window. You should eliminate tear-off menus from your application as they're
not a part of any modern user interface style.</p>
<blockquote>
<p>This is a throw-back to the Motif-style X11 that Tk's original look and feel
were based on. Get rid of them unless your application is designed to run only
on that old box collecting dust in the basement. We'll all look forward to a
future version of Tk where this misguided paean to backward compatibility is
removed.</p>
</blockquote>
<blockquote>
<p>While on the topic of ancient history, the <code>option_add</code> bit uses the option
database. On X11 systems, this provided a standardized way to customize certain
elements of user interfaces through text-based configuration files.  It's no
longer used today. Older Tk programs may use the <code>option</code> command internally to
separate style configuration options from widget creation code.  This all
pre-dated themed Tk styles, which should be used for that purpose today.
However, it's somehow fitting to use the obsolete option database to
automatically remove the obsolete tear-off menus.</p>
</blockquote>
<h2 id="creating-a-menubar"><a class="header" href="#creating-a-menubar">Creating a Menubar</a></h2>
<p>In Tk, menubars are associated with individual windows; each toplevel window can
have at most one menubar. On Windows and many X11 window managers, this is
visually obvious, as the menus are part of each window, sitting just below the
title bar at the top.</p>
<p>On macOS, though, there is a single menubar along the top of the screen, shared
by each window. As far as your Tk program is concerned, each window still does
have its own menubar. As you switch between windows, Tk ensures that the correct
menubar is displayed. If you don't specify a menubar for a particular window, Tk
will use the menubar associated with the root window; you'll have noticed by now
that this is automatically created for you when your Tk application starts.</p>
<blockquote>
<p>Because all windows have a menubar on macOS, it's important to define one,
either for each window or a fallback menubar for the root window. Otherwise,
you'll end up with the &quot;built-in&quot; menubar, which contains menus that are only
intended for typing commands directly into the interpreter.Because all windows
have a menubar on macOS, it's important to define one, either for each window or
a fallback menubar for the root window. Otherwise, you'll end up with the
&quot;built-in&quot; menubar, which contains menus that are only intended for typing
commands directly into the interpreter.</p>
</blockquote>
<p>To create a menubar for a window, first, create a menu widget. Then, use the
window's <code>menu</code> configuration option to attach the menu widget to the window.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let win = root.add_toplevel(())?;
let menubar = win.add_menu(())?;
win.configure( -menu(menubar) )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>You can use the same menubar for more than one window. In other words, you can
specify the same menubar as the <code>menu</code> configuration option for several toplevel
windows. This is particularly useful on Windows and X11, where you may want a
window to include a menu, but don't necessarily need to juggle different menus
in your application. However, if the contents or state of menu items depends on
what's going on in the active window, you'll have to manage this yourself.</p>
</blockquote>
<blockquote>
<p>This is truly ancient history, but menubars used to be implemented by creating
a frame widget containing the menu items and packing it into the top of the
window like any other widget. Hopefully, you don't have any code or
documentation that still does this.</p>
</blockquote>
<h2 id="adding-menus"><a class="header" href="#adding-menus">Adding Menus</a></h2>
<p>We now have a menubar, but that's pretty useless without some menus to go in it.
So again, we'll create a menu widget for each menu, each one a child of the
menubar. We'll then add them all to the menubar.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let menu_file = menubar.add_menu(())?;
let menu_edit = menubar.add_menu(())?;
menubar.add_cascade( -menu(menu_file) -label(&quot;File&quot;) )?;
menubar.add_cascade( -menu(menu_edit) -label(&quot;Edit&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The <code>add_cascade</code> method adds a menu item, which itself is a menu (a submenu).</p>
</blockquote>
<h2 id="adding-menu-items"><a class="header" href="#adding-menu-items">Adding Menu Items</a></h2>
<p>Now that we have a couple of menus in our menubar, we can add a few items to
each menu.</p>
<h3 id="command-items"><a class="header" href="#command-items">Command Items</a></h3>
<p>Regular menu items are called <code>command</code> items in Tk. We'll see some other types
of menu items shortly. Notice that menu items are part of the menu itself; we
don't have to create a separate menu widget for each one (submenus being the
exception).</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menu_file.add_command( -label(&quot;New&quot;)     -command(&quot;newFile&quot;)   )?;
menu_file.add_command( -label(&quot;Open...&quot;) -command(&quot;openFile&quot;)  )?;
menu_file.add_command( -label(&quot;Close&quot;)   -command(&quot;closeFile&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>On macOS, the ellipsis (&quot;...&quot;) is actually a special character, more tightly
spaced than three periods in a row. Tk takes care of substituting this character
for you automatically.</p>
</blockquote>
<p>Each menu item has associated with it several configuration options, analogous
to widget configuration options. Each type of menu item has a different set of
available options. Cascade menu items have a <code>menu</code> option used to specify the
submenu, command menu items have a <code>command</code> option to specify the command to
invoke when the item is chosen. Both have a <code>label</code> option to specify the text
to display for the item.</p>
<h3 id="submenus"><a class="header" href="#submenus">Submenus</a></h3>
<p>We've already seen <code>cascade</code> menu items used to add a menu to a menubar. Not
surprisingly, if you want to add a submenu to an existing menu, you also use a
<code>cascade</code> menu item in exactly the same way. You might use this to build a
&quot;recent files&quot; submenu, for example.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let menu_recent = menu_file.add_menu(())?;
menu_file.add_cascade( -menu(menu_recent) -label(&quot;Open Recent&quot;) )?;
for f in recent_files {
    let f = PathBuf::from(f);
    if let Some( file_name ) = f.file_name() {
        menu_recent.add_command(
            -label( file_name.to_str() )
            -command(( &quot;openFile&quot;, f ))
        )?;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="separators"><a class="header" href="#separators">Separators</a></h3>
<p>A third type of menu item is the <code>separator</code>, which produces the dividing line
you often see between different menu items.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menu_file.add_separator(())?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="checkbutton-and-radiobutton-items"><a class="header" href="#checkbutton-and-radiobutton-items">Checkbutton and Radiobutton Items</a></h3>
<p>Finally, there are also <code>checkbutton</code> and <code>radiobutton</code> menu items that behave
analogously to checkbutton and radiobutton widgets. These menu items have a
variable associated with them. Depending on its value, an indicator (i.e.,
checkmark or selected radiobutton) may be shown next to its label.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menu_file.add_checkbutton( -label(&quot;Check&quot;) -variable(&quot;check&quot;) -onvalue(1) -offvalue(0) )?;
menu_file.add_radiobutton( -label(&quot;One&quot;)   -variable(&quot;radio&quot;) -value(1) )?;
menu_file.add_radiobutton( -label(&quot;Two&quot;)   -variable(&quot;radio&quot;) -value(2) )?;
<span class="boring">}
</span></code></pre></pre>
<p>When a user selects a checkbutton item that is not already checked, it sets the
associated variable to the value in <code>onvalue</code>. Selecting an item that is already
checked sets it to the value in <code>offvalue</code>. Selecting a radiobutton item sets
the associated variable to the value in <code>value</code>. Both types of items also react
to any changes you make to the associated variable.</p>
<p>Like command items, checkbutton and radiobutton menu items support a <code>command</code>
configuration option that is invoked when the menu item is chosen. The
associated variable and the menu item's state are updated before the callback is
invoked.</p>
<blockquote>
<p>Radiobutton menu items are not part of the Windows or macOS human interface
guidelines. On those platforms, the item's indicator is a checkmark, as it would
be for a checkbutton item. The semantics still work. It's a good way to select
between multiple items since it will show one of them selected (checked).</p>
</blockquote>
<h2 id="manipulating-menu-items"><a class="header" href="#manipulating-menu-items">Manipulating Menu Items</a></h2>
<p>As well as adding items to the end of menus, you can also insert them in the
middle of menus via the <code>insert_{type}( index, opts )</code> method; here index is the
position (0..n-1) of the item you want to insert before. You can also delete one
or more menu items susing the <code>delete( index )</code> or <code>delete_range( index )</code>
methods.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menu_recent.delete_range( 0.. )?;
<span class="boring">}
</span></code></pre></pre>
<p>Like most everything in Tk, you can look at or change the value of an item's
options at any time. Items are referred to via an index. Usually, this is a
number (0..n-1) indicating the item's position in the menu. You can also specify
the label of the menu item (or, in fact, a &quot;glob-style&quot; pattern to match against
the item's label).</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!( &quot;{}&quot;, menu_file.entrycget( 0, label )? ); // get label of top entry in menu
println!( &quot;{}&quot;, menu_file.entryconfigure_options(0)? ); // show all options for an item
<span class="boring">}
</span></code></pre></pre>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>You can disable a menu item so that users cannot select it. This can be done via
the <code>state</code> option, setting it to the value <code>disabled</code>. Use a value of <code>normal</code>
to re-enable the item.</p>
<p>Menus should always reflect the current state of your application. If a menu
item is not presently relevant (e.g., the &quot;Copy&quot; item is only applicable if
something in your application is selected), you should disable it. When your
application state changes so that the item is applicable, make sure to enable
it.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menu_file.entryconfigure( menu::Index::pattern(&quot;Close&quot;) -state(&quot;disabled&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Sometimes you may have menu items whose name changes in response to application
state changes, rather than the menu item being disabled. For example, A web
browser might have a menu item that changes between &quot;Show Bookmarks&quot; and &quot;Hide
Bookmarks&quot; as a bookmarks pane is hidden or displayed.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bookmarks.entryconfigure( 3, -label(&quot;Hide Bookmarks&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>As your program grows complex, it's easy to miss enabling or disabling some
items. One strategy is to centralize all the menu state changes in one routine.
Whenever there is a state change in your application, it should call this
routine. It will examine the current state and update menus accordingly. The
same code can also handle toolbars, status bars, or other user interface
components.</p>
</blockquote>
<h3 id="accelerator-keys"><a class="header" href="#accelerator-keys">Accelerator Keys</a></h3>
<p>The <code>accelerator</code> option is used to indicate a keyboard equivalent that
corresponds to a menu item. This does not actually create the accelerator, but
only displays it next to the menu item. You still need to create an event
binding for the accelerator yourself.</p>
<blockquote>
<p>Remember that event bindings can be set on individual widgets, all widgets of
a certain type, the toplevel window containing the widget you're interested in,
or the application as a whole. As menu bars are associated with individual
windows, the event bindings you create will usually be on the toplevel window
the menu is associated with.</p>
</blockquote>
<p>Accelerators are very platform-specific, not only in terms of which keys are
used for what operation, but what modifier keys are used for menu accelerators
(e.g., on macOS, it is the &quot;Command&quot; key, on Windows and X11, it is usually the
&quot;Control&quot; key). Examples of valid accelerator options are <code>Command-N</code>,
<code>Shift+Ctrl+X</code>, and <code>Command-Option-B</code>. Commonly used modifiers include
<code>Control</code>, <code>Ctrl</code>, <code>Option</code>, <code>Opt</code>, <code>Alt</code>, <code>Shift</code>, &quot;<code>Command</code>, <code>Cmd</code>, and
<code>Meta</code>.</p>
<blockquote>
<p>On macOS, modifier names are automatically mapped to the different modifier
icons that appear in menus, i.e., <code>Shift</code>  , <code>Command</code>  , <code>Control</code>  , and
<code>Option</code>  .</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>edit.entryconfigure( menu::Index::pattern(&quot;Paste&quot;), -accelerator(&quot;Command+V&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="underline"><a class="header" href="#underline">Underline</a></h3>
<p>All platforms support keyboard traversal of the menubar via the arrow keys. On
Windows and X11, you can also use other keys to jump to particular menus or menu
items. The keys that trigger these jumps are indicated by an underlined letter
in the menu item's label. To add one of these to a menu item, use the
<code>underline</code> configuration option for the item. Its value should be the index of
the character you'd like underlined (from 0 to the length of the string - 1).
Unlike with accelerator keys, the menu will watch for the keystroke, so no
separate event binding is needed.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menubar.add_command( -label(&quot;Path Browser&quot;) -underline(5) )?; // underline &quot;B&quot;
<span class="boring">}
</span></code></pre></pre>
<h3 id="images"><a class="header" href="#images">Images</a></h3>
<p>It is also possible to use images in menu items, either beside the menu item's
label, or replacing it altogether. To do this, use the <code>image</code> and <code>compound</code>
options, which work just like in label widgets. The value for <code>image</code> must be a
Tk image object, while <code>compound</code> can have the values <code>bottom</code>, <code>center</code>,
<code>left</code>, <code>right</code>, <code>top</code>, or <code>none</code>.</p>
<h2 id="menu-virtual-events"><a class="header" href="#menu-virtual-events">Menu Virtual Events</a></h2>
<p>Platform conventions for menus suggest standard menus and items that should be
available in most applications. For example, most applications have an &quot;Edit&quot;
menu, with menu items for &quot;Copy,&quot; &quot;Paste,&quot; etc. Tk widgets like entry or text
will react appropriately when those menu items are chosen. But if you're
building your own menus, how do you make that work? What <code>command</code> would you
assign to a &quot;Copy&quot; menu item?</p>
<p>Tk handles this with virtual events. As you'll recall from the Tk Concepts
chapter, these are high-level application events, as opposed to low-level
operating system events. Tk's widgets will watch for specific events. When you
build your menus, you can generate those events rather than directly invoking a
callback function. Your application can create event bindings to watch for those
events too.</p>
<blockquote>
<p>Some developers create virtual events for every item in their menus. They
generate those events instead of calling routines in their own code directly.
It's one way of splitting off your user interface code from the rest of your
application. Remember that even if you do this, you'll still need code that
enables and disables menu items, adjusts their labels, etc. in response to
application state changes.</p>
</blockquote>
<p>Here's a minimal example showing how we'd add two items to an &quot;Edit&quot; menu, the
standard &quot;Paste&quot; item, and an application-specific &quot;Find...&quot; item that will open
a dialog to find or search for something. We'll include an entry widget so that
we can check that &quot;Paste&quot; works.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _e = root.add_ttk_entry(())?;
let m = root.add_menu(())?;
let m_edit = m.add_menu( &quot;edit&quot; )?;
m.add_cascade( -menu(m_edit) -label(&quot;Edit&quot;) )?;
m_edit.add_command( -label(&quot;Paste&quot;)
    -command( tclosure!( tk, move || -&gt; TkResult&lt;()&gt; {
        Ok( tk.focus()?.event_generate( event::virtual_event(&quot;Paste&quot;), () )? )})))?;
m_edit.add_command( -label(&quot;Find...&quot;)
    -command( tclosure!( tk, move || -&gt; TkResult&lt;()&gt; {
        Ok( root.event_generate( event::virtual_event(&quot;OpenFindDialog&quot;), () )? )})))?;
root.configure( -menu(m) )?;

root.bind( event::virtual_event(&quot;OpenFindDialog&quot;), tclosure!( tk, move || -&gt; TkResult&lt;String&gt; {
    Ok( tk.message_box( -message(&quot;I hope you find what you're looking for!&quot;) )? )
}))?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>When you generate a virtual event, you need to specify the widget that the
event should be sent to. We want the &quot;Paste&quot; event to be sent to the widget with
the keyboard focus (usually indicated by a focus ring). You can determine which
widget has the keyboard focus using the <code>focus</code> command. Try it out, choosing
the Paste item when the window is first opened (when there's no focus) and after
clicking on the entry (making it the focus). Notice the entry handles the
<code>event::virtual_event(&quot;Paste&quot;)</code> itself. There's no need for us to create an
event binding.</p>
</blockquote>
<blockquote>
<p>The <code>event::virtual_event(&quot;OpenFindDialog&quot;)</code> event is sent to the root window,
which is where we create an event binding. If we had multiple toplevel windows,
we'd send it to a specific window.</p>
</blockquote>
<p>Tk predefines the following virtual events:</p>
<ul>
<li><code>event::virtual_event(&quot;Clear&quot;)</code></li>
<li><code>event::virtual_event(&quot;Copy&quot;)</code></li>
<li><code>event::virtual_event(&quot;Cut&quot;)</code></li>
<li><code>event::virtual_event(&quot;Paste&quot;)</code></li>
<li><code>event::virtual_event(&quot;PasteSelection&quot;)</code></li>
<li><code>event::virtual_event(&quot;PrevWindow&quot;)</code></li>
<li><code>event::virtual_event(&quot;Redo&quot;)</code></li>
<li><code>event::virtual_event(&quot;Undo&quot;)</code>.</li>
</ul>
<p>For additional information, see the <code>event</code> mod.</p>
<h2 id="construct-all-menus-in-one-statement"><a class="header" href="#construct-all-menus-in-one-statement">Construct all menus in one statement</a></h2>
<p>The tk crate provides <code>add_menus()</code>, a convenient API to construct all menus in
one place:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let win = root.add_toplevel(())?;
let created_widgets = win.add_menus( &quot;menubar&quot;
    -menu::cascade( &quot;file&quot; -label(&quot;File&quot;)
        -menu::command( -label(&quot;New&quot;)       -command(&quot;newFile&quot;) )
        -menu::command( -label(&quot;Open...&quot;)   -command(&quot;openFile&quot;) )
        -menu::command( -label(&quot;Close&quot;)     -command(&quot;closeFile&quot;) )
        -menu::cascade( &quot;recent&quot; -label(&quot;Open Recent&quot;) )
        -menu::separator( no_arg() )
        -menu::checkbutton( -label(&quot;Check&quot;) -variable(&quot;check&quot;) -onvalue(1) -offvalue(0) )
        -menu::radiobutton( -label(&quot;One&quot;)   -variable(&quot;radio&quot;) -value(1) )
        -menu::radiobutton( -label(&quot;Two&quot;)   -variable(&quot;radio&quot;) -value(2) )
    )
)?;
<span class="boring">}
</span></code></pre></pre>
<p>See <code>add_menus</code> example for more.</p>
<h2 id="run-example-12"><a class="header" href="#run-example-12">Run Example</a></h2>
<p><code>cargo run --example menu</code></p>
<p><code>cargo run --example add_menus</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-menus"><a class="header" href="#platform-menus">Platform Menus</a></h1>
<p>Each platform has a few menus in every menubar that are handled specially by Tk.</p>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<p>You've probably noticed that Tk on macOS supplies its own default menubar. It
includes a menu named after the program being run (in this case, your
programming language's shell, e.g., &quot;Wish&quot;, &quot;Python&quot;, etc.), a File menu, and
standard Edit, Windows, and Help menus, all stocked with various menu items.</p>
<p>You can override this menubar in your own program, but to get the results you
want, you'll need to follow some particular steps (in some cases, in a
particular order).</p>
<blockquote>
<p>Starting at Tk 8.5.13, the handling of special menus on macOS changed due to
the underlying Tk code migrating from the obsolete Carbon API to Cocoa. If
you're seeing duplicate menu names, missing items, things you didn't put there,
etc., review this section carefully.</p>
</blockquote>
<p>The first thing to know is that if you don't specify a menubar for a window (or
its parent window, e.g., the root window), you'll end up with the default
menubar Tk supplies, which unless you're just mucking around on your own, is
almost certainly not what you want.</p>
<h3 id="the-application-menu"><a class="header" href="#the-application-menu">The Application Menu</a></h3>
<p>Every menubar starts with the system-wide apple icon menu. To the right of that
is a menu for the frontmost application. It is always named after the binary
being run. If you do supply a menubar, at the time the menubar is attached to
the window, if there is not a specially named <code>.apple</code> menu (see below), Tk will
provide its default application menu. It will contain an &quot;About Tcl &amp; Tk&quot; item,
followed by the standard menu items: preferences, the services submenu,
hide/show items, and quit. Again, you don't want this.</p>
<p>If you supply your own <code>.apple</code> menu, when the menubar is attached to the
window, Tk will add the standard items (preferences and onward) onto the end of
any items you have added. Perfect! Items you add after the menubar is attached
to the window will appear after the quit item, which, again, you don't want.</p>
<blockquote>
<p>The application menu, which we're dealing with here, is distinct from the
apple menu (the one with the apple icon, just to the left of the application
menu). Despite that, we really mean the application menu, even though Tk still
refer to it as the &quot;apple&quot; menu. This is a holdover from pre-OS X days when
these sorts of items did go in the actual apple menu, and there was no separate
application menu.</p>
</blockquote>
<p>So, in other words, in your program, make sure you:</p>
<ol>
<li>
<p>Create a menubar for each window or the root window. Do not attach the
menubar to the window yet!</p>
</li>
<li>
<p>Add a menu to the menubar named .apple. It will be used as the application
menu.</p>
</li>
<li>
<p>The menu will automatically be named the same as the application binary; if
you want to change this, rename (or make a copy of) the binary used to run your script.</p>
</li>
<li>
<p>Add the items you want to appear at the top of the application menu, i.e.,
an &quot;About yourapp&quot; item, followed by a separator.</p>
</li>
<li>
<p>After you have done all this, you can then attach the menubar to your
window via the window's menu configuration option.</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let win = root.add_toplevel(&quot;win&quot;)?;
let menubar = win.add_menu(&quot;menubar&quot;)?;
let apple = menubar.add_menu(&quot;apple&quot;)?;
menubar.add_cascade( -menu(apple) )?;
apple.add_command( -label(&quot;About My Application&quot;) )?;
apple.add_separator(())?;
win.configure( -menu(menubar) )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The pathname of the application menu must be .apple.</p>
</blockquote>
<h3 id="handling-the-preferences-menu-item"><a class="header" href="#handling-the-preferences-menu-item">Handling the Preferences Menu Item</a></h3>
<p>As you've noticed, the application menu always includes a &quot;Preferences...&quot; menu
item. If your application has a preferences dialog, this menu item should open
it. If your application has no preferences dialog, this menu item should be
disabled, which it is by default.</p>
<p>To hook up your preferences dialog, you'll need to define a Tcl procedure named
<code>::tk::mac::ShowPreferences</code>. This will be called when the Preferences menu item
is chosen; if the procedure is not defined, the menu item will be disabled.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tclosure!( tk, cmd: &quot;tk::mac::ShowPreferences&quot;, move || -&gt; TkResult&lt;()&gt; {
    // show preferences
    Ok(())
});
<span class="boring">}
</span></code></pre></pre>
<h3 id="providing-a-help-menu"><a class="header" href="#providing-a-help-menu">Providing a Help Menu</a></h3>
<p>Like the application menu, any help menu you add to your own menubar is treated
specially on macOS. As with the application menu that needed a special name
(<code>.apple</code>), the help menu must be given the name <code>.help</code>. Also, like the
application menu, the help menu should also be added before the menubar is
attached to the window.</p>
<p>The help menu will include the standard macOS search box to search help, as well
as an item named &quot;yourapp Help.&quot; As with the name of the application menu, this
comes from your program's executable and cannot be changed. Similar to how
preferences dialogs are handled, to respond to this help item, you need to
define a Tcl procedure named <code>::tk::mac::ShowHelp</code>. If this procedure is not
defined, it will not disable the menu item. Instead, it will generate an error
when the help item is chosen.</p>
<blockquote>
<p>If you don't want to include help, don't add a help menu to the menubar, and
none will be shown.</p>
</blockquote>
<blockquote>
<p>Unlike on X11 and earlier versions of Tk on macOS, the Help menu will not
automatically be put at the end of the menubar, so ensure it is the last menu
added.</p>
</blockquote>
<p>You can also add other items to the help menu. These will appear after the
application help item.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let menu_help = menubar.add_menu( &quot;help&quot; )?;
menubar.add_cascade( -menu(menu_help) -label(&quot;Help&quot;) )?;
tclosure!( tk, cmd: &quot;::tk::mac::ShowHelp&quot;, move || -&gt; TkResult&lt;()&gt; {
    // show help
    Ok(())
});
<span class="boring">}
</span></code></pre></pre>
<h3 id="other-menu-handlers"><a class="header" href="#other-menu-handlers">Other Menu Handlers</a></h3>
<p>You saw previously how handling certain standard menu items required you to
define Tcl callback procedures, e.g., <code>tk::mac::ShowPreferences</code> and
<code>tk::mac::ShowHelp</code>.</p>
<p>There are several other callbacks that you can define. For example, you might
intercept the Quit menu item, prompting users to save their changes before
quitting. Here is the complete list:</p>
<ul>
<li>
<p><code>tk::mac::ShowPreferences</code>:</p>
<p>Called when the &quot;Preferences...&quot; menu item is selected.</p>
</li>
<li>
<p><code>tk::mac::ShowHelp</code>:</p>
<p>Called to display main online help for the application.</p>
</li>
<li>
<p><code>tk::mac::Quit</code>:</p>
<p>Called when the Quit menu item is selected, when a user is trying to shut down the system etc.</p>
</li>
<li>
<p><code>tk::mac::OnHide</code>:</p>
<p>Called when your application has been hidden.</p>
</li>
<li>
<p><code>tk::mac::OnShow</code>:</p>
<p>Called when your application is shown after being hidden.</p>
</li>
<li>
<p><code>tk::mac::OpenApplication</code>:</p>
<p>Called when your application is first opened.</p>
</li>
<li>
<p><code>tk::mac::ReopenApplication</code>:</p>
<p>Called when a user &quot;reopens&quot; your already-running application (e.g. clicks on it in the Dock)</p>
</li>
<li>
<p><code>tk::mac::OpenDocument</code>:</p>
<p>Called when the Finder wants the application to open one or more documents
(e.g. that were dropped on it). The procedure is passed a list of pathnames of
files to be opened.</p>
</li>
<li>
<p><code>tk::mac::PrintDocument</code>:</p>
<p>As with OpenDocument, but the documents should be printed rather than opened.</p>
</li>
</ul>
<p>For additional information, see the <code>tk_mac</code> command reference.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>On Windows, each window has a &quot;System&quot; menu at the top left of the window frame,
with a small icon for your application. It contains items like &quot;Close&quot;,
&quot;Minimize&quot;, etc. In Tk, if you create a system menu, you can add new items that
will appear below the standard items.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menubar.add_cascade( -menu( menubar.add_menu( &quot;system&quot; )? ))?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="x11"><a class="header" href="#x11">X11</a></h2>
<p>On X11, if you create a help menu, Tk will ensure that it is always the last
menu in the menubar.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>menubar.add_cascade( -label(&quot;Help&quot;) -menu( menubar.add_menu(&quot;help&quot;)? ))?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-13"><a class="header" href="#run-example-13">Run Example</a></h2>
<p><code>cargo run --example platform_menus</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contextual-menus"><a class="header" href="#contextual-menus">Contextual Menus</a></h1>
<p>Contextual menus (&quot;popup&quot; menus) are typically invoked by a right mouse button
click on an object in the application. A menu pops up at the location of the
mouse cursor. Users can then select an items from the menu (or click outside it
to dismiss it without choosing any item).</p>
<p>To create a contextual menu, we'll use exactly the same commands we did to
create menus in the menubar. Typically, we'd create one menu with several
command items in it, and potentially some cascade menu items and their
associated menus.</p>
<p>To activate the menu, users will perform a contextual menu click. We'll have to
create an event binding to capture that click. That, however, can mean different
things on different platforms. On Windows and X11, this is the right mouse
button being clicked (the third mouse button). On macOS, this is either a click
of the left (or only) button with the control key held down or a right-click on
a multi-button mouse. Unlike Windows and X11, macOS refers to this as the second
mouse button, not the third, so that's the event we'll see in our program.</p>
<blockquote>
<p>Most earlier programs that have used popup menus assumed it was only
&quot;button 3&quot; they needed to worry about.</p>
</blockquote>
<p>Besides capturing the correct contextual menu event, we also need to capture the
mouse's location. It turns out we need to do this relative to the entire screen
(global coordinates) and not local to the window or widget you clicked on (local
coordinates). The <code>%X</code> and <code>%Y</code> substitutions in Tk's event binding system will
capture those for us.</p>
<p>The last step is simply to tell the menu to pop up at the particular location,
via the <code>post</code> method. Here's an example of the whole process, using a popup
menu on the application's main window.</p>
<pre><pre class="playground"><code class="language-rust no_run">// `cargo run --example contextual_menus`

use std::ffi::c_int;
use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let menu = root.add_menu(())?;
    for i in [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] {
        menu.add_command( -label(i) )?;
    }

    let handler = tclosure!( tk, cmd: &quot;handler&quot;, args: &quot;%X %Y&quot;,
        move |x: c_int, y: c_int| -&gt; TkResult&lt;()&gt; {
            Ok( tk.popup( menu, x, y, None )? )
        }
    );

    use event::*;
    if tk.windowing_system()? == TkWindowingSystem::Aqua {
        root.bind( button_press_2(), &amp;*handler )?;
        root.bind( control().button_press_1(), &amp;*handler )?;
    } else {
        root.bind( button_press_3(), &amp;*handler )?;
    }

    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-and-dialogs"><a class="header" href="#windows-and-dialogs">Windows and Dialogs</a></h1>
<p>Everything we've done up until now has been in a single window. In this chapter,
we'll cover how to use multiple windows, changing various attributes of windows,
and use some of the standard dialog boxes that are available in Tk.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-and-destroying-windows"><a class="header" href="#creating-and-destroying-windows">Creating and Destroying Windows</a></h1>
<p>We've seen that all Tk programs start out with a root toplevel window, and then
widgets are created as children of that root window. Creating new toplevel
windows works almost exactly the same as creating new widgets.</p>
<p>Toplevel windows are created using the <code>toplevel</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let window = parent.add_toplevel(())?;
<span class="boring">}
</span></code></pre></pre>
<p>Note: Toplevels are part of the classic Tk widgets, not the themed widgets.</p>
<p>Unlike regular widgets, we don't have to <code>grid</code> a toplevel for it to appear
onscreen. Once we've created a new toplevel, we can create other widgets as
children of that toplevel, and <code>grid</code> them inside the toplevel. The new toplevel
behaves exactly like the automatically created root window.</p>
<p>To destroy a window, use the <code>destroy</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.destroy( window )?;
<span class="boring">}
</span></code></pre></pre>
<p>Note that you can use <code>destroy</code> on any widget, not just a toplevel window. When
you destroy a window, all windows (widgets) that are children of that window are
also destroyed. Be careful! If you destroy the root window (that all other
widgets are descended from), that will terminate your application.</p>
<blockquote>
<p>In a typical document-oriented application, we want to be able to close any
windows while leaving the others open. In that case, we may want to create a new
toplevel for every window, and not put anything directly inside the root window
at all. While we can't just destroy the root window, we can remove it entirely
from the screen using its <code>withdraw</code> method, which we'll see shortly.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-behavior-and-styles"><a class="header" href="#window-behavior-and-styles">Window Behavior and Styles</a></h1>
<p>There are lots of things about how windows behave and how they look that can be
changed.</p>
<h2 id="window-title"><a class="header" href="#window-title">Window Title</a></h2>
<p>To examine or change the title of the window:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let old_title = window.wm_title()?;
window.wm_title( &quot;New title&quot; )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The &quot;wm&quot; here stands for &quot;window manager&quot; which is an X11 term used for a
program that manages all the windows onscreen, including their title bars,
frames, and so on. What we're effectively doing is asking the window manager to
change the title of this particular window for us. The same terminology has been
carried over to Tk running on macOS and Windows.</p>
</blockquote>
<h3 id="size-and-location"><a class="header" href="#size-and-location">Size and Location</a></h3>
<p>Here is an example of changing the size and position. It places the window
towards the top righthand corner of the screen:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.set_wm_geometry( TkGeometry{ w: 300, h: 200, x: -5, y: 40 })?;
<span class="boring">}
</span></code></pre></pre>
<p>You can retrieve the current geometry using <code>wm_geometry</code> method. However, if
you try it immediately after changing the geometry, you'll find it doesn't
match. Remember that all drawing effectively occurs in the background, in
response to idle times via the event loop. Until that drawing occurs, the
internal geometry of the window won't be updated. If you do want to force things
to update immediately, you can.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.update_idletasks()?;
println!( &quot;{}&quot;, window.wm_geometry()? );
<span class="boring">}
</span></code></pre></pre>
<p>We've seen that the window defaults to the size requested by the widgets that
are gridded into it. If we're creating and adding new widgets interactively in
the interpreter, or if our program adds new widgets in response to other events,
the window size adjusts. This behavior continues until either we explicitly
provide the window's geometry as above or a user resizes the window. At that
point, even if we add more widgets, the window won't change size. You'll want to
be sure you're using all of <code>grid</code>'s features (e.g., <code>sticky</code>, <code>weight</code>) to make
everything fit nicely.</p>
<h3 id="resizing-behavior"><a class="header" href="#resizing-behavior">Resizing Behavior</a></h3>
<p>By default, toplevel windows, including the root window, can be resized by
users. However, sometimes you may want to prevent users from resizing the
window. You can do this via the <code>resizable</code> method. It's first parameter
controls whether users can change the width, and the second if they can change
the height. So to disable all resizing:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.set_wm_resizable( false, false )?;
<span class="boring">}
</span></code></pre></pre>
<p>If a window is resizable, you can specify a minimum and/or maximum size that
you'd like the window's size constrained to (again, parameters are width and
height):</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.set_wm_minsize( 200, 100 )?;
window.set_wm_maxsize( 500, 500 )?;
<span class="boring">}
</span></code></pre></pre>
<p>You saw earlier how to obtain the current size of the window via its geometry.
Wondering how large it would be if you didn't specify its geometry, or a user
didn't resize it? You can retrieve the window's requested size, i.e., how much
space it requests from the geometry manager. Like with drawing, geometry
calculations are only done at idle time in the event loop, so you won't get a
useful response until the widget has appeared onscreen.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.winfo_reqwidth()?; // or reqheight
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>You can use the <code>winfo_reqwidth</code> and <code>winfo_reqheight</code> methods on any widget,
not just toplevel windows. There are other <code>winfo_*</code> methods you can call on any
widget, such as width and height, to get the actual (not requested) width and
height. For more, see the <code>winfo</code> mod.</p>
</blockquote>
<h3 id="intercepting-the-close-button"><a class="header" href="#intercepting-the-close-button">Intercepting the Close Button</a></h3>
<p>Most windows have a close button in their title bar. By default, Tk will destroy
the window if users click on that button. You can, however, provide a callback
that will be run instead. A common use is to prompt the user to save an open
file if modifications have been made.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe { window.set_wm_protocol( &quot;WM_DELETE_WINDOW&quot;, callback )?; }
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The somewhat obscurely-named <code>WM_DELETE_PROTOCOL</code> originated with X11 window
manager protocols.</p>
</blockquote>
<h3 id="transparency"><a class="header" href="#transparency">Transparency</a></h3>
<p>Windows can be made partially transparent by specifying an alpha channel,
ranging from <code>0.0</code> (fully transparent) to <code>1.0</code> (fully opqaque).</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.set_wm_attributes( -alpha(0.5) )?;
<span class="boring">}
</span></code></pre></pre>
<p>On macOS, you can additionally specify a <code>-transparent</code> attribute (using the
same mechanism as with <code>-alpha</code>), which allows you to make the background of the
window transparent, and remove the window's show. You should also set the
<code>background</code> configuration option for the window and any frames to the color
<code>ssytemTransparent</code>.</p>
<h3 id="full-screen"><a class="header" href="#full-screen">Full Screen</a></h3>
<p>You can make a window expand to take up the full screen:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.set_wm_attributes( -fullscreen(true) )?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="iconifying-and-withdrawing"><a class="header" href="#iconifying-and-withdrawing">Iconifying and Withdrawing</a></h3>
<p>On most systems, you can temporarily remove the window from the screen by
iconifying it. In Tk, whether or not a window is iconified is referred to as the
window's state. The possible states for a window include <code>normal</code> and <code>iconic</code>
(for an iconified window), and several others: <code>withdrawn</code>, <code>icon</code> or <code>zoomed</code>.</p>
<p>You can query or set the current window state directly. There are also methods
<code>iconify</code>, <code>deiconify</code>, and <code>withdraw</code>, which are shortcuts for setting the
<code>iconic</code>, <code>normal</code>, and <code>withdrawn</code> states, respectively.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_state = window.wm_state()?;
window.set_wm_state( TkState::Normal )?;
window.wm_iconify()?;
window.wm_deiconify()?;
window.wm_withdraw()?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="stacking-order"><a class="header" href="#stacking-order">Stacking Order</a></h3>
<p>Stacking order refers to the order that windows are &quot;placed&quot; on the screen, from
bottom to top. When the positions of two windows overlap each other, the one
closer to the top of the stacking order will obscure or overlap the one lower in
the stacking order.</p>
<p>You can ensure that a window is always at the top of the stacking order (or at
least above all others where this attribute isn't set):</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.set_wm_attributes( -topmost(true) )?;
<span class="boring">}
</span></code></pre></pre>
<p>You can find the current stacking order, listed from lowest to highest:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window
    .wm_stackorder()?
    .iter()
    .for_each( |widget| println!( &quot;stackorder: {}&quot;, widget.path() ));
<span class="boring">}
</span></code></pre></pre>
<p>You can also just check if one window is above or below another:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if window.wm_stackorder_isabove( &amp;other ) {}
if window.wm_stackorder_isbelow( &amp;other ) {}
<span class="boring">}
</span></code></pre></pre>
<p>You can also raise or lower windows, either to the very top (bottom) of the
stacking order, or just above (below) a designated window:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>window.raise()?;
window.raise_above( &amp;other )?;
window.lower()?;
window.lower_below( &amp;other )?;
<span class="boring">}
</span></code></pre></pre>
<p>Why do you need to pass a window to get the stacking order? Stacking order
applies not only for toplevel windows, but for any sibling widgets (those with
the same parent). If you have several widgets gridded together but overlapping,
you can raise and lower them relative to each other:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let little = root.add_ttk_label( &quot;little&quot; -text(&quot;Little&quot;) )?
    .grid( -column(0) -row(0) )?; 
root.add_ttk_label( &quot;bigger&quot; -text(&quot;Much Bigger Label&quot;) )?
    .grid( -column(0) -row(0) )?;
tk.after( 2000, (tclosure!( tk,
    move || -&gt; TkResult&lt;()&gt; { Ok( little.raise()? )}),))?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="screen-information"><a class="header" href="#screen-information">Screen Information</a></h2>
<p>We've previously used the <code>winfo</code> command to find out information about specific
widgets. It can also provide information about the entire display or screen. As
usual, see the <code>winfo</code> command reference for full details.</p>
<p>For example, you can determine the screen's color depth (how many bits per
pixel) and color model (usually <code>truecolor</code> on modern displays), it's pixel
density, and resolution.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!( &quot;color depth={} ({})&quot;, root.winfo_screendepth()?, root.winfo_screenvisual()? );
println!( &quot;pixels per inch={}&quot;, root.winfo_pixels( TkDistance::Inches(1.0) )? );
println!( &quot;width={} height={}&quot;, root.winfo_screenwidth()?, root.winfo_screenheight()? );
<span class="boring">}
</span></code></pre></pre>
<h3 id="multiple-monitors"><a class="header" href="#multiple-monitors">Multiple Monitors</a></h3>
<p>While normally you shouldn't have to pay attention to it, if you do have
multiple monitors on your system and want to customize things a bit, there are
some tools in Tk to help.</p>
<p>First, there are two ways that multiple monitors can be represented. The first
is with logically separate displays. This is often the case on X11 systems,
though it can be changed, e.g., using the <code>xrandr</code> system utility. A downside of
this model is that once a window is created on a screen, it can't be moved to a
different one. You can determine the screen that a Tk window is running on,
which looks something like <code>:0.0</code> (an X11-formatted display name).</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>root.winfo_screen()?;
<span class="boring">}
</span></code></pre></pre>
<p>When first creating a <code>toplevel</code> you can specify the screen it should be created
on using the <code>screen</code> configuration option.</p>
<blockquote>
<p>Different monitors may have different resolutions, color depths, etc. You'll
notice that all the screen information calls we just covered are methods invoked
on a specific widget. They will return information about whatever screen that
window is located on.</p>
</blockquote>
<p>Alternatively, multiple monitors can also be represented as one big virtual
display, which is the case on macOS and Windows. When you ask for information
about the screen, Tk will return information on the primary monitor. For
example, if you have two Full HD monitors side-by-side, the screen resolution
will be reported as 1920 x 1080, not 3840 x 1080. This is probably a good thing;
it means that if we're positioning or sizing windows, we don't need to worry
about multiple monitors, and everything will just show up correctly on the
primary monitor.</p>
<p>What if a user moves a window from the primary monitor to a different one? If
you ask for its position, it will be relative to the primary monitor. So in our
side-by-side FHD monitor setup, if you call the <code>winfo_x</code> method on a window
positioned near the left edge of a monitor, it might return <code>100</code> (if it's on
the primary monitor), <code>-1820</code> (if it's on a monitor to the left of the primary
monitor), or <code>2020</code> (if it's on a monitor to the right of the primary monitor).
You can still use the <code>geometry</code> method we saw a bit earlier to position the
window on a different monitor, even though the geometry specification may look a
bit odd, e.g., <code>x:-1820, y:100</code>.</p>
<p>You can find out approximately how large the entire display is, spanning
multiple monitors. To do so, check a toplevel widget's maximum size, i.e., how
large the user can resize it (you can't do this after you've already changed it,
of course). This may be a bit smaller than the full size of the display. For
example, on macOS, it will be reduced by the size of the menubar at the top of
the screen.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>root.wm_maxsize()?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-14"><a class="header" href="#run-example-14">Run Example</a></h2>
<p><code>cargo run --example window_behavior_and_styles</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dialog-windows"><a class="header" href="#dialog-windows">Dialog Windows</a></h1>
<p>Dialog boxes are a type of window used in applications to get some information
from users, inform them that some event has occurred, confirm an action, and
more. The appearance and usage of dialog boxes are usually quite specifically
detailed in a platform's style guide. Tk comes with several dialog boxes
built-in for common tasks. These help you conform to platform-specific style
guidelines.</p>
<h2 id="selecting-files-and-directories"><a class="header" href="#selecting-files-and-directories">Selecting Files and Directories</a></h2>
<p>Tk provides several dialogs to let users select files or directories. On Windows
and macOS, these invoke the underlying operating system dialogs directly. The
&quot;open&quot; variant on the dialog is used when you want users to select an existing
file (like in a <code>&quot;File | Open...&quot;</code> menu command), while the &quot;save&quot; variant is
used to choose a file to save into (usually used by the <code>&quot;File | Save As...&quot;</code>
menu command).</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let filename = tk.get_open_file()?;
let filename = tk.get_save_file()?;
let dirname  = tk.choose_directory()?;
<span class="boring">}
</span></code></pre></pre>
<p>All of these commands produce modal dialogs. This means that the commands will
not complete until a user submits the dialog. These commands return the full
pathname of the file or directory a user has chosen, or an empty string if a
user cancels out of the dialog.</p>
<table><thead><tr><th style="text-align: center">Open file dialogs</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/getopenfile_all.png" alt="Open file dialogs." /></td></tr>
</tbody></table>
<table><thead><tr><th style="text-align: center">Save file dialogs</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/getsavefile_all.png" alt="Save file dialogs." /></td></tr>
</tbody></table>
<table><thead><tr><th style="text-align: center">Choose directory dialogs</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/choosedir_all.png" alt="Choose directory dialogs." /></td></tr>
</tbody></table>
<p>Various options can be passed to these dialogs, allowing you to set the
allowable file types, initial directory, default filename, and many more. These
are detailed in the <code>getOpenFile</code> (includes <code>getSaveFile</code>) and <code>chooseDirectory</code>
reference manual pages.</p>
<h3 id="selecting-colors"><a class="header" href="#selecting-colors">Selecting Colors</a></h3>
<p>Another modal dialog lets users select a color. It will return a color value,
e.g. <code>#ff62b8</code>. The dialog takes an optional <code>initialcolor</code> option to specify an
existing color, i.e., that users might want to replace. More information is
available in the <code>chooseColor</code> reference manual pages.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.choose_color( -initialcolor(&quot;#ff0000&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<table><thead><tr><th style="text-align: center">Choose color dialogs</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/choosecolor_all.png" alt="Choose color dialogs." /></td></tr>
</tbody></table>
<h2 id="selecting-fonts"><a class="header" href="#selecting-fonts">Selecting Fonts</a></h2>
<p>Tk 8.6 added support for another system dialog: a font chooser. While the file
dialogs and color chooser were modal dialogs, that block until the dialog is
dismissed and then return a result, the font chooser doesn't work like that.</p>
<table><thead><tr><th style="text-align: center">Font chooser dialogs</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/fontchooser_all.png" alt="Font chooser dialogs." /></td></tr>
</tbody></table>
<p>While the system font dialog is modal on some platforms, e.g., Windows, that's
not the case everywhere. On macOS, the system font chooser works more like a
floating tool palette in a drawing program, remaining available to change the
font for whatever text is selected in your main application window. The Tk font
dialog API has to accommodate both models. To do so, it uses callbacks (and
virtual events) to notify your application of font changes.</p>
<p>To use the font dialog, first provide it with an initial font and a callback
which will be invoked when a font is chosen. For illustration, we'll have the
callback change the font on a label.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let l = root
    .add_ttk_label( &quot;l&quot; -text(&quot;Hello World&quot;) -font(&quot;helvetica 24&quot;) )?
    .grid( -padx(10) -pady(10) )?;
tclosure!( tk, cmd:&quot;font_changed&quot;,
    move |some_font:Obj| -&gt; TkResult&lt;()&gt; { Ok( l.configure( -font(some_font) )? )});
tk.fontchooser_configure( -font(&quot;helvetica 24&quot;) -command(&quot;font_changed&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>You can query or change the font that is (or will be) displayed in the dialog
at any time.</p>
</blockquote>
<p>Next, put the dialog onscreen via the <code>show</code> method. On platforms where the font
dialog is modal, your program will block at this point until the dialog is
dismissed. On other platforms, <code>show</code> returns immediately; the dialog remains
onscreen while your program continues. At this point, a font has not been
chosen. There's also a <code>hide</code> method to remove it from the screen (not terribly
useful when the font dialog is modal).</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.fontchooser_show()?;
tk.fontchooser_hide()?;
<span class="boring">}
</span></code></pre></pre>
<p>If the font dialog was modal, and the user chose a font, the dialog would have
invoked your callback, passing it a font specification. If they cancelled out of
the dialog, there'd be no callback. When the dialog isn't modal, and the user
chooses a font, it will invoke your callback. A
<code>event::virtual_event( &quot;TkFontchooserFontChanged&quot; )</code> virtual event is also
generated; you can retrieve the current font via the dialog's <code>font</code>
configuration option. If the font dialog is closed, a
<code>event::virtual_event( &quot;TkFontchooserVisibility&quot; )</code> is generated. You can also
find out if the font dialog is currently visible onscreen via the <code>visible</code>
configuration option (though changing it is an error; use the <code>show</code> and <code>hide</code>
methods instead).</p>
<blockquote>
<p>Because of the significant differences between them, providing a good user
experience on all platforms takes a bit of work. On platforms where the font
dialog is modal,it's likely to be invoked from a button or menu item that
says, e.g., <code>Font...</code>. On other platforms, the button or menu item should
toggle between <code>Show Fonts</code> and <code>Hide Fonts</code>.</p>
</blockquote>
<blockquote>
<p>If you have several text widgets in your application that can be given
different fonts, when one of them gains focus, it should update the font
chooser with its current font. This also means that a callback from the font
dialog may apply to a different text widget than the one you initially called
<code>show</code> from! Finally, be aware that the font chooser itself may gain the
keyboard focus on some platforms. </p>
</blockquote>
<blockquote>
<p>As of Tk 8.6.10, there are a few bugs in the font chooser on various
platforms. Here's a quick rundown including workarounds: </p>
</blockquote>
<blockquote>
<ul>
<li>on macOS, if you don't provide a font via the <code>font</code> configuration option,
your callbacks won't be invoked  always provide an initial font</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>on X11, if you don't provide values for all configuration options, those you
don't include will be reset to their default values  whenever you change any
option, change all of them, even if it's just to their current value</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>on X11, the font dialog includes an <code>Apply</code> button when you provide a
callback, but omits it when you don't (and just watch for virtual events);
however, other bugs mean those virtual events are never generated  always
provide a command callback</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>on Windows, you can also leave off the <code>Apply</code> button by not providing a
callback; while virtual events are generated on font changes, the <code>font</code>
configuration option is never updated  always provide a command callback, and
hold onto the font yourself, rather than trying to ask the font dialog for it
later</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>on Windows, a font change virtual event is not generated if you change the
<code>font</code> configuration option in your code, though it is on macOS and X11  take
any necessary actions when you change the font in your code rather than in a
virtual event handler </li>
</ul>
</blockquote>
<blockquote>
<p>Because of the differences between platforms and the various bugs, testing is
far more important when using the font chooser than the other system dialogs.</p>
</blockquote>
<h3 id="alert-and-confirmation-dialogs"><a class="header" href="#alert-and-confirmation-dialogs">Alert and Confirmation Dialogs</a></h3>
<p>Many applications use various simple modal alerts or dialogs to notify users of
an event, ask them to confirm an action, or make another similar choice via
clicking on a button. Tk provides a versatile &quot;message box&quot; that encapsulates
all these different types of dialogs.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.message_box( -message(&quot;Have a good day&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<table><thead><tr><th style="text-align: center">Simple message boxes</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/alert_all.png" alt="Simple message boxes." /></td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.message_box(
    -type_( &quot;yesno&quot; )
    -message( &quot;Are you sure you want to install SuperVirus?&quot; )
    -icon( &quot;question&quot; ) -title( &quot;Install&quot; )
)?;
<span class="boring">}
</span></code></pre></pre>
<table><thead><tr><th style="text-align: center">Example message boxes</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/messagebox_all.png" alt="Example message boxes." /></td></tr>
</tbody></table>
<p>Like the previous dialogs that we've seen, these are modal and return the result
of a user's action to the caller. The exact return value will depend on the
<code>type_</code> option passed to the command, as shown here:</p>
<p><code>ok (default)</code>:        <code>ok</code>
<code>okcancel</code>:            <code>ok</code> or <code>cancel</code>
<code>yesno</code>:               <code>yes</code> or <code>no</code>
<code>yesnocancel</code>:         <code>yes</code>, <code>no</code> or <code>cancel</code>
<code>retrycancel</code>:         <code>retry</code> or <code>cancel</code>
<code>abortretryignore</code>:    <code>abort</code>, <code>retry</code> or <code>ignore</code> </p>
<p>The full list of possible options is shown here:</p>
<p><code>type_</code>:    As described above.
<code>message</code>:  The main message displayed inside the alert.
<code>detail</code>:   A secondary message (if needed).
<code>title</code>:    Title for the dialog window. Not used on macOS.
<code>icon</code>:     Icon, one of info (default), error, question or warning.
<code>default</code>:  Default button, e.g. ok or cancel for a okcancel dialog.
<code>parent</code>:   Window of your application this dialog is being posted for.</p>
<p>Additional details can be found in the reference manual.</p>
<h2 id="run-example-15"><a class="header" href="#run-example-15">Run Example</a></h2>
<p><code>cargo run --example dialog_windows</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organizing-complex-interfaces"><a class="header" href="#organizing-complex-interfaces">Organizing Complex Interfaces</a></h1>
<p>If you have a complex user interface, you'll need to find ways to organize it
that don't overwhelm your users. There are several different approaches to doing
this. Both general-purpose and platform-specific human interface guidelines are
good resources when designing your user interface.</p>
<p>When we talk about complexity in this chapter, we don't mean the underlying
technical complexity of how the program is implemented. Instead, we mean how
it's presented to users. A user interface can be pulled together from many
different modules, built from hundreds of widgets combined in a deeply nested
hierarchy, but that doesn't mean users need to perceive it as complex.</p>
<h2 id="multiple-windows"><a class="header" href="#multiple-windows">Multiple windows</a></h2>
<p>One benefit of using multiple windows in an application can be to simplify the
user interface. Done well, it can require users to focus only on the contents of
one window at a time to complete a task. Forcing them to focus on or switch
between several windows can also have the opposite effect. Similarly, showing
only the widgets relevant to the current task (i.e., via <code>grid</code>) can help
simplify the user interface.</p>
<h2 id="white-space"><a class="header" href="#white-space">White space</a></h2>
<p>If you do need to display a large number of widgets onscreen at the same time,
think about how to organize them visually. We've seen how <code>grid</code> makes it easy
to align widgets with each other. White space is another useful aid. Place
related widgets close to each other (possibly with an explanatory label
immediately above) and separate them from other widgets by white space. This
helps users organize the user interface in their own minds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="separator"><a class="header" href="#separator">Separator</a></h1>
<p>A second approach to grouping widgets in one display is to place a thin
horizontal or vertical rule between groups of widgets; often, this can be more
space-efficient than using white space, which may be relevant for a tight
display. Tk provides a simple <em>separator</em> widget for this purpose.</p>
<table><thead><tr><th style="text-align: center">Separator widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_separator_all.png" alt="Separator widgets." /></td></tr>
</tbody></table>
<p>Separators are created using the <code>add_ttk_separator</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_separator( &quot;s&quot; -orient(&quot;horizontal&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>orient</code> option may be specified as either <code>horizontal</code> or <code>vertical</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="label-frames"><a class="header" href="#label-frames">Label Frames</a></h1>
<p>A <em>labelframe</em> widget, also commonly known as a group box, provides another way
to group related components. It acts like a normal <code>ttk_frame</code>, in that it
contains other widgets that you <code>grid</code> inside it. However, it is visually set
off from the rest of the user interface. You can optionally provide a text label
to be displayed outside the labelframe.</p>
<table><thead><tr><th style="text-align: center">Labelframe widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_labelframe_all.png" alt="Labelframe widgets." /></td></tr>
</tbody></table>
<p>Labelframes are created using the <code>add_ttk_labelframe</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_ttk_labelframe( &quot;lf&quot; -text(&quot;Label&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paned-windows"><a class="header" href="#paned-windows">Paned Windows</a></h1>
<p>A <em>panedwindow</em> widget lets you stack two or more resizable widgets above and
below each other (or to the left and right). Users can adjust the relative
heights (or widths) of each pane by dragging a sash located between them.
Typically the widgets you're adding to a panedwindow will be frames containing
many other widgets.</p>
<table><thead><tr><th style="text-align: center">Panedwindow widgets(shown here managing several labelframes)</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_panedwindow_all.png" alt="Panedwindow widgets." /></td></tr>
</tbody></table>
<p>Panedwindows are created using the <code>add_ttk_panedwindow</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example paned_windows

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let p = root.add_ttk_panedwindow( -orient(&quot;vertical&quot;) )?.pack(())?;
    
    // two panes, each of which would get widgets gridded into it:
    let f1 = p.add_ttk_labelframe( -text(&quot;Pane1&quot;) -width(100) -height(100) )?;
    let f2 = p.add_ttk_labelframe( -text(&quot;Pane2&quot;) -width(100) -height(100) )?;
    p.add( &amp;f1, () )?;
    p.add( &amp;f2, () )?;

    Ok( main_loop() )
}
</code></pre></pre>
<p>A panedwindow is either <code>vertical</code> (its panes are stacked vertically on top of
each other) or horizontal. Importantly, each pane you add to the panedwindow
must be a direct child of the panedwindow itself.</p>
<p>Calling the <code>add</code> method adds a new pane at the end of the list of panes. The
<code>insert( position, subwindow, options )</code> method allows you to place the pane at
the given position in the list of panes (0..n-1). If the pane is already managed
by the panedwindow, it will be moved to the new position. You can use the
<code>forget( subwindow )</code> to remove a pane from the panedwindow (you can also pass a
position instead of a subwindow).</p>
<p>You can assign relative weights to each pane so that if the overall panedwindow
resizes, certain panes will be allocated more space than others. As well, you
can adjust the position of each sash between items in the panedwindow. See the
command reference for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notebook"><a class="header" href="#notebook">Notebook</a></h1>
<p>A <em>notebook</em> widget uses the metaphor of a tabbed notebook to let users switch
between one of several pages, using an index tab. Unlike with paned windows,
users only see a single page (akin to a pane) at a time.</p>
<table><thead><tr><th style="text-align: center">Notebook widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_notebook_all.png" alt="Notebook widgets." /></td></tr>
</tbody></table>
<p>Notebooks are created using the <code>add_ttk_notebook</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example notebook

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let n = root.add_ttk_notebook(())?.pack(())?;
    let f1 = n.add_ttk_frame(())?; // first page, which would get widgets gridded into it 
    let f2 = n.add_ttk_frame(())?; // second page
    n.add( &amp;f1, -text(&quot;One&quot;) )?;
    n.add( &amp;f2, -text(&quot;Two&quot;) )?;

    Ok( main_loop() )
}
</code></pre></pre>
<p>The operations on tabbed notebooks are similar to those on panedwindows. Each
page is typically a frame and again must be a direct child (subwindow) of the
notebook itself. A new page and its associated tab are added after the last tab
with the <code>add( subwindow, options )</code> method. The <code>text</code> tab option sets the
label on the tab; also useful is the <code>state</code> tab option, which can have the
value <code>normal</code>, <code>disabled</code> (not selectable), or <code>hidden</code>. </p>
<p>To insert a tab at somewhere other than the end of the list, use the
<code>insert( &amp;self, position, subwindow options )</code>, and to remove a given tab, use
the <code>forget</code> method, passing it either the position (0..n-1) or the tab's
subwindow. You can retrieve the list of all subwindows contained in the notebook
via the <code>tabs</code> method.</p>
<p>To retrieve the selected subwindow, call the <code>select</code> method, and change the
selected tab by passing it either the tab's position or the subwindow itself as
a parameter.</p>
<p>To change a tab option (like the text label on the tab or its state), you can
use the <code>tab( &amp;self, tabid, options )</code> method (where <code>tabid</code> is again the tab's
position or subwindow); use <code>tabs( &amp;self )</code> to return the current value of the
option.</p>
<p>Notebook widgets generate a <code>event::virtual_event( &quot;NotebookTabChanged&quot; )</code>
whenever a new tab is selected.</p>
<p>Again, there are a variety of less frequently used options and commands detailed
in the command reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonts-colors-images"><a class="header" href="#fonts-colors-images">Fonts, Colors, Images</a></h1>
<p>This chapter describes how Tk handles fonts, colors, and images. We've touched
on all of these before, but here we'll provide a more in-depth treatment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonts"><a class="header" href="#fonts">Fonts</a></h1>
<p>Tk's label widget allows you to change the font used to display text via the
<code>font</code> configuration option. The canvas and text widgets, covered in the
following chapters, also allow you to specify fonts. Other themed widgets that
display text may not have a <code>font</code> configuration option, but their fonts can be
changed using styles.</p>
<blockquote>
<p>We'll cover styles in detail later. In essence, they replace the old way of
tweaking multiple configuration options on individual widgets. Instead, fonts,
colors, and other settings that control appearance can be bundled together in a
style. That style can then be applied to multiple widgets. It's akin to the
difference between hardcoding display-oriented markup inside HTML pages vs.
using CSS to keep display-specific information separate.</p>
</blockquote>
<p>As with many things in Tk, the default fonts are usually a good choice. If you
need to make changes, this section shows you the best way to do so, using named
fonts. Tk includes named fonts suitable for use in all different components of
your user interface. They take into account the conventions of the specific
platform you're running on. You can also specify your own fonts when you need
additional flexibility.</p>
<p>The font command reference provides full details on specifying fonts, as well as
other font-related operations.</p>
<blockquote>
<p>Many older Tk programs hardcoded fonts, using either the &quot;family size style&quot;
format we'll see below, X11 font names, or the older and more arcane X11 font
specification strings. These applications looked increasingly dated as platforms
evolved. Worse, fonts were often specified on a per-widget basis, leaving font
decisions spread throughout the code. Named fonts, particularly the standard
fonts that Tk provides, are a far better solution. Reviewing and updating font
decisions is an easy and important change to make in any existing applications.</p>
</blockquote>
<h2 id="standard-fonts"><a class="header" href="#standard-fonts">Standard Fonts</a></h2>
<p>Each platform defines specific fonts that should be used for standard user
interface elements. Tk encapsulates many of these decisions into a standard set
of named fonts. They are available on all platforms, though the exact font used
will vary. This helps abstract away platform differences. Of course, the
standard widgets use these named fonts. The predefined fonts are:</p>
<p><code>TkDefaultFont</code>     : Default for items not otherwise specified.</p>
<p><code>TkTextFont</code>        : Used for entry widgets, listboxes, etc.</p>
<p><code>TkFixedFont</code>       : A standard fixed-width font.</p>
<p><code>TkMenuFont</code>        : The font used for menu items.</p>
<p><code>TkHeadingFont</code>     : Font for column headings in lists and tables.</p>
<p><code>TkCaptionFont</code>     : A font for window and dialog caption bars.</p>
<p><code>TkSmallCaptionFont</code>: A smaller caption font for tool dialogs.</p>
<p><code>TkIconFont</code>        : A font for icon captions.</p>
<p><code>TkTooltipFont</code>     : A font for tooltips. </p>
<h2 id="platform-specific-fonts"><a class="header" href="#platform-specific-fonts">Platform-Specific Fonts</a></h2>
<p>Tk provides additional named fonts to help you comply with less common
situations on specific platforms. Individual platform guidelines detail how and
where these fonts should be used. These fonts are only defined on specific
platforms. You'll need to take that into account if your application is portable
across platforms.</p>
<p>Tk on X11 recognizes any valid X11 font name (see, e.g., the <code>xlsfonts</code>
command). However, these can vary with the operating system, installed software,
and the configuration of the individual machine. There is no guarantee that a
font available on your X11 system has been installed on any other X11 system.</p>
<p>On Windows, Tk provides named fonts for all the fonts that can be set in the
&quot;Display&quot; Control Panel. It recognizes the following font names: <code>system</code>,
<code>ansi</code>, <code>device</code>, <code>systemfixed</code>, <code>ansifixed</code>, and <code>oemfixed</code>.</p>
<p>On macOS, the Apple Human Interface Guidelines (HIG) specifies a number of
additional fonts. Tk recognizes the following names: <code>systemSystemFont</code>,
<code>systemSmallSystemFont</code>, <code>systemApplicationFont</code>, <code>systemViewsFont</code>,
<code>systemMenuItemFont</code>, <code>systemMenuItemCmdKeyFont</code>, <code>systemPushButtonFont</code>,
<code>systemAlertHeaderFont</code>, <code>systemMiniSystemFont</code>,
<code>systemDetailEmphasizedSystemFont</code>, <code>systemEmphasizedSystemFont</code>,
<code>systemSmallEmphasizedSystemFont</code>, <code>systemLabelFont</code>, <code>systemMenuTitleFont</code>,
<code>systemMenuItemMarkFont</code>, <code>systemWindowTitleFont</code>,
<code>systemUtilityWindowTitleFont</code>, <code>systemToolbarFont</code>, and
<code>systemDetailSystemFont</code>.</p>
<h2 id="working-with-named-fonts"><a class="header" href="#working-with-named-fonts">Working with Named Fonts</a></h2>
<p>Tk provides several operations that help you work with named fonts. You can
start by getting a list of all the currently defined named fonts.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!( &quot;{:#?}&quot;, tk.font_names()? );
<span class="boring">}
</span></code></pre></pre>
<p>You can find out the actual system font represented by an abstract named font.
This consists of the <code>family</code> (e.g., <code>Times</code> or <code>Helvetica</code>), the <code>size</code> (in
points if positive, in pixels if negative), the <code>weight</code> (<code>normal</code> or <code>bold</code>),
the <code>slant</code> (<code>roman</code> or <code>italic</code>), and boolean attributes for <code>underline</code> and
<code>overstrike</code>. You can find out the font's <code>metrics</code> (how tall characters in the
font can be and whether it is monospaced), and even <code>measure</code> how many pixels
wide a piece of text rendered in the font would be.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!( &quot;{:#?}&quot;, tk.font_actual_get_all( Font::&lt;()&gt;::Name( &quot;TkTextFont&quot; ))? );
// e.g. -family .AppleSystemUIFont -size 13 -weight normal -slant roman -underline 0 -overstrike 0

println!( &quot;{:#?}&quot;, tk.font_metrics_get_all( Font::&lt;()&gt;::Name( &quot;TkTextFont&quot; ))? );
// e.g. -ascent 13 -descent 3 -linespace 16 -fixed 0

println!( &quot;{:#?}&quot;, tk.font_measure( Font::&lt;()&gt;::Name( &quot;TkTextFont&quot; ), &quot;The quick brown fox&quot; )? );
// e.g. 124
}
<span class="boring">}
</span></code></pre></pre>
<p>You can also create your own fonts, which can then be used exactly like the
predefined ones. To do so, choose a name for the font and specify its font
attributes as above.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tk.font_create( &quot;AppHighlightFont&quot;, -family(&quot;Helvetica&quot;) -size(12) -weight(&quot;bold&quot;) )?;
root.add_ttk_label( &quot;l&quot; -text(&quot;Attention!&quot;) -font(&quot;AppHighlightFont&quot;) )?
    .grid(())?;
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>family</code> attribute specifies the font family. Tk ensures the names
<code>Courier</code>, <code>Times</code>, and <code>Helvetica</code> are available, though they may be mapped to
an appropriate monospaced, serif, or sans-serif font). Other fonts installed on
your system can be used, but the usual caveats about portability apply. You can
get the names of all available families with: </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!( &quot;{:#?}&quot;, tk.font_families()? );
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-16"><a class="header" href="#run-example-16">Run Example</a></h2>
<p><code>cargo run --example fonts</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colors"><a class="header" href="#colors">Colors</a></h1>
<p>As with fonts, there are various ways to specify colors. Full details can be
found in the
<a href="https://tcl.tk/man/tcl8.6/TkCmd/colors.htm">colors command reference</a>.</p>
<p>In general, Tk widgets default to the right colors for most situations. If you'd
like to change colors, you'll do so via widget-specific commands or options,
e.g., the label's <code>foreground</code> and <code>background</code> configuration options. For most
themed widgets, color changes are specified through styles, not by changing the
widget directly.</p>
<p>You can specify colors via RGB, as you would in HTML or CSS, e.g. <code>#3FF</code> or
<code>#FF016A</code>. Tk also recognizes names such as <code>red</code>, <code>black</code>, <code>grey50</code>,
<code>light blue</code>, etc.</p>
<blockquote>
<p>Tk recognizes the standard names for colors defined by X11. You can find a
complete list in the command reference (noted above).</p>
</blockquote>
<p>As with fonts, both macOS and Windows specify many system-specific abstract
color names (again, see the reference). The actual color these correspond to may
depend on system settings and can change over time, e.g., dark mode, text
highlight colors, default backgrounds.</p>
<p>If needed, you can find the RGB values (each between 0 and 65535) for a color
using the <code>winfo_rgb</code> method on any widget.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example colors

use tk::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    println!( &quot;{:?}&quot;, root.winfo_rgb( TkColor::Name(&quot;red&quot;) )? );

    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="images-1"><a class="header" href="#images-1">Images</a></h1>
<p>We've seen the basics of using images already, displaying them in labels or
buttons, for example. We create an image object, usually from a file on disk.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example images

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let label_image = root
        .add_ttk_label( &quot;label_image&quot; -text(&quot;Full name&quot;) )?
        .pack(())?;

    let img = tk.image_create_photo( -file(&quot;book/src/images/tcl.gif&quot;) )?;
    label_image.configure( -image(img) )?;

    root.winfo_rgb( TkColor::Name(&quot;red&quot;) )?;
    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas"><a class="header" href="#canvas">Canvas</a></h1>
<p>A <em>canvas</em> widget manages a 2D collection of graphical objects  lines, circles,
text, images, other widgets, and more. Tk's canvas is an incredibly powerful and
flexible widget and truly one of Tk's highlights. It is suitable for a wide
range of uses, including drawing or diagramming, CAD tools, displaying or
monitoring simulations or actual equipment, and building more complex widgets
out of simpler ones.</p>
<p>Note: Canvas widgets are part of the classic Tk widgets, not the themed Tk
widgets.</p>
<table><thead><tr><th style="text-align: center">Canvas widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_canvas_all.png" alt="Canvas widgets." /></td></tr>
</tbody></table>
<p>Canvas widgets are created using the <code>canvas</code> command:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_canvas( &quot;canvas&quot; -width(500) -height(400) -background(&quot;gray75&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>You'll often provide a width and height, either in pixels or any of the other
standard distance units. As always, you can ask the geometry manager to expand
it to fill the available space in the window. You might provide a default
background color for the canvas, specifying colors as you learned about in the
last chapter. Canvas widgets also support other appearance options like <code>relief</code>
and <code>borderwidth</code> that we've used before.</p>
<p>Canvas widgets have a tremendous number of features, and we won't cover
everything here. Instead, we'll start with a simple example, a freehand
sketching tool, and incrementally add new pieces, each showing another feature
of canvas widgets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-items"><a class="header" href="#creating-items">Creating Items</a></h1>
<p>When you create a new canvas widget, it is essentially a large rectangle with
nothing on it, truly a blank canvas, in other words. To do anything useful with
it, you'll need to add items to it. There are a wide variety of different types
of items you can add. Here, we'll add a simple line item to the canvas.</p>
<p>To create a line, you need to specify its starting and ending coordinates.
Coordinates are expressed as the number of pixels away from the top-left corner,
horizontally and vertically, i.e. (x,y). The pixel at the top-left corner, known
as the origin, has coordinates (0,0). The &quot;x&quot; value increases as you move to the
right, and the &quot;y&quot; value increases as you move down. A line is described by two
points, which we'd refer to as (x1,y1) and (x2,y2). This code creates a line
from (10,5) to (200,50):</p>
<pre><pre class="playground"><code class="language-rust no_run">use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();
    let canvas = root.add_canvas(())?.pack(())?;
    canvas.create_line( &amp;[ (10.0,5.0), (200.0,50.0) ], () )?;
    Ok( main_loop() )
}
</code></pre></pre>
<p>The <code>create_line</code> command returns an item id (an integer) that uniquely refers
to this item. We'll see how it can be used shortly. Often, we don't need to
refer to the item later and can ignore the returned id.</p>
<h2 id="a-simple-sketchpad"><a class="header" href="#a-simple-sketchpad">A Simple Sketchpad</a></h2>
<p>Let's start our simple sketchpad example. For now, we'll implement freehand
drawing on the canvas with the mouse. We create a canvas widget and attach event
bindings to it to capture mouse clicks and drags. When the mouse is first
pressed, we'll remember that location as the &quot;start&quot; of our next line. As the
mouse is moved with the mouse button held down, we create a line item from this
&quot;start&quot; position to the current mouse location. This current location becomes
the &quot;start&quot; position for the next line item. Every mouse drag creates a new line
item.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example canvas_a_simple_sketchpad

use std::os::raw::c_double;
use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();
    let canvas = root
        .add_canvas(())?
        .grid( -sticky(&quot;nwes&quot;) -column(0i32) -row(0i32) )?;
    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure( 0, -weight(1) )?;
    Widget::bind( &amp;canvas, event::button_press_1(), &quot;set lastx %x; set lasty %y&quot; )?;
    Widget::bind( &amp;canvas, event::button_1().motion(), tclosure!( tk, args: &quot;%x %y&quot;,
        move |x: c_double, y: c_double| -&gt; TkResult&lt;()&gt; {
            let last_x = tk.get_double(&quot;lastx&quot;)?;
            let last_y = tk.get_double(&quot;lasty&quot;)?;
            canvas.create_line( &amp;[ (last_x,last_y), (x,y) ], () )?;
            tk.set( &quot;lastx&quot;, x );
            tk.set( &quot;lasty&quot;, y );
            Ok(())
        }
    ))?;
    Ok( main_loop() )
}
</code></pre></pre>
<h2 id="item-attributes"><a class="header" href="#item-attributes">Item Attributes</a></h2>
<p>When creating items, you can also specify one or more item attributes, affecting
how it appears. For example, we can specify that the line should be red and
three pixels wide.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas.create_line( &amp;[ (10.0,10.0), (200.0,50.0) ], -fill(&quot;red&quot;)-width(3) )?;
<span class="boring">}
</span></code></pre></pre>
<p>The exact set of attributes will vary according to the type of item. Some
commonly used ones are:</p>
<table><thead><tr><th style="text-align: right">attribute</th><th style="text-align: left">description</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>fill</code></td><td style="text-align: left">color to draw the object</td></tr>
<tr><td style="text-align: right"><code>width</code></td><td style="text-align: left">line width of the item (or its outline)</td></tr>
<tr><td style="text-align: right"><code>outline</code></td><td style="text-align: left">for filled shapes like rectangles, the color to draw the item's outline</td></tr>
<tr><td style="text-align: right"><code>dash</code></td><td style="text-align: left">draw a dashed line instead of a solid one, e.g., 2 4 6 4 alternates short (2 pixels) and long (6 pixels) dashes with 4 pixels between</td></tr>
<tr><td style="text-align: right"><code>stipple</code></td><td style="text-align: left">instead of a solid fill color, use a pattern, typically gray75, gray50, gray25, or gray12; stippling is currently not supported on macOS</td></tr>
<tr><td style="text-align: right"><code>state</code></td><td style="text-align: left">assign a state of <code>normal</code>(default), <code>disabled</code>(item event bindings are ignored), or <code>hidden</code>(removed from display)</td></tr>
<tr><td style="text-align: right"><code>disabledfill</code>, <code>disabledwidth</code>, ...</td><td style="text-align: left">if the item's <code>state</code> is set to <code>disabled</code>, the item will display using these variants of the usual attributes</td></tr>
<tr><td style="text-align: right"><code>activefill</code>, <code>activewidth</code>, ...</td><td style="text-align: left">when the mouse pointer is over the item, it will display using these variants of the usual attributes</td></tr>
</tbody></table>
<blockquote>
<p>If you have canvas items that change state, creating the item with both the
regular and <code>disabled*</code> attribute variants can simplify your code. You simply
need to change the item's <code>state</code> rather than writing code to change multiple
display attributes. The same applies to the <code>active*</code> attribute variants. Both
encourage a more declarative style that can remove a lot of boilerplate code.</p>
</blockquote>
<p>Just like with Tk widgets, you can change the attributes of canvas items after
they're created.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let id = canvas.create_line( &amp;[ (0.0,0.0), (10.0,10.0) ], -fill(&quot;red&quot;) )?;
canvas.itemconfigure( id.into(), -fill(&quot;blue&quot;) -width(2) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="item-types"><a class="header" href="#item-types">Item Types</a></h2>
<p>Canvas widgets support a wide variety of item types.</p>
<h3 id="line"><a class="header" href="#line">Line</a></h3>
<p>Our sketchpad created simple line items, each a single segment with a start
point and an end point. Lines items can also consist of multiple segments.</p>
<p>Lines have several interesting additional attributes, allowing for drawing
curves, arrows, and more.</p>
<table><thead><tr><th style="text-align: right">attribute</th><th style="text-align: left">description</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>arrow</code></td><td style="text-align: left">place an arrowhead at the start(<code>first</code>), end(<code>last</code>), or both ends(<code>both</code>); default is <code>none</code></td></tr>
<tr><td style="text-align: right"><code>arrowshape</code></td><td style="text-align: left">allows changing the appearance of any arrowheads</td></tr>
<tr><td style="text-align: right"><code>capstyle</code></td><td style="text-align: left">for wide lines without arrowheads, this controls how the end of lines are drawn; one of <code>butt</code>(default), <code>projecting</code>, or <code>round</code></td></tr>
<tr><td style="text-align: right"><code>joinstyle</code></td><td style="text-align: left">for wide lines with multiple segments, this controls drawings of each vertex; one of <code>round</code> (default), <code>bevel</code>, or <code>miter</code></td></tr>
<tr><td style="text-align: right"><code>smooth</code></td><td style="text-align: left">if specified as <code>true</code> (or <code>bezier</code>), draws a smooth curve (via quadratic splines) between multiple segments rather than using straight lines; <code>raw</code> specifies a different type of curve (cubic splines)</td></tr>
<tr><td style="text-align: right"><code>splinesteps</code></td><td style="text-align: left">controls the smoothness of curved lines, i.e., those with the <code>smooth</code> option set</td></tr>
</tbody></table>
<h3 id="rectangle"><a class="header" href="#rectangle">Rectangle</a></h3>
<p>Rectangles are specified by the coordinates of opposing corners, e.g., top-left
and bottom-right. They can be filled in (via <code>fill</code>) with one color, and the
<code>outline</code> given a different color.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas.create_rectangle( 10.0, 10.0, 200.0, 50.0, -fill(&quot;red&quot;) -outline(&quot;blue&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="oval"><a class="header" href="#oval">Oval</a></h3>
<p>Ovals items work exactly the same as rectangles.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas.create_oval( 10.0, 10.0, 200.0, 50.0, -fill(&quot;red&quot;) -outline(&quot;blue&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="polygon"><a class="header" href="#polygon">Polygon</a></h3>
<p>Polygon items allow you to create arbitrary shapes as defined by a series of
points. The coordinates are given in the same way as multipoint lines. Tk
ensures the polygon is &quot;closed,&quot; attaching the last point to the first if
needed. Like ovals and rectangles, they can have separate <code>fill</code> and <code>outline</code>
colors. They also support the <code>joinstyle</code>, <code>smooth</code>, and <code>splinesteps</code>
attributes of line items.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas.create_polygon(
    &amp;[ (10.0,10.0), (200.0,50.0), (90.0,150.0), (50.0,80.0), (120.0,55.0) ],
    -fill(&quot;red&quot;) -outline(&quot;blue&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="arc"><a class="header" href="#arc">Arc</a></h3>
<p>Arc items draw a portion of an oval; think of one piece of a pie chart. Its
display is controlled by three attributes:</p>
<ul>
<li><code>start</code>: how far along the oval the arc should start, in degrees (0 is the
3-o'clock position)</li>
<li>The <code>extent</code>: how many degrees &quot;wide&quot; the arc should be, positive for
counter-clockwise from the start, negative for clockwise</li>
<li><code>style</code>: one of <code>pieslice</code>(the default), <code>arc</code>(draws just the outer
perimeter), or <code>chord</code>(draws the area between a line connecting the start and
end points of the arc and the outer perimeter).</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas.create_arc( 10.0, 10.0, 200.0, 50.0,
    -fill(&quot;yellow&quot;) -outline(&quot;black&quot;) -start(45) -extent(135) -width(5) )?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="widget"><a class="header" href="#widget">Widget</a></h3>
<p>One of the coolest things you can do with the canvas widget is embed other
widgets inside it. This can be a lowly button, an entry (think in-place editing
of text items), a listbox, a frame itself containing a complex set of widgets...
anything! Remember when we said way back when that a canvas widget could act as
a geometry manager? This is what we meant.</p>
<p>Canvas items that display other widgets are known as window items (Tk's
longstanding terminology for widgets). They are positioned like text and image
items. You can give them explicit <code>width</code> and <code>height</code> attributes; they default
to the widget's preferred size. Finally, it's important that the widget you're
placing on the canvas (via the <code>window</code>) attribute be a child widget of the
canvas.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let button = root.add_ttk_button( -text(&quot;Implode!&quot;) )?;
canvas.create_window( 10.0, 10.0, -anchor(&quot;nw&quot;) -window(button) )?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="modifying-items"><a class="header" href="#modifying-items">Modifying Items</a></h3>
<p>We've seen how you can modify the configuration options on an item  its color,
width, etc. There are several other things you can do with items.</p>
<p>To delete items, use the <code>delete</code> method.</p>
<p>To change an item's size and position, you can use the <code>coords</code> method. You
supply new coordinates for the item, specified the same way as when you first
created it. Calling this method without a new set of coordinates will return the
current coordinates of the item. You can use the <code>move</code> method to offset one or
more items horizontally or vertically from their current position.</p>
<p>All items are ordered from top to bottom in what's called the stacking order. If
an item later in the stacking order overlaps an item below it, the first item
will be drawn on top of the second. The <code>raise</code> (<code>lift</code> in Tkinter) and <code>lower</code>
methods allow you to adjust an item's position in the stacking order.</p>
<p>There are several more operations detailed in the reference manual to modify
items and retrieve information about them.</p>
<h2 id="run-example-17"><a class="header" href="#run-example-17">Run Example</a></h2>
<ul>
<li><code>cargo run --example canvas_creating_items</code></li>
<li><code>cargo run --example canvas_a_simple_sketchpad</code></li>
<li><code>cargo run --example canvas_item_types</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-bindings"><a class="header" href="#event-bindings">Event Bindings</a></h1>
<p>We've already seen that the canvas widget as a whole, like any other Tk widget,
can capture events using the bind command.</p>
<p>You can also attach bindings to individual items in the canvas (or groups of
them, as we'll see in the next section using tags). So if you want to know
whether or not a particular item has been clicked on, you don't need to watch
for mouse click events for the canvas as a whole and then figure out if that
click happened on your item. Tk will take care of all this for you.</p>
<p>To capture these events, you use a bind command built into the canvas. It works
exactly like the regular bind command, taking an event pattern and a callback.
The only difference is you specify the canvas item this binding applies to.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas.bind(
    id.into(),
    event::button_press_1(),
    tclosure!( tk, move || l.configure( -text(&quot;...&quot;) )))?;
<span class="boring">}
</span></code></pre></pre>
<p>Let's add some code to our sketchpad example to allow changing the drawing
color. We'll first create a few different rectangle items, each filled with a
different color. We'll then attach a binding to each of these. When they're
clicked on, they'll set a global variable to the new drawing color. Our mouse
motion binding will look at that variable when creating the line segments.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example canvas_event_binding

use std::os::raw::c_double;
use tcl::*;
use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();
    let canvas = root
        .add_canvas(())?
        .grid( -sticky(&quot;nwes&quot;) -column(0i32) -row(0i32) )?;
    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure( 0, -weight(1) )?;
    Widget::bind( &amp;canvas, event::button_press_1(), &quot;set lastx %x; set lasty %y&quot; )?;
    Widget::bind( &amp;canvas, event::button_1().motion(), tclosure!( tk, args: &quot;%x %y&quot;,
        move |x: c_double, y: c_double| -&gt; TkResult&lt;()&gt; {
            let last_x = tk.get_double(&quot;lastx&quot;)?;
            let last_y = tk.get_double(&quot;lasty&quot;)?;
            let color = tk.get(&quot;color&quot;)?;
            canvas.create_line( &amp;[ (last_x,last_y), (x,y) ], -fill(color) )?;
            tk.set( &quot;lastx&quot;, x );
            tk.set( &quot;lasty&quot;, y );
            Ok(())
        }
    ))?;

    let id = canvas.create_rectangle( 10.0, 10.0, 30.0, 30.0, -fill(&quot;red&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;red&quot; ); Ok(()) }))?;

    let id = canvas.create_rectangle( 10.0, 35.0, 30.0, 55.0, -fill(&quot;blue&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;blue&quot; ); Ok(()) }))?;

    let id = canvas.create_rectangle( 10.0, 60.0, 30.0, 80.0, -fill(&quot;black&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;black&quot; ); Ok(()) }))?;

    tk.set( &quot;color&quot;, &quot;black&quot; );
    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tags"><a class="header" href="#tags">Tags</a></h1>
<p>We've seen that every canvas item can be referred to by a unique id number.
There is another handy and powerful way to refer to items on a canvas, using
tags.</p>
<p>A tag is just an identifier of your creation, something meaningful to your
program. You can attach tags to canvas items; each item can have any number of
tags. Unlike item id numbers, which are unique for each item, many items can
share the same tag.</p>
<p>What can you do with tags? We saw that you can use the item id to modify a
canvas item (and we'll see soon there are other things you can do to items, like
move them around, delete them, etc.). Any time you can use an item id, you can
use a tag. For example, you can change the color of all items having a specific
tag.</p>
<p>Tags are a good way to identify collections of items in your canvas (items in a
drawn line, items in a palette, etc.). You can use tags to correlate canvas
items to particular objects in your application (for example, tag all canvas
items that are part of the robot with id #X37 with the tag &quot;robotX37&quot;). With
tags, you don't have to keep track of the ids of canvas items to refer to groups
of items later; tags let Tk do that for you.</p>
<p>You can assign tags when creating an item using the <code>tags</code> item configuration
option. You can add tags later with the <code>addtag</code> method or remove them with the
<code>dtags</code> method. You can get the list of tags for an item with the <code>gettags</code>
method or return a list of item id numbers having the given tag with the <code>find</code>
command.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example canvas_tags

use tk::*;
use tk::canvas::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();
    let canvas = root.add_canvas(())?.pack(())?;
    let _tag1 = canvas.create_line( &amp;[ (10.0,10.0), (20.0,20.0) ], -tags(&quot;firstline drawing&quot;) )?;
    let tag2 = canvas.create_rectangle( 30.0, 30.0, 40.0, 40.0, -tags(&quot;firstline drawing&quot;) )?;
    canvas.addtag( &quot;rectangle&quot;, SearchSpec::WithTag( tag2.clone().into() ))?;
    canvas.addtag( &quot;polygon&quot;, SearchSpec::WithTag( item_tag( &quot;drawing&quot; ).into() ))?;

    let tags = canvas.gettags( tag2.clone() )?;
    for name in &amp;[ &quot;drawing&quot;, &quot;rectangle&quot;, &quot;polygon&quot; ] {
        assert!( tags.iter().find( |&amp;tag| tag.0.as_str() == *name ).is_some() );
    }

    canvas.dtag( tag2.clone(), Some( ItemTag( &quot;polygon&quot;.to_owned() )))?;

    let tags = canvas.gettags( tag2.clone() )?;
    for name in &amp;[ &quot;drawing&quot;, &quot;rectangle&quot; ] {
        assert!( tags.iter().find( |&amp;tag| tag.0.as_str() == *name ).is_some() );
    }
    assert!( tags.iter().find( |&amp;tag| tag.0.as_str() == &quot;polygon&quot; ).is_none() );

    let items = canvas.find( SearchSpec::WithTag( item_tag( &quot;drawing&quot; ).into() ))?;

    assert_eq!(
        items.get_elements()?.map( |item| item.get_string() ).collect::&lt;Vec&lt;_&gt;&gt;(),
        vec![ &quot;1&quot;.to_owned(), &quot;2&quot;.to_owned() ]);
 
    Ok( main_loop() )
}
</code></pre></pre>
<p>As you can see, methods like <code>withtag</code> accept either an individual item or a
tag; in the latter case, they will apply to all items having that tag (which
could be none). The <code>addtag</code> and <code>find</code> methods have many other options,
allowing you to specify items near a point, overlapping a particular area, etc.</p>
<p>Let's use tags first to put a border around whichever item in our color palette
is currently selected.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example canvas_a_simple_sketchpad_border_around_selected

use std::os::raw::c_double;
use tcl::*;
use tk::*;
use tk::canvas::*;
use tk::cmd::*;

fn set_color&lt;Inst:TkInstance&gt;( tk: &amp;Tk&lt;Inst&gt;, canvas: &amp;TkCanvas&lt;Inst&gt;, color: &amp;Obj ) -&gt; TkResult&lt;()&gt; {
    tk.set( &quot;color&quot;, color.clone() );
    canvas.dtag( item_tag( &quot;all&quot; ), Some( item_tag( &quot;paletteSelected&quot; )))?;
    canvas.itemconfigure( item_tag( &quot;palette&quot; ), -outline(&quot;white&quot;) )?;
    canvas.addtag( &quot;paletteSelected&quot;, SearchSpec::WithTag( item_tag( &amp;format!( &quot;palette{}&quot;, color.clone() )).into() ))?;
    canvas.itemconfigure( item_tag( &quot;paletteSelected&quot; ), -outline(&quot;#999999&quot;) )?;
    Ok(())
}

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();
    let canvas = root
        .add_canvas(())?
        .grid( -sticky(&quot;nwes&quot;) -column(0i32) -row(0i32) )?;
    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure( 0, -weight(1) )?;
    Widget::bind( &amp;canvas, event::button_press_1(), &quot;set lastx %x; set lasty %y&quot; )?;
    Widget::bind( &amp;canvas, event::button_1().motion(), tclosure!( tk, args: &quot;%x %y&quot;,
        move |x: c_double, y: c_double| -&gt; TkResult&lt;()&gt; {
            let last_x = tk.get_double(&quot;lastx&quot;)?;
            let last_y = tk.get_double(&quot;lasty&quot;)?;
            let color = tk.get(&quot;color&quot;)?;
            set_color( &amp;tk, &amp;canvas, &amp;color )?;
            canvas.create_line( &amp;[ (last_x,last_y), (x,y) ], -fill(color) )?;
            tk.set( &quot;lastx&quot;, x );
            tk.set( &quot;lasty&quot;, y );
            Ok(())
        }
    ))?;

    let id = canvas.create_rectangle( 10.0, 10.0, 30.0, 30.0,
        -fill(&quot;red&quot;) -tags(&quot;palette palettered&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;red&quot; ); Ok(()) }))?;

    let id = canvas.create_rectangle( 10.0, 35.0, 30.0, 55.0,
        -fill(&quot;blue&quot;) -tags(&quot;palette paletteblue&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;blue&quot; ); Ok(()) }))?;

    let id = canvas.create_rectangle( 10.0, 60.0, 30.0, 80.0,
        -fill(&quot;black&quot;) -tags(&quot;palette paletteblack paletteSelected&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;black&quot; ); Ok(()) }))?;

    set_color( &amp;tk, &amp;canvas, &amp;Obj::from(&quot;black&quot;) )?;
    canvas.itemconfigure( item_tag( &quot;palette&quot; ), -width(5) )?;

    Ok( main_loop() )
}
</code></pre></pre>
<p>The canvas <code>itemconfigure</code> method provides another way to change the properties
of a canvas item. The advantage over dealing with the canvas item object
directly is that we can specify a tag, so that the change we're making applies
to all items having that tag. Without this, we could use <code>gettags</code> to get all
the items, iterate through them, and set the option, but <code>itemconfigure</code> is more
convenient.</p>
<p>Let's also use tags to make the current stroke being drawn appear more
prominent. When the mouse button is released, we'll return the line to normal.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Widget::bind( &amp;canvas, event::button_1().motion(), tclosure!( tk, args: &quot;%x %y&quot;,
    move |x: c_double, y: c_double| -&gt; TkResult&lt;()&gt; {
        // ...
        canvas.create_line( &amp;[ (last_x,last_y), (x,y) ],
            -fill(color) -width(5) -tags(&quot;currentline&quot;) )?;

        tk.set( &quot;lastx&quot;, x );
        tk.set( &quot;lasty&quot;, y );
        // ...
        Ok(())
    }
))?;

Widget::bind(
    &amp;canvas,
    event::button_1().button_pelease(),
    tclosure!( tk, move || -&gt;TkResult&lt;()&gt; {
        Ok( canvas.itemconfigure( item_tag( &quot;currentline&quot; ), -width(1) )? )
    })
)?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-18"><a class="header" href="#run-example-18">Run Example</a></h2>
<ul>
<li><code>cargo run --example canvas_tags</code></li>
<li><code>cargo run --example canvas_a_simple_sketchpad_border_around_selected</code></li>
<li><code>cargo run --example canvas_a_simple_sketchpad_more_prominent</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scrolling"><a class="header" href="#scrolling">Scrolling</a></h1>
<p>In many applications, you'll want the canvas to be larger than what appears on
the screen. You can attach horizontal and vertical scrollbars to the canvas in
the usual way via the <code>xview</code> and <code>yview</code> methods.</p>
<p>You can specify both how large you'd like it to be on screen and its full size
(which would require scrolling to see). The <code>width</code> and <code>height</code> configuration
options control how much space the canvas widget requests from the geometry
manager. The <code>scrollregion</code> configuration option tells Tk how large the canvas
surface is by specifying its left, top, right, and bottom coordinates, e.g.,
<code>0 0 1000 1000</code>.</p>
<p>You should be able to modify the sketchpad program to add scrolling, given what
you already know. Give it a try.</p>
<p>Once you've done that, scroll the canvas down just a little bit, and then try
drawing. You'll see that the line you're drawing appears above where the mouse
is pointing! Surprised?</p>
<p>What's going on is that the global <code>bind</code> command doesn't know that the canvas
is scrolled (it doesn't know the details of any particular widget). So if you've
scrolled the canvas down by 50 pixels, and you click on the top left corner,
bind will report that you've clicked at (0,0). But we know that because of the
scrolling, that position should really be (0,50).</p>
<p>The <code>canvasx</code> and <code>canvasy</code> methods translate the position onscreen (which bind
reports) into the actual point on the canvas (taking into account scrolling).</p>
<blockquote>
<p>Be careful if you're adding <code>canvasx</code> and <code>canvasy</code> methods directly to the
event binding scripts. You need to watch the quoting and substitutions to ensure
the conversions are done when the event fires. As always, it's better to place
that code in a procedure separate from the event binding itself.</p>
</blockquote>
<p>Here then, is our complete example. We probably don't want the palette to be
scrolled away when the canvas is scrolled, but we'll leave that for another day.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example canvas_scrolling

use std::os::raw::c_double;
use tcl::*;
use tk::*;
use tk::canvas::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let canvas = root
        .add_canvas( &quot;canvas&quot; -scrollregion(&quot;0 0 1000 1000&quot;) -yscrollcommand(&quot;.v set&quot;) -xscrollcommand(&quot;.h set&quot;) )?
        .grid( -sticky(&quot;nwes&quot;) -column(0i32) -row(0i32) )?;

    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure( 0, -weight(1) )?;

    let _h = root
        .add_ttk_scrollbar( &quot;h&quot; -orient(&quot;horizontal&quot;) -command(&quot;.canvas xview&quot;) )?
        .grid( -column(0) -row(1) -sticky(&quot;we&quot;) )?;

    let _v = root
        .add_ttk_scrollbar( &quot;v&quot; -orient(&quot;vertical&quot;) -command(&quot;.canvas yview&quot;) )?
        .grid( -column(1) -row(0) -sticky(&quot;ns&quot;) )?;

    Widget::bind( &amp;canvas, event::button_press_1(),
        &quot;set lastx [.canvas canvasx %x]; set lasty [.canvas canvasy %y]&quot; )?;
    Widget::bind( &amp;canvas, event::button_1().motion(), tclosure!( tk, args: &quot;%x %y&quot;,
        move |x: c_double, y: c_double| -&gt; TkResult&lt;()&gt; {
            let x = canvas.canvasx( x, None )?;
            let y = canvas.canvasy( y, None )?;
        
            let last_x = tk.get_double(&quot;lastx&quot;)?;
            let last_y = tk.get_double(&quot;lasty&quot;)?;
            let color = tk.get(&quot;color&quot;)?;

            canvas.dtag( item_tag( &quot;all&quot; ),
                Some( ItemTag( &quot;paletteSelected&quot;.to_owned() )))?;
            canvas.itemconfigure( item_tag( &quot;palette&quot; ),
                -outline(&quot;white&quot;) )?;
            canvas.addtag( &quot;paletteSelected&quot;,
                SearchSpec::WithTag(
                    item_tag( &amp;format!( &quot;palette{}&quot;, color.clone().get_string() )).into() ))?;
            canvas.itemconfigure( item_tag( &quot;paletteSelected&quot; ), -outline(&quot;#999999&quot;) )?;

            canvas.create_line( vec![ (last_x,last_y), (x,y) ],
                -fill(color) -width(5) -tags(&quot;currentline&quot;) )?;

            tk.set( &quot;lastx&quot;, x );
            tk.set( &quot;lasty&quot;, y );
            Ok(())
        }
    ))?;

    Widget::bind(
        &amp;canvas,
        event::button_1().button_pelease(),
        tclosure!( tk, move || -&gt;TkResult&lt;()&gt; {
            Ok( canvas.itemconfigure( item_tag( &quot;currentline&quot; ), -width(1) )? )
        })
    )?;

    let id = canvas.create_rectangle( 10.0, 10.0, 30.0, 30.0,
        -fill(&quot;red&quot;) -tags(&quot;palette palettered&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;red&quot; ); Ok(()) }))?;

    let id = canvas.create_rectangle( 10.0, 35.0, 30.0, 55.0,
        -fill(&quot;blue&quot;) -tags(&quot;palette paletteblue&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;blue&quot; ); Ok(()) }))?;

    let id = canvas.create_rectangle( 10.0, 60.0, 30.0, 80.0,
        -fill(&quot;black&quot;) -tags(&quot;palette paletteblack paletteSelected&quot;) )?;
    canvas.bind( id,
        event::button_press_1(),
        tclosure!( tk, move || { tk.set( &quot;color&quot;, &quot;black&quot; ); Ok(()) }))?;

    tk.set( &quot;color&quot;, &quot;black&quot; );
    canvas.itemconfigure( item_tag( &quot;palette&quot; ), -width(5) )?;

    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-1"><a class="header" href="#text-1">Text</a></h1>
<p>A <em>text</em> widget manages a multi-line text area. Like the canvas widget, Tk's
text widget is an immensely flexible and powerful tool that can be used for a
wide variety of tasks. It can provide a simple multi-line text area as part of a
form. But text widgets can also form the basis for a stylized code editor, an
outliner, a web browser, and much more.</p>
<p>Note: Text widgets are part of the classic Tk widgets, not the themed Tk
widgets.</p>
<table><thead><tr><th style="text-align: center">Text widgets</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/w_textfull_all.png" alt="Text widgets." /></td></tr>
</tbody></table>
<p>While we briefly introduced text widgets in an earlier chapter, we'll go into
more detail here. You'll get a better sense of the level of sophistication they
allow. Still, if you plan to do any significant work with the text widget, the
reference manual is a well-organized, helpful, and highly-recommended read.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parent.add_tk_text( &quot;t&quot; -width(40) -height(10) )?;
<span class="boring">}
</span></code></pre></pre>
<p>You'll often provide a width (in characters) and height (in lines). As always,
you can ask the geometry manager to expand it to fill the available space in the
window.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-basics"><a class="header" href="#the-basics">The Basics</a></h1>
<p>If you simply need a multi-line text field for a form, there are only a few
things to worry about: create and size the widget (check), provide an initial
value, and retrieve the text after a user has submitted the form.</p>
<h2 id="providing-initial-content"><a class="header" href="#providing-initial-content">Providing Initial Content</a></h2>
<p>Text widgets start with nothing in them, so we'll need to add any initial
content ourselves. Because text widgets can hold a lot more than plain text, a
simple mechanism (like the entry widget's <code>textvariable</code> configuration option)
isn't sufficient.</p>
<p>Instead, we'll use the widget's <code>insert</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.insert( Index::line_char(1,0), &quot;here is my\ntext to insert&quot; )?;
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Index::line_char(1,0)</code> here is the position where to insert the text, and
can be read as &quot;line 1, character 0&quot;. This refers to the first character of the
first line. Historically, especially on Unix, programmers tend to think about
line numbers as 1-based and character positions as 0-based.</p>
<p>The text to insert is just a string. Because the widget can hold multi-line
text, the string we supply can be multi-line as well. To do this, simply embed
<code>\n</code> (newline) characters in the string at the appropriate locations.</p>
<h2 id="retrieving-the-text"><a class="header" href="#retrieving-the-text">Retrieving the Text</a></h2>
<p>After users have made any changes and submitted the form (for example), your
program can retrieve the contents of the widget via the <code>get</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_text = txt.get_range( Index::line_char(1,0).. )?;
<span class="boring">}
</span></code></pre></pre>
<p><code>Index::line_char(1,0)..</code> indicates the start position is &quot;line 1, character 0&quot;
and the end position is &quot;the end&quot;; You can provide different start and end
positions if you want to obtain only part of the text.  You'll see more on
positions shortly.</p>
<h2 id="customizing-appearance"><a class="header" href="#customizing-appearance">Customizing Appearance</a></h2>
<p>We previously saw the <code>width</code> and <code>height</code> configuration options for text
widgets. Several other options control its appearance. The most useful are:</p>
<table><thead><tr><th style="text-align: right">attribute</th><th style="text-align: left">description</th></tr></thead><tbody>
<tr><td style="text-align: right">foreground</td><td style="text-align: left">color to draw the text in</td></tr>
<tr><td style="text-align: right">background</td><td style="text-align: left">background color of the widget</td></tr>
<tr><td style="text-align: right">padx, pady</td><td style="text-align: left">extra padding along the inside border of the widget</td></tr>
<tr><td style="text-align: right">borderwidth</td><td style="text-align: left">width of the border around widget</td></tr>
<tr><td style="text-align: right">relief</td><td style="text-align: left">border style: <code>flat</code>, <code>raised</code>, <code>sunken</code>, <code>solid</code>, <code>ridge</code>, <code>groove</code></td></tr>
</tbody></table>
<h2 id="wrapping-and-scrolling"><a class="header" href="#wrapping-and-scrolling">Wrapping and Scrolling</a></h2>
<p>What if some lines of text in the widget are very long, longer than the width of
the widget? By default, the text wraps around to the next line. This behavior
can be changed with the <code>wrap</code> configuration option. It defaults to <code>char</code>,
meaning wrap lines at any character. Other options are <code>word</code> to wrap lines only
at word breaks (e.g., spaces), and <code>none</code> meaning to not wrap lines at all. In
the latter case, some text of longer lines won't be visible unless we attach a
horizontal scrollbar to the widget. (Users can also scroll through the text
using arrow keys, even if scrollbars aren't present).</p>
<p>Both horizontal and vertical scrollbars can be attached to the text widget in
the same way as with other widgets, e.g., canvas, listbox.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example text_wrapping_and_scrolling

use tk::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let txt = root.add_text( &quot;t&quot;
        -width(40) -height(5) -wrap(&quot;none&quot;)
        -yscrollcommand(&quot;.ys set&quot;) -xscrollcommand(&quot;.xs set&quot;) )?
        .grid( -column(0) -row(0) -sticky(&quot;nwes&quot;) )?;
    let _xs = root
        .add_ttk_scrollbar( &quot;xs&quot; -orient(&quot;horizontal&quot;) -command(&quot;.t xview&quot;) )?
        .grid( -column(0) -row(1) -sticky(&quot;we&quot;) )?;
    let _ys = root
        .add_ttk_scrollbar( &quot;ys&quot; -orient(&quot;vertical&quot;) -command(&quot;.t yview&quot;) )?
        .grid( -column(1) -row(0) -sticky(&quot;ns&quot;) )?;

    txt.insert( text::Index::end(), &quot;Lorem ipsum...\n...\n... &quot; )?;
    root.grid_columnconfigure( 0, -weight(1) )?;
    root.grid_rowconfigure( 0, -weight(1) )?;

    Ok( main_loop() )
}
</code></pre></pre>
<p>We can also ask the widget to ensure that a certain part of the text is visible.
For example, let's say we've added more text to the widget than will fit
onscreen (so it will scroll). However, we want to ensure that the top of the
text rather than the bottom is visible. We can use the <code>see</code> method.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.see( Index::line_char(1,0) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="disabling-the-widget"><a class="header" href="#disabling-the-widget">Disabling the Widget</a></h2>
<p>Some forms will temporarily disable editing in particular widgets unless certain
conditions are met (e.g., some other options are set to a certain value). To
prevent users from changing a text widget, set the <code>state</code> configuration option
to <code>disabled</code>. Re-enable editing by setting this option back to <code>normal</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.configure( -state(&quot;disabled&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>As text widgets are part of the classic widgets, the usual <code>state</code> and
<code>instate</code> methods are not available.</p>
</blockquote>
<h2 id="run-example-19"><a class="header" href="#run-example-19">Run Example</a></h2>
<ul>
<li><code>cargo run --example text_the_basics</code></li>
<li><code>cargo run --example text_wrapping_and_scrolling</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modifying-the-text-in-code"><a class="header" href="#modifying-the-text-in-code">Modifying the Text in Code</a></h1>
<p>While users can modify the text in the text widget interactively, your program
can also make changes. Adding text is done with the <code>insert</code> method, which we
used above to provide an initial value for the text widget.</p>
<h2 id="text-positions-and-indices"><a class="header" href="#text-positions-and-indices">Text Positions and Indices</a></h2>
<p>When we specified a position of <code>Index::line_char( 1, 0 )</code> (first
line, first character), this was an example of an index. It tells the <code>insert</code>
method where to put the new text (just before the first line, first character,
i.e., at the very start of the widget). Indices can be specified in a variety of
ways. We used another one with the <code>get</code> method: <code>Index::end()</code> means just
past the end of the text. (Why &quot;just past?&quot; Text is inserted right before the
given index, so inserting at <code>End</code> will add text to the end of the widget). Note
that Tk will always add a newline at the very end of the text widget.</p>
<p>Here are a few additional examples of indices and how to interpret them:</p>
<table><thead><tr><th style="text-align: right">attribute</th><th style="text-align: left">description</th></tr></thead><tbody>
<tr><td style="text-align: right"><code>Index::line(3)..</code></td><td style="text-align: left">The newline at the end of line 3</td></tr>
<tr><td style="text-align: right"><code>Index::line_char(1,0).chars(3)</code></td><td style="text-align: left">Three characters past the start of line 1</td></tr>
<tr><td style="text-align: right"><code>Index::line(2)..Index::end().chars(-1)</code></td><td style="text-align: left">The last character before the new line in line 2</td></tr>
<tr><td style="text-align: right"><code>Index::end().chars(-1)</code></td><td style="text-align: left">The newline that Tk always adds at the end of the text</td></tr>
<tr><td style="text-align: right"><code>Index::end().chars(-2)</code></td><td style="text-align: left">The actual last character of the text</td></tr>
<tr><td style="text-align: right"><code>Index::end().lines(-1)</code></td><td style="text-align: left">The start of the last actual line of text</td></tr>
<tr><td style="text-align: right"><code>Index::line_char(2,2).lines(2)</code></td><td style="text-align: left">The third character (index 2) of the fourth line of text</td></tr>
<tr><td style="text-align: right"><code>Index::line_char(2,5).linestart()</code></td><td style="text-align: left">The first character of line 2</td></tr>
<tr><td style="text-align: right"><code>Index::line_char(2,5).lineend()</code></td><td style="text-align: left">The position of the newline at the end of line 2</td></tr>
<tr><td style="text-align: right"><code>Index::line_char(2,5).wordstart()</code></td><td style="text-align: left">First char. of the word with the char. at index 2.5</td></tr>
<tr><td style="text-align: right"><code>Index::line_char(2,5).wordend()</code></td><td style="text-align: left">First char. after the word with the char. at index 2.5</td></tr>
</tbody></table>
<p>Some additional things to keep in mind:</p>
<ul>
<li>An index past the end of the text (e.g., <code>Index::end().chars(100)</code> is
interpreted as <code>Index::end()</code>.</li>
<li>Indices wrap to subsequent lines as needed; e.g.,
<code>Index::line_char(1,0).chars(10)</code> on a line with only five characters will
refer to a position on the second line.</li>
<li>Line numbers in indices are interpreted as logical lines, i.e., each line ends
only at the &quot;\n.&quot; With long lines and wrapping enabled, one logical line may
represent multiple display lines. If you'd like to move up or down a single
line on the display, you can specify this as, e.g.,
<code>Index::line_char(1,0).display_lines(2)</code>.</li>
</ul>
<p>To determine the canonical position of an index, use the
<code>index( &amp;self, index: Index )</code> method. Pass it any index expression, and it
returns the corresponding index in the form &quot;line.char&quot;. For example, to find
the position of the last character (ignoring the automatic newline at the end),
use:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.index( Index::end() )?;
<span class="boring">}
</span></code></pre></pre>
<p>You can compare two indices using the <code>compare</code> method, which lets you check for
equality, whether one index is later in the text than the other, etc.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if txt.compare( index1, TkCmp::Equal, index2 )? {
    // same position
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="deleting-text"><a class="header" href="#deleting-text">Deleting Text</a></h2>
<p>While the <code>insert</code> method adds new text anywhere in the widget, the
<code>delete( &amp;self, index: Index )</code> and
<code>delete_ranges( &amp;self, ranges: Vec&lt;Range&lt;Index&gt;&gt; )</code> methods removes it. We can
delete either a single character (specified by index) or a range of characters
(specified by start and end indices). In the latter case, characters from (and
including) the start index until just before the end index are deleted (the
character at the end index is not deleted). So if we assume for each of these we
start off with <code>&quot;abcd\nefgh&quot;</code> in the text widget:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.delete( Index::line_char(1,2) )?; // &quot;abd\nefgh&quot;
txt.delete_ranges( vec![ Index::line_char(1,1), Index::line_char(1,2) ])?; // &quot;acd\nefgh&quot;
txt.delete_ranges( vec![ Index::line_char(1,0), Index::line_char(2,0) ])?; // &quot;efgh&quot;
txt.delete_ranges( vec![ Index::line_char(1,2), Index::line_char(2,1) ])?; // &quot;abfgh&quot;
<span class="boring">}
</span></code></pre></pre>
<p>There is also a <code>replace</code> method that performs a <code>delete</code> followed by an
<code>insert</code> at the same location.</p>
<h2 id="example-logging-window"><a class="header" href="#example-logging-window">Example: Logging Window</a></h2>
<p>Here's a short example using a text widget as an 80x24 logging window for an
application. Users don't edit the text widget at all. Instead, the program
writes log messages to it. We'd like to display more than 24 lines (so no
scrolling). If the log is full, old messages are removed from the top before new
ones are added at the end.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example logging_window

use tk::*;
use tk::cmd::*;
use tk::text::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let log = root
        .add_text( -width(80) -height(24) -wrap(&quot;none&quot;) )?
        .grid(())?;

    let write_to_log = | msg: &amp;str| -&gt; TkResult&lt;()&gt; {
        let index = log.index( Index::end().lines(-1) )?;
        log.configure( -state(&quot;normal&quot;) )?;
        log.insert( Index::end(), msg )?;
        if log.index( Index::end().chars(-1) )? != Index::line_char(1,0) {
            log.insert( Index::end(), &quot;\n&quot; )?;
        }
        if let Index::LineChar( num_line, _, _ ) = index {
            if num_line &gt; 24 {
                log.delete_ranges( vec![ Index::line_char(1,0)..Index::line_char(num_line-23,0) ])?;
            }
        }
        log.configure( -state(&quot;disabled&quot;) )?;
        Ok(())
    };

    for c in 'a'..='z' {
        write_to_log( &amp;format!( &quot;{0}{0}{0}{0}{0}{0}{0}{0}{0}{0}&quot;, c ))?;
    }

    Ok( main_loop() )
}
</code></pre></pre>
<blockquote>
<p>Note that because the program placed the widget in a disabled state, we had to
re-enable it to make any changes, even from our program.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatting-with-tags"><a class="header" href="#formatting-with-tags">Formatting with Tags</a></h1>
<p>So far, we've used text widgets when all the text is in a single font. Now it's
time to add formatting like bold, italic, strikethrough, background colors, font
sizes, and much more. Tk's text widget implements these using a feature called
tags.</p>
<p>Tags are objects associated with the text widget. Each tag is referred to via a
name chosen by the programmer. Each tag has several configuration options. These
are things like fonts and colors that control formatting. Though tags are
objects having state, they don't need to be explicitly created but are
automatically created the first time the tag name is used.</p>
<h2 id="adding-tags-to-text"><a class="header" href="#adding-tags-to-text">Adding Tags to Text</a></h2>
<p>Tags can be associated with one or more ranges of text in the widget. As before,
ranges are specified via indices. A single index represents a single character,
and a pair of indices represent a range from the start character to just before
the end character. Tags are added to a range of text using the <code>tag_add</code> method.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.tag_add( &quot;highlightline&quot;, vec![ Index::line_char(5,0), Index::line_char(6,0) ] )?;
<span class="boring">}
</span></code></pre></pre>
<p>Tags can also be provided when first inserting text. The <code>insert_with_tags</code>
method supports an optional parameter containing a list of one or more tags to
add to the text being inserted.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>log.insert_with_tags( Index::end(), &amp;[
    ( &quot;new material to insert&quot;, &amp;[&quot;highlightline&quot;,&quot;recent&quot;,&quot;warning&quot;] )
])?;
<span class="boring">}
</span></code></pre></pre>
<p>As the widget's contents are modified (whether by a user or your program), the
tags will adjust automatically. For example, if we tagged the text &quot;the quick
brown fox&quot; with the tag &quot;nounphrase&quot;, and then replaced the word &quot;quick&quot; with
&quot;speedy,&quot; the tag still applies to the entire phrase.</p>
<h2 id="applying-formatting-to-tags"><a class="header" href="#applying-formatting-to-tags">Applying Formatting to Tags</a></h2>
<p>Formatting is applied to tags via configuration options; these work similarly to
configuration options for the entire widget. As an example:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.tag_configure( &quot;highlightline&quot;,
    -background(&quot;yellow&quot;) -font(&quot;TkFixedFont&quot;) -relief(&quot;raised&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Tags support the following configuration options: <code>background</code>, <code>bgstipple</code>,
<code>borderwidth</code>, <code>elide</code>, <code>fgstipple</code>, <code>font</code>, <code>foreground</code>, <code>justify</code>,
<code>lmargin1</code>, <code>lmargin2</code>, <code>offset</code>, <code>overstrike</code>, <code>relief</code>, <code>rmargin</code>, <code>spacing1</code>,
<code>spacing2</code>, <code>spacing3</code>, <code>tabs</code>, <code>tabstyle</code>, <code>underline</code>, and <code>wrap</code>. Check the
reference manual for detailed descriptions of these. The
<code>tag_cget( tag, option )</code> method allows us to query the configuration options of
a tag.</p>
<p>Because multiple tags can apply to the same range of text, there is the
possibility of conflict (e.g., two tags specifying different fonts). A priority
order is used to resolve these; the most recently created tags have the highest
priority, but priorities can be rearranged using the
<code>tag_raise( tag, above_this )</code> and <code>tag_lower( tag, below_this )</code> methods.</p>
<h2 id="more-tag-manipulations"><a class="header" href="#more-tag-manipulations">More Tag Manipulations</a></h2>
<p>To delete one or more tags altogether, we can use the <code>tag_delete( tags)</code>
method. This also, of course, removes any references to the tag in the text. We
can also remove a tag from a range of text using the <code>tag_remove( tag, ranges )</code>
method. Even if that leaves no ranges of text with that tag, the tag object
itself still exists.</p>
<p>The <code>tag_ranges( tag )</code> method will return a list of ranges in the text that the
tag has been applied to. There are also <code>tag_nextrange( tag, range )</code> and
<code>tag_prevrange( tag, range )</code> methods to search forward or backward for the
first such range from a given position.</p>
<p>The <code>tag_names_all()</code> method will return a list of all tags currently defined in
the text widget (including those that may not be presently used). The
<code>tag_names( index )</code> method will return the list of tags applied to just the
character at the index.</p>
<p>Finally, we can use the first and last characters in the text having a given tag
as indices, the same way we can use <code>Index::end()</code> or <code>Index::line_char(2,5)</code>.
To do so, just specify <code>Index::TagFirst( name, _ )</code> or
<code>Index::TagLast( name, _ )</code>.</p>
<h2 id="differences-between-tags-in-canvas-and-text-widgets"><a class="header" href="#differences-between-tags-in-canvas-and-text-widgets">Differences between Tags in Canvas and Text Widgets</a></h2>
<p>Both canvas and text widgets support &quot;tags&quot; that can be applied to several
objects, style them, etc. However, canvas and text tags are not the same and
there are substantial differences to take note of.</p>
<p>In canvas widgets, only individual canvas items have configuration options that
control their appearance. When we refer to a tag in a canvas, the meaning of
that is identical to &quot;all canvas items presently having that tag.&quot; The tag
itself doesn't exist as a separate object. So in the following snippet, the last
rectangle added will not be colored red. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>canvas.itemconfigure( item_tag(&quot;important&quot;), -fill(&quot;red&quot;) )?;
canvas.create_rectangle( 10, 10, 40, 40, -tags(&quot;important&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>In contrast, with text widgets, it's not the individual characters that retain
the state information about appearance, but tags, which are objects in their own
right. So in this snippet, the newly added text will be colored red.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.insert_with_tags( Index::end(), &amp;[ &quot;first text&quot;, &amp;[ &quot;important&quot; ]])?;
txt.tag_configure( &quot;important&quot; -foreground(&quot;red&quot;) )?;
txt.insert_with_tags( Index::end(), &amp;[ &quot;second text&quot;, &amp;[ &quot;important&quot; ]])?;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events-and-bindings"><a class="header" href="#events-and-bindings">Events and Bindings</a></h1>
<p>One very cool thing we can do is define event bindings on tags. That allows us
to easily do things like recognize mouse clicks on particular ranges of text and
popup a menu or dialog in response. Different tags can have different bindings.
This saves the hassle of sorting out questions like &quot;what does a click at this
location mean?&quot;. Bindings on tags are implemented using the <code>tag_bind</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>txt.tag_bind( &quot;important&quot;, event::button_press_1(), popup_important_menu )?;
<span class="boring">}
</span></code></pre></pre>
<p>Widget-wide event bindings continue to work as they do for every other widget,
e.g., to capture a mouse click anywhere in the text. Besides the normal
low-level events, the text widget generates a <code>Modified</code> virtual event whenever
a change is made to the content of the widget, and a <code>Selection</code> virtual event
whenever there is a change made to which text is selected.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selecting-text"><a class="header" href="#selecting-text">Selecting Text</a></h1>
<p>We can identify the range of text selected by a user, if any. For example, an editor may have a toolbar button to bold the selected text. While you can tell when the selection has changed (e.g., to update whether or not the bold button is active) via the <code>Selection</code> virtual event, that doesn't tell you what has been selected.</p>
<p>The text widget automatically maintains a tag named <code>sel</code>, which refers to the selected text. Whenever the selection changes, the <code>sel</code> tag will be updated. So we can find the range of text selected using the <code>tag_ranges tag</code> method, passing it <code>sel</code> as the tag to report on.</p>
<p>Similarly, we can change the selection by using <code>tag_add</code> to set a new
selection, or <code>tag_remove</code> to remove the selection. The sel tag cannot be
deleted, however.</p>
<blockquote>
<p>Though the default widget bindings prevent this from happening, <code>sel</code> is like
any other tag in that it can support multiple ranges, i.e., disjoint selections.
To prevent this from happening, when changing the selection from your code, make
sure to remove any old selection before adding a new one.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marks"><a class="header" href="#marks">Marks</a></h1>
<p>Marks indicate a particular place in the text. In that respect, they are like indices. However, as the text is modified, the mark will adjust to be in the same relative location. In that way, they resemble tags but refer to a single position rather than a range of text. Marks actually don't refer to a position occupied by a character in the text but specify a position between two characters.</p>
<p>Tk automatically maintains two different marks. The first, named <code>insert</code>, is the present location of the insertion cursor. As the cursor is moved (via mouse or keyboard), the mark moves with it. The second mark, named <code>current</code>, tracks the position of the character underneath the current mouse position.</p>
<p>To create your own marks, use the widget's <code>mark_set( name, index)</code> method, passing it the name of the mark and an index (the mark is positioned just before the character at the given index). This is also used to move an existing mark to a different position. Marks can be removed using the <code>mark_unset( name )</code> method, passing it the name of the mark. If you delete a range of text containing a mark, that also removes the mark.</p>
<p>The name of a mark can also be used as an index (in the same way
<code>Index::line_char(1,0)</code> or <code>Index::end().chars(-1)</code> are indices). You can find
the next mark (or previous one) from a given index in the text using the
<code>mark_next( index )</code> or <code>mark_previous( index )</code> methods. The <code>mark_names</code>
method will return a list of the names of all marks.</p>
<p>Marks also have a gravity, which can be modified with the
<code>set_mark_gravity( name, direction )</code> method, which affects what happens when
text is inserted at the mark. Suppose we have the text &quot;ac&quot; with a mark in
between that we'll symbolize with a pipe, i.e., &quot;a|c.&quot; If the gravity of that
mark is <code>TkTextMarkGravity::Right</code> (the default), the mark attaches itself to
the &quot;c.&quot; If the new text &quot;b&quot; is inserted at the mark, the mark will remain stuck
to the &quot;c,&quot; and so the new text will be inserted before the mark, i.e., &quot;ab|c.&quot;
If the gravity is instead <code>TkTextMarkGravity::Left</code>, the mark attaches itself to
the &quot;a,&quot; and so new text will be inserted after the mark, i.e., &quot;a|bc.&quot;</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="images-and-widgets"><a class="header" href="#images-and-widgets">Images and Widgets</a></h1>
<p>Like canvas widgets, text widgets can contain images and any other Tk widgets
(including frames containing many other widgets). In a sense, this allows the
text widget to work as a geometry manager in its own right. The ability to add
images and widgets within the text opens up a world of possibilities for your
program.</p>
<p>Images are added to a text widget at a particular index, with the image
specified as an existing Tk image. Other options that allow you to fine-tune
padding, etc.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let img = tk.image_create_photo( -file(&quot;book/src/images/tcl.gif&quot;) )?;
txt.image_create( Index::tag_first(&quot;sel&quot;), -image(img) )?;
<span class="boring">}
</span></code></pre></pre>
<p>Other widgets are added to a text widget in much the same way as images. The
widget being added must be a descendant of the text widget in the widget
hierarchy.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = txt.add_ttk_button( -text(&quot;Push Me&quot;) )?;
txt.window_create( Index::line_char(1,0), -window(b) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-20"><a class="header" href="#run-example-20">Run Example</a></h2>
<p><code>cargo run --example text_images_and_widgets</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-more"><a class="header" href="#even-more">Even More</a></h1>
<p>Text widgets can do many more things. Here, we'll briefly mention just a few
more of them. For details on any of these, see the reference manual.</p>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<p>The text widget includes a powerful <code>search</code> method to locate a piece of text
within the widget. This is useful for a &quot;Find&quot; dialog, as one obvious example.
You can search backward or forward from a particular position or within a given
range, specify the search term using exact text, case insensitive, or via
regular expressions, find one or all occurrences of the search term, etc.</p>
<h2 id="modifications-undo-and-redo"><a class="header" href="#modifications-undo-and-redo">Modifications, Undo and Redo</a></h2>
<p>The text widget keeps track of whether changes have been made (useful to know
whether it needs to be saved to a file, for example). We can query (or change)
using the <code>set_edit_modified( modified )</code> method. There is also a complete
multi-level undo/redo mechanism, managed automatically by the widget when we set
its <code>undo</code> configuration option to <code>true</code>. Calling <code>edit_undo</code> or <code>edit_redo</code>
modifies the current text using information stored on the undo/redo stack.</p>
<h2 id="eliding-text"><a class="header" href="#eliding-text">Eliding Text</a></h2>
<p>Text widgets can include text that is not displayed. This is known as &quot;elided&quot;
text, and is made available using the <code>elide</code> configuration option for tags. It
can be used to implement an outliner, a &quot;folding&quot; code editor, or even to bury
extra meta-data intermixed with displayed text. When specifying positions within
elided text, you have to be a bit more careful. Methods that work with positions
have extra options to either include or ignore the elided text.</p>
<h2 id="introspection"><a class="header" href="#introspection">Introspection</a></h2>
<p>Like most Tk widgets, the text widget goes out of its way to expose information
about its internal state. We've seen this in terms of the <code>get</code> method, widget
configuration options, <code>names</code> and <code>cget</code> for both tags and marks, etc. There is
even more information available that can be useful for a wide variety of tasks.
Check out the <code>debug</code>, <code>dlineinfo</code>, <code>bbox</code>, <code>count</code>, and <code>dump</code> methods in the
reference manual.</p>
<h2 id="peering"><a class="header" href="#peering">Peering</a></h2>
<p>The Tk text widget allows the same underlying text data structure (containing
all the text, marks, tags, images, etc.) to be shared between two or more
different text widgets. This is known as peering and is controlled via
<code>peer_create</code> and <code>peer_names</code> methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="treeview"><a class="header" href="#treeview">Treeview</a></h1>
<p>A <em>treeview</em> widget displays a hierarchy of items and allows users to browse
through it. One or more attributes of each item can be displayed as columns to
the right of the tree. It can be used to build user interfaces similar to the
tree display you'd find in file managers like the macOS Finder or Windows
Explorer. As with most Tk widgets, it offers incredible flexibility so it can be
customized to suit a wide range of situations.</p>
<table><thead><tr><th style="text-align: center"><img src="./images/w_treeview_all.png" alt="Treeview widgets." /></th></tr></thead><tbody>
<tr><td style="text-align: center">Treeview widgets</td></tr>
</tbody></table>
<p>Treeview widgets are created using the <code>add_ttk_treeview</code> command:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tree = root.add_ttk_treeview(())?;
<span class="boring">}
</span></code></pre></pre>
<p>Horizontal and vertical scrollbars can be added in the usual manner if desired.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-items-to-the-tree"><a class="header" href="#adding-items-to-the-tree">Adding Items to the Tree</a></h1>
<p>To do anything useful with the treeview, we'll need to add one or more items to
it. Each item represents a single node in the tree, whether a leaf node or an
internal node containing other nodes. Items are referred to by a unique id. You
can assign this id when the item is first created, or the widget can
automatically generate one.</p>
<p>Items are created by inserting them into the tree, using the treeview's <code>insert</code>
method. To insert an item, we need to know where to insert it. That means
specifying the parent item and where within the list of the parent's existing
children the new item should be inserted.</p>
<p>The treeview widget automatically creates a root node (which is not displayed).
Its id is the empty string. It serves as the parent of the first level of items
that are added. Positions within the list of a node's children are specified by
index (0 being the first, and <code>Index::End</code> meaning insert after all existing
children).</p>
<p>Normally, you'll also specify the name of each item, which is the text displayed
in the tree. Other options allow you to add an image beside the name, specify
whether the node is open or closed, etc.</p>
<p>Inserting the item returns the id of the newly created item.</p>
<pre><pre class="playground"><code class="language-rust no_run">// cargo run --example adding_items_to_the_tree

use tk::*;
use tk::ttk_treeview::*;
use tk::cmd::*;

fn main() -&gt; TkResult&lt;()&gt; {
    let tk = make_tk!()?;
    let root = tk.root();

    let tree = root.add_ttk_treeview(())?.pack(())?;

    // Inserted at the root, program chooses id:
    tree.insert( &quot;&quot;, Index::End, &quot;widgets&quot; -text(&quot;Widget Tour&quot;) )?;
     
    // Same thing, but inserted as first child:
    tree.insert( &quot;&quot;, 0, &quot;gallery&quot; -text(&quot;Applications&quot;) )?;
    
    // Treeview chooses the id:
    let id = tree
        .insert( &quot;&quot;, Index::End, -text(&quot;Tutorial&quot;) )?
        .unwrap();
    
    // Inserted underneath an existing node:
    tree.insert( &quot;widgets&quot;, Index::End, -text(&quot;Canvas&quot;) )?;
    tree.insert( &amp;id, Index::End, -text(&quot;Tree&quot;) )?;
 
    Ok( main_loop() )
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rearranging-items"><a class="header" href="#rearranging-items">Rearranging Items</a></h1>
<p>A node (and its descendants, if any) can be moved to a different location in the
tree. The only restriction is that a node cannot be moved underneath one of its
descendants for obvious reasons. As before, the target location is specified via
a parent node and a position within its list of children.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// move widgets under gallery
tree.move_item( &quot;widgets&quot;, &quot;gallery&quot;, Index::End )?;
<span class="boring">}
</span></code></pre></pre>
<p>Items can be detached from the tree. This removes the item and its descendants
from the hierarchy but does not destroy the items. This allows us to later
reinsert them with <code>move_item</code>.</p>
<p>Items can also be deleted, which does completely destroy the item and its
descendants.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tree.delete( &amp;[ &quot;widgets&quot; ])?;
<span class="boring">}
</span></code></pre></pre>
<p>To traverse the hierarchy, there are methods to find the parent of an item
(<code>parent_item</code>), its next or previous sibling (<code>next_item</code> and <code>prev_item</code>), and
return the list of <code>children</code> of an item.</p>
<p>We can control whether or not the item is open and shows its children by
modifying the <code>open</code> item configuration option.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tree.set_item( &quot;widgets&quot;, -open(&quot;true&quot;) )?;
let is_open = tree.item( &quot;widgets&quot;, open )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-21"><a class="header" href="#run-example-21">Run Example</a></h2>
<p><code>cargo run --example rearranging_items</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="displaying-information-for-each-item"><a class="header" href="#displaying-information-for-each-item">Displaying Information for each Item</a></h1>
<p>The treeview can display one or more additional pieces of information about each
item. These are shown as columns to the right of the main tree display.</p>
<p>Each column is referenced by a symbolic name that we assign. We can specify the
list of columns using the <code>columns</code> configuration option of the treeview widget,
either when first creating the widget or later on.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>root.add_ttk_treeview( -columns(&quot;size modified&quot;) )?;
tree.configure( -columns(&quot;size modified owner&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>We can specify the width of the column, how the display of item information in
the column is aligned, and more. We can also provide information about the
column's heading, such as the text to display, an optional image, alignment, and
a script to invoke when the item is clicked (e.g., to sort the tree).</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tree.set_column( &quot;size&quot;, -width(100) -anchor(&quot;center&quot;) )?;
tree.set_heading( &quot;size&quot;, -text(&quot;Size&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>What to display in each column for each item can be specified individually by
using the <code>set_item_at_column</code> method. You can also provide a list describing
what to display in all the columns for the item. This is done using the <code>values</code>
item configuration option. It takes a list of values and can be provided when
first inserting the item or changed later. The order of the list must be the
same as the order in the <code>columns</code> widget configuration option.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tree.set_item_at_column( &quot;widgets&quot;, &quot;size&quot;, &quot;12KB&quot; )?;
let size = tree.item_at_column( &quot;widgets&quot;, &quot;size&quot; )?;
assert_eq!( size.to_string(), &quot;12KB&quot; );
tree.insert( &quot;&quot;, Index::End,
    -text(&quot;Listbox&quot;) -values(&amp;[&quot;15KB&quot;,&quot;Yesterday&quot;,&quot;mark&quot;]) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-example-22"><a class="header" href="#run-example-22">Run Example</a></h2>
<p><code>cargo run --example displaying_information_for_each_item</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-appearance-and-events"><a class="header" href="#item-appearance-and-events">Item Appearance and Events</a></h1>
<p>Like the text and canvas widgets, the treeview widget uses tags to modify the
appearance of items in the tree. We can assign a list of tags to each item using
the <code>tags</code> item configuration option (again, when creating the item or later
on).</p>
<p>Configuration options can then be specified on the tag, applied to all items
having that tag. Valid tag options include <code>foreground</code> (text color),
<code>background</code>, <code>font</code>, and <code>image</code> (not used if the item specifies its own
image).</p>
<p>We can also create event bindings on tags to capture mouse clicks, keyboard
events, etc.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tree.insert( &quot;&quot;, Index::End, -text(&quot;button&quot;) -tags(&quot;ttk simple&quot;) )?;
tree.tag_configure( &quot;ttk&quot;, -background(&quot;yellow&quot;) )?;
tree.tag_bind( &quot;ttk&quot;, event::button_1(), item_clicked )?;
// the item clicked can be found via tree.focus()
<span class="boring">}
</span></code></pre></pre>
<p>The treeview will generate virtual events <code>TreeviewSelect</code>, <code>TreeviewOpen</code>, and
<code>TreeviewClose</code>, which allow us to monitor changes to the widget made by users.
We can use the <code>selection</code> method to determine the current selection (the
selection can also be changed from your program).</p>
<h2 id="run-example-23"><a class="header" href="#run-example-23">Run Example</a></h2>
<p><code>cargo run --example item_appearance_and_events</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customizing-the-display"><a class="header" href="#customizing-the-display">Customizing the Display</a></h1>
<p>There are many aspects of how the treeview widget is displayed that we can
customize. We've already seen some of them, such as the text of items, fonts and
colors, names of column headings, and more. Here are a few additional ones.</p>
<ul>
<li>Specify the desired number of rows to show using the <code>height</code> widget configuration option.</li>
<li>Control the width of each column using the column's <code>width</code> or <code>minwidth</code>
options. The column holding the tree can be accessed with the symbolic name
<code>#0</code>. The overall requested width for the widget is based on the sum of the
column widths.</li>
<li>Choose which columns to display and the order to display them in using the
<code>displaycolumns</code> widget configuration option.</li>
<li>You can optionally hide one or both of the column headings or the tree itself
(leaving just the columns) using the <code>show</code> widget configuration option
(default is &quot;tree headings&quot; to show both).</li>
<li>You can specify whether a single item or multiple items can be selected by
users via the <code>selectmode</code> widget configuration option, passing <code>browse</code>
(single item), <code>extended</code> (multiple items, the default), or <code>none</code>. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styles-and-themes"><a class="header" href="#styles-and-themes">Styles and Themes</a></h1>
<p>The themed aspect of the modern Tk widgets is one of the most powerful and
exciting aspects of the newer widget set. Yet, it's also one of the most
confusing.</p>
<p>This chapter explains styles (which control how widgets like buttons look) and
themes (which are a collection of styles that define how all the widgets in your
application look). Changing themes can give your application an entirely
different look.</p>
<table><thead><tr><th style="text-align: center">Applying different themes.</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="./images/themes.png" alt="Themes." /></td></tr>
</tbody></table>
<p>Note that it's not just colors that have changed, but the actual shape of
individual widgets. Styles and themes are extremely flexible.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>However, before you get carried away, very few applications will benefit from
switching themes like this. Some games or educational programs might be
exceptions. Using the standard Tk theme for a given platform will display
widgets the way people expect to see them, particularly if they're running macOS
and Windows.</p>
<blockquote>
<p>On Linux systems, there's far less standardization of look and feel. Users
expect (and are more comfortable with) some variability and &quot;coolness.&quot; Because
different widget sets (typically GTK and QT) are used by window managers,
control panels, and other system utilities, Tk can't seamlessly blend in with
the current settings on any particular system. Most of the Linux screenshots in
this tutorial use Tk's alt theme. Despite users being accustomed to variability,
there are limits to what most users will accept. A prime example is the styling
of core widgets in Tk's classic widget set, matching circa-1992 OSF/Motif.</p>
</blockquote>
<p>Styles and themes, used in a more targeted manner and with significant
restraint, can have a role to play in modern applications. This chapter explains
why and when you might want to use them and how to go about doing so. We'll
begin by drawing a parallel between Tk's styles and themes and another realm of
software development.</p>
<h2 id="understanding-styles-and-themes"><a class="header" href="#understanding-styles-and-themes">Understanding Styles and Themes</a></h2>
<p>If you're familiar with web development, you know about cascading stylesheets
(CSS). There are two ways it can be used to customize the appearance of an
element in your HTML page. One way is to add a bunch of style attributes (fonts,
colors, borders, etc.) directly to an element in your HTML code via the <code>style</code>
attribute. For example:</p>
<pre><code class="language-html">&lt;label style=&quot;color:red; font-size:14pt; font-weight:bold; background-color:yellow;&quot;&gt;
    Meltdown imminent!
&lt;/label&gt;
</code></pre>
<p>The other way to use CSS is to attach a class to each widget via the <code>class</code>
attribute. The details of how elements of that class appear are provided
elsewhere, often in a separate CSS file. You can attach the same class to many
elements, and they will all have the same appearance. You don't need to repeat
the full details for every element. More importantly, you separate the logical
content of your site (HTML) from its appearance (CSS).</p>
<pre><code class="language-html">&lt;label class=&quot;danger&quot;&gt;Meltdown imminent!&lt;/label&gt;
...
&lt;style type=&quot;text/css&quot;&gt;
label.danger {color:red; font-size:14pt; font-weight:bold; background-color:yellow;}
&lt;/style&gt;
</code></pre>
<p>Back to Tk.</p>
<ul>
<li>In the classic Tk widgets, all appearance customizations require specifying
each detail on individual widgets, akin to always using the <code>style</code> HTML
attribute.</li>
<li>In the themed Tk widgets, all appearance customizations are made via attaching
a style to a widget, akin to using the <code>class</code> HTML attribute. Separately, you
define how widgets with that style will appear, akin to writing CSS.</li>
<li>Unlike with HTML, you can't freely mix and match. You can't customize some
themed entries or buttons with styles and others by directly changing
appearance options.</li>
</ul>
<blockquote>
<p>Yes, there are a few exceptions, like labels where you can customize the font
and colors through both styles and configuration options.</p>
</blockquote>
<h2 id="benefits"><a class="header" href="#benefits">Benefits</a></h2>
<p>So why use styles and themes in Tk? They take the fine-grained details of
appearance decisions away from individual instances of widgets.</p>
<p>That makes for cleaner code and less repetition. If you have 20 entry widgets in
your application, you don't need to repeat the exact appearance details every
time you create one (or write a wrapper function). Instead, you assign them a
style.</p>
<p>Styles also put all appearance decisions in one place. And because styles for a
button and styles for other widgets can share common elements, it promotes
consistency and improves reuse.</p>
<blockquote>
<p>Styles also have many benefits for widget authors. Widgets can delegate most
appearance decisions to styles. A widget author no longer has to hardcode logic
to the effect of &quot;when the state is disabled, consult the 'disabledforeground'
configuration option and use that for the foreground color.&quot; Not only did that
make coding widgets longer (and more repetitive), but it also restricted how a
widget could be changed based on its state. If the widget author omitted logic
to change the font when the state changed, you were out of luck as an
application developer using the widget.</p>
</blockquote>
<blockquote>
<p>Using styles, widget authors don't need to provide code for every possible
appearance option. That not only simplifies the widget but paradoxically ensures
that a wider range of appearances can be set, including those the widget author
may not have anticipated. </p>
</blockquote>
<h2 id="run-example-24"><a class="header" href="#run-example-24">Run Example</a></h2>
<p>Example code in this chapter can be executed via:</p>
<p><code>cargo run --example styles_and_themes</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-existing-themes"><a class="header" href="#using-existing-themes">Using Existing Themes</a></h1>
<p>Before delving into the weightier matters of tastefully and selectively
modifying and applying styles to improve the usability of your application and
cleanliness of your code, let's deal with the fun bits: using existing themes to
completely reskin your application.</p>
<p>Themes are identified by a name. You can obtain the names of all available
themes:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let names = tk.theme_names()?
    .iter()
    .fold( String::new(), |acc,name| format!( &quot;{} {}&quot;, acc, name ));
println!( &quot;{}&quot;, names ); // clam alt default classic
<span class="boring">}
</span></code></pre></pre>
<table><thead><tr><th style="text-align: center"><img src="./images/w_several_themes.png" alt="Built-in themes." /></th></tr></thead><tbody>
<tr><td style="text-align: center">Built-in themes.</td></tr>
</tbody></table>
<p>Besides the built-in themes (<code>alt</code>, <code>default</code>, <code>clam</code>, and <code>classic</code>), macOS
includes a theme named <code>aqua</code> to match the system-wide style, while Windows
includes themes named <code>vista</code>, <code>winxpnative</code>, and <code>winnative</code>.</p>
<p>Only one theme can be active at a time. To obtain the name of the theme
currently in use, use the following:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let theme = tk.theme_in_use()?;
println!( &quot;{}&quot;, theme.name ); // aqua
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>This API, which was originally targeted for Tk 8.6, was back-ported to Tk
8.5.9. If you're using an earlier version of Tk getting this info is a bit trickier.</p>
</blockquote>
<p>Switching to a new theme can be done with:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>new_theme.theme_use()?;
<span class="boring">}
</span></code></pre></pre>
<p>What does this actually do? Obviously, it sets the current theme to the
indicated theme. Doing this, therefore, replaces all the currently available
styles with the set of styles defined by the theme. Finally, it refreshes all
widgets, so they take on the appearance described by the new theme.</p>
<h2 id="third-party-themes"><a class="header" href="#third-party-themes">Third-Party Themes</a></h2>
<p>With a bit of looking around, you can find some existing add-on themes available
for download. A good starting point is
<a href="">https://wiki.tcl-lang.org/page/List+of+ttk+Themes</a>.</p>
<p>Though themes can be defined in any language that Tk supports, most that you
will find are written in Tcl. How can you install them so that they are
available to use in your application?</p>
<p>As an example, let's use the &quot;awdark&quot; theme, available from
<a href="">https://sourceforge.net/projects/tcl-awthemes/</a>. Download and unzip the
awthemes-*.zip file somewhere. You'll notice it contains a bunch of .tcl files,
a subdirectory i containing more directory with images used by the theme, etc.</p>
<p>One of the files is named <code>pkgIndex.tcl</code>. This identifies it as a Tcl package,
which is similar to a module in other languages. If we look inside, you'll see a
bunch of lines like <code>package ifneeded awdark 7.7</code>. Here, <code>awdark</code> is the name of
the package, and <code>7.7</code> is its version number. It's not unusual, as in this case,
for a single <code>pkgIndex.tcl</code> file to provide several packages.</p>
<p>To use it, we need to tell Tcl where to find the package (via adding its
directory to Tcl's <code>auto_path</code>) and the name of the package to use.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = std::path::Path::new( &quot;/full/path/to/awthemes-9.3.1&quot; );
tk.package_load( &quot;awdark&quot;, path )?;
<span class="boring">}
</span></code></pre></pre>
<p>If the theme is instead implemented as a single Tcl source file, without a
<code>pkgIndex.tcl</code>, you can make it available like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = std::path::Path::new( &quot;/full/path/to/themefile.tcl&quot; );
tk.source( path )?;
<span class="boring">}
</span></code></pre></pre>
<p>You should now be able to use the theme in your own application, just as you
would a built-in theme.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-styles"><a class="header" href="#using-styles">Using Styles</a></h1>
<p>We'll now tackle the more complex issue of taking full advantage of styles and
themes within your application, not just reskinning it with an existing theme.</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>We first need to introduce a few essential concepts.</p>
<h3 id="widget-class"><a class="header" href="#widget-class">Widget Class</a></h3>
<p>A widget class identifies the type of a particular widget, whether it is a
button, a label, a canvas, etc. All themed widgets have a default class. Buttons
have the class <code>TButton</code>, labels <code>TLabel</code>, etc.</p>
<h3 id="widget-state"><a class="header" href="#widget-state">Widget State</a></h3>
<p>A <em>widget state</em> allows a single widget to have more than one appearance or
behavior, depending on things like mouse position, different state options set
by the application, and so on.</p>
<p>As you'll recall, all themed widgets maintain a set of binary state flags,
accessed by the <code>state</code> and <code>instate</code> methods. The flags are: <code>active</code>,
<code>disabled</code>, <code>focus</code>, <code>pressed</code>, <code>selected</code>, <code>background</code>, <code>readonly</code>,
<code>alternate</code>, <code>and</code> <code>invalid</code>. All widgets have the same set of state flags,
though they may ignore some of them (e.g., a label widget would likely ignore an
<code>invalid</code> state flag). See the
[<code>themed widget</code>(https://tcl.tk/man/tcl8.6/TkCmd/ttk_widget.htm) page in the
reference manual for the exact meaning of each state flag.</p>
<h3 id="style"><a class="header" href="#style">Style</a></h3>
<p>A style describes the appearance (or appearances) of a widget class. All themed
widgets having the same widget class will have the same appearance(s).</p>
<p>Styles are referred to by the name of the widget class they describe. For
example, the style <code>TButton</code> defines the appearance of all widgets with the
class <code>TButton</code>.</p>
<p>Styles know about different states, and one style can define different
appearances based on a widget's state. For example, a style can specify how a
widget's appearance should change if the <code>pressed</code> state flag is set.</p>
<h3 id="theme"><a class="header" href="#theme">Theme</a></h3>
<p>A theme is a collection of styles. While each style is widget-specific (one for
buttons, one for entries, etc.), a theme collects many styles together. All
styles in the same theme will be designed to visually &quot;fit&quot; together with each
other. (Tk doesn't technically restrict bad design or judgment, unfortunately!)</p>
<p>Using a particular theme in an application really means that, by default, the
appearance of each widget will be controlled by the style within that theme
responsible for that widget class.</p>
<h2 id="style-names"><a class="header" href="#style-names">Style Names</a></h2>
<p>Every style has a name. If you're going to modify a style, create a new one, or
use a style for a widget, you need to know its name.</p>
<p>How do you know what the names of the styles are? If you have a particular
widget, and you want to know what style it is currently using, you can first
check the value of its <code>style</code> configuration option. If that is empty, it means
the widget is using the default style for the widget. You can retrieve that via
the widget's class. For example:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = root.add_ttk_button(())?;
assert!( b.cget( style )?.is_empty() ); // empty string as a result
assert_eq!( b.winfo_class()?, &quot;TButton&quot; );
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the style that is being used is <code>TButton</code>. The default styles for
other themed widgets are named similarly, e.g., <code>TEntry</code>, <code>TLabel</code>, etc.</p>
<blockquote>
<p>It's always wise to check the specifics. For example, the treeview widget's
class is <code>Treeview</code>, not <code>TTreeview</code>.</p>
</blockquote>
<p>Beyond the default styles, though, styles can be named pretty much anything. You
might create your own style (or use a theme that has a style) named <code>FunButton</code>,
<code>NuclearReactorButton</code>, or even <code>GuessWhatIAm</code> (not a wise choice).</p>
<p>More often, you'll find names like <code>Fun.TButton</code> or <code>NuclearReactor.TButton</code>.
These suggest variations of a base style; as you'll see, this is something Tk
supports for creating and modifying styles.</p>
<blockquote>
<p>The ability to retrieve a list of all currently available styles is currently
not supported. This will likely appear in Tk 8.7 in the form of a new command,
<code>theme_styles()</code>, returning the list of styles implemented by a theme. It also
proposes adding a <code>style</code> method for all widgets, so you don't have to examine
both the widget's <code>style</code> configuration option and its class. See
<a href="https://tip.tcl.tk/584">TIP #584</a>.</p>
</blockquote>
<h2 id="applying-a-style"><a class="header" href="#applying-a-style">Applying a Style</a></h2>
<p>To use a style means to apply that style to an individual widget. All you need
is the style's name and the widget to apply it to. Setting the style can be done
at creation time:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>root.add_ttk_button( -text(&quot;Hello&quot;) -style(&quot;Fun.TButton&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>A widget's style can also be changed later with the <code>style</code> configuration
option:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b.configure( -style(&quot;Emergency.TButton&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="creating-a-simple-style"><a class="header" href="#creating-a-simple-style">Creating a Simple Style</a></h2>
<p>So how do we create a new style like <code>Emergency.TButton</code>?</p>
<p>In situations like this, you're creating a new style only slightly different
from an existing one. This is the most common reason for creating new styles.</p>
<p>For example, you want most of the buttons in your application to keep their
usual appearance but have certain &quot;emergency&quot; buttons highlighted differently.
Creating a new style (e.g., <code>Emergency.TButton</code>), derived from the base style
(<code>TButton</code>), is appropriate.</p>
<p>Prepending another name (<code>Emergency</code>) followed by a dot onto an existing style
creates a new style derived from the existing one. The new style will have
exactly the same options as the existing one except for the indicated
differences:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>some_style.configure( -font(&quot;helvetica 24&quot;) -foreground(&quot;red&quot;) -padding(10) )?;
<span class="boring">}
</span></code></pre></pre>
<p>As shown earlier, you can then apply that style to an individual button widget
via its style configuration option. Every other button widget would retain its
normal appearance.</p>
<p>How do you know what options are available to change for a given style? That
requires diving a little deeper inside styles.</p>
<blockquote>
<p>You may have existing code using the classic widgets that you'd like to move
to the themed widgets. Most appearance changes made to classic widgets through
configuration options can probably be dropped. For those that can't, you may
need to create a new style, as shown above.</p>
</blockquote>
<blockquote>
<p>State-specific appearance changes can be treated similarly. In classic Tk,
several widgets supported a few state changes via configuration options. For
example, setting a button's <code>state</code> option to <code>disabled</code> would draw it with a
greyed-out label. Some allowed an additional state, active, which represented a
different appearance. You could change the widget's appearance in multiple
states via a set of configuration options, e.g., <code>foreground</code>,
<code>disabledforeground</code>, and <code>activeforeground</code>.</p>
</blockquote>
<blockquote>
<p>State changes via configuration options should be changed to use the <code>state</code>
method on themed widgets. Configuration options to modify the widget's
appearance in a particular state should be dealt with in the style.</p>
</blockquote>
<blockquote>
<p>Classic Tk widgets also supported a very primitive form of styles that you may
encounter. This used the <em>option database</em>, a now-obscure front end to X11-style
configuration files.</p>
</blockquote>
<blockquote>
<p>In classic Tk, all buttons had the same class (<code>Button</code>), all labels had the
same class (<code>Label</code>), etc. You could use this widget class both for
introspection and for changing options globally through the option database. It
let you say, for example, that all buttons should have a red background.</p>
</blockquote>
<blockquote>
<p>A few classic Tk widgets, including frame and toplevel widgets, let you change
the widget class of a particular widget when it was first created by providing a
<code>class</code> configuration option. For example, you could specify that one specific
frame widget had a class of <code>SpecialFrame</code>, while others would have the default
class <code>Frame</code>. You could use the option database to change the appearance of
just the <code>SpecialFrame</code> frames.</p>
</blockquote>
<blockquote>
<p>Styles and themes take that simple idea and give it rocket boosters. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whats-inside-a-style"><a class="header" href="#whats-inside-a-style">What's Inside a Style?</a></h1>
<p>If all you want to do is use a style or create a new one with a few tweaks, you
now know everything you need. If, however, you want to make more substantial
changes, things start to get &quot;interesting.&quot;</p>
<h2 id="elements"><a class="header" href="#elements">Elements</a></h2>
<p>While each style controls a single type of widget, each widget is usually
composed of smaller pieces, called elements. It's the job of the style author to
construct the entire widget out of these smaller elements. What these elements
are depends on the widget.</p>
<p>Here's an example of a button. It might have a border on the very outside.
That's one element. Just inside that, there may be a focus ring. Normally, it's
just the background color, but could be highlighted when a user tabs into the
button. So that's a second element. Then there might be some spacing between
that focus ring and the button's label. That spacing is a third element.
Finally, the text label of the button itself is a forth element. </p>
<table><thead><tr><th style="text-align: center"><img src="./images/button_elements.png" alt="Possible elements of a button." /></th></tr></thead><tbody>
<tr><td style="text-align: center">Possible elements of a button.</td></tr>
</tbody></table>
<p>Why might the style author have divided it up that way? If you have one part of
the widget that may be in a different location or a different color than
another, it may be a good candidate for an element. Note that this is just one
example of how a button could be constructed from elements. Different styles and
themes could (and do) accomplish this in different ways.</p>
<p>Here is an example of a vertical scrollbar. It consists of a &quot;trough&quot; element,
which contains other elements. These include the up and down arrow elements at
either end and a &quot;thumb&quot; element in the middle (it might have additional
elements, like borders).</p>
<table><thead><tr><th style="text-align: center"><img src="./images/scrollbar_elements.png" alt="Possible elements of a scrollbar." /></th></tr></thead><tbody>
<tr><td style="text-align: center">Possible elements of a scrollbar.</td></tr>
</tbody></table>
<h2 id="layout-1"><a class="header" href="#layout-1">Layout</a></h2>
<p>Besides specifying which elements make up a widget, a style also defines how
those elements are arranged within the widget. This is called their layout. Our
button had a label element inside a spacing element, inside a focus ring
element, inside a border element. Its logical layout is this:</p>
<pre><code>border {
    focus {
        spacing {
            label
        }
    }
}
</code></pre>
<p>We can ask Tk for the layout of the <code>TButton</code> style:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!( &quot;{}&quot;, tbutton_style.layout()? );
// &quot;Button.border -sticky nswe -border 1 -children {Button.focus -sticky nswe -children {Button.spacing -sticky nswe -children {Button.label -sticky nswe}}}&quot;
<span class="boring">}
</span></code></pre></pre>
<p>If we clean this up and format it a bit, we get something with this structure:</p>
<pre><code>Button.border -sticky nswe -border 1 -children {
    Button.focus -sticky nswe -children {
        Button.spacing -sticky nswe -children {
            Button.label -sticky nswe
        }
    }
}
</code></pre>
<p>This starts to make sense; we have four elements, named <code>Button.border</code>,
<code>Button.focus</code>, <code>Button.spacing</code>, and <code>Button.label</code>. Each has different element
options, such as <code>children</code>, <code>sticky</code>, and <code>border</code> that specify layout or
sizes. Without getting into too much detail at this point, we can clearly see
the nested layout based on the <code>children</code> and <code>sticky</code> attributes.</p>
<blockquote>
<p>Styles uses a simplified version of Tk's <code>pack</code> geometry manager to specify
element layout. This is detailed in the
<a href="https://tcl.tk/man/tcl8.6/TkCmd/ttk_style.htm">style</a> reference manual page.</p>
</blockquote>
<h2 id="element-options"><a class="header" href="#element-options">Element Options</a></h2>
<p>Each of these elements has several different options. For example, a label
element has a font and a foreground color. An element representing the thumb of
a scrollbar may have one option to set its background color and another to
provide the width of a border. These can be customized to adjust how the
elements within the overall widget look.</p>
<p>You can determine what options are available for each element? Here's an example
of checking what options are available for the label inside the button (which we
know from the <code>layout</code> method is identified as <code>Button.label</code>):</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let options = tk
    .element(&quot;Button.label&quot;)
    .element_options()?
    .iter()
    .fold( String::new(), |acc,opt| format!( &quot;{} {}&quot;, acc, opt ));
println!( &quot;{}&quot;, options ); // &quot; -compound -space -text -font -foreground -underline -width -anchor -justify -wraplength -embossed -image -stipple -background&quot;
<span class="boring">}
</span></code></pre></pre>
<p>In the following sections, we'll look at the not-entirely-straightforward way to
work with element options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manipulating-styles"><a class="header" href="#manipulating-styles">Manipulating Styles</a></h1>
<p>In this section, we'll see how to change the style's appearance by modifying
style options. You can do this either by modifying an existing style, or more
typically, by creating a new style. We saw how to create a simple style that was
derived from another one earlier:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let emergency_tbutton_style = tk.new_ttk_style( &quot;Emergency.TButton&quot;, None );
emergency_tbutton_style
    .configure( -font(&quot;helvetica 24&quot;) -foreground(&quot;red&quot;) -padding(10) )?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="modifying-a-style-option"><a class="header" href="#modifying-a-style-option">Modifying a Style Option</a></h2>
<p>Modifying an option for an existing style is done similarly to modifying any
other configuration option, by specifying the style, name of the option, and new
value:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tbutton_style.configure( -font(&quot;helvetica 24&quot;) )?;
<span class="boring">}
</span></code></pre></pre>
<p>You'll learn more about what the valid options are shortly.</p>
<blockquote>
<p>If you modify an existing style, like we've done here with <code>TButton</code>, that
modification will apply to all widgets using that style (by default, all
buttons). That may well be what you want to do.</p>
</blockquote>
<p>To retrieve the current value of an option, use the <code>lookup</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!( &quot;{}&quot;, tbutton_style.lookup_normal( font )? ); // &quot;helvetica 24&quot;
<span class="boring">}
</span></code></pre></pre>
<h2 id="state-specific-style-options"><a class="header" href="#state-specific-style-options">State Specific Style Options</a></h2>
<p>Besides the normal configuration options for the style, the widget author may
have specified different options to use when the widget is in a particular
widget state. For example, when a button is disabled, it may change the button's
label to grey.</p>
<blockquote>
<p>Remember that the state is composed of one or more state flags (or their
negation), as set by the widget's <code>state</code> method or queried via the <code>instate</code>
method.</p>
</blockquote>
<p>You can specify state-specific variations for one or more of a style's
configuration options with a map. For each configuration option, you can specify
a list of widget states, along with the value that option should be assigned
when the widget is in that state.</p>
<p>The following example provides for the following variations from a button's
normal appearance:</p>
<ul>
<li>
<p>when the widget is in the disabled state, the background color should be set
to <code>#d9d9d9</code></p>
</li>
<li>
<p>when the widget is in the active state (mouse over it), the background color
should be set to <code>#ececec</code></p>
</li>
<li>
<p>when the widget is in the disabled state, the foreground color should be set
to <code>#a3a3a3</code> (this is in addition to the background color change we already
noted)</p>
</li>
<li>
<p>when the widget is in the state where the button is pressed, and the widget is
not disabled, the relief should be set to <code>sunken</code> </p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tbutton_style.map(
    -background([ &quot;disabled&quot;, &quot;#d9d9d9&quot;, &quot;active&quot;, &quot;#ececec&quot; ].as_slice())
    -foreground([ &quot;disabled&quot;, &quot;#a3a3a3&quot; ].as_slice())
    -relief([ &quot;pressed !disabled&quot;, &quot;sunken&quot; ].as_slice()))?;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Because widget states can contain multiple flags, more than one state may
match an option (e.g., <code>pressed</code> and <code>pressed</code> <code>!disabled</code> will both match if
the widget's <code>pressed</code> state flag is set). The list of states is evaluated in
the order you provide in the map command. The first state in the list that
matches is used.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-difficult-to-you"><a class="header" href="#sound-difficult-to-you">Sound Difficult to you?</a></h1>
<p>You now know that styles consist of elements, each with various options,
composed together in a layout. You can change options on styles to make all
widgets using the style appear differently. Any widgets using that style take on
the appearance that the style defines. Themes collect an entire set of related
styles, making it easy to change the appearance of your entire user interface.</p>
<p>So what makes styles and themes so difficult in practice? Three things. First:</p>
<pre><code>You can only modify options for a style, not element options (except sometimes).
</code></pre>
<p>We talked earlier about identifying the elements used in the style by examining
its layout and identifying what options were available for each element. But
when we went to make changes to a style, we seemed to be configuring an option
for the style without specifying an individual element. What's going on?</p>
<p>Again, using our button example, we had an element <code>Button.label</code>, which, among
other things, had a <code>font</code> configuration option. What happens is that when that
<code>Button.label</code> element is drawn, it looks at the <code>font</code> configuration option set
on the style to determine what font to draw itself in.</p>
<blockquote>
<p>To understand why, you need to know that when a style includes an element as
a piece of it, that element does not maintain any (element-specific) storage. In
particular, it does not store any configuration options itself. When it needs to
retrieve options, it does so via the containing style, which is passed to the
element. Individual elements, therefore, are &quot;flyweight&quot; objects in GoF pattern
parlance.</p>
</blockquote>
<p>Similarly, any other elements will look up their configuration options from
options set on the style. What if two elements use the same configuration option
(like a background color)? Because there is only one background configuration
option (stored in the style), both elements will use the same background color.
You can't have one element use one background color and the other use a
different background color.</p>
<blockquote>
<p>Except when you can. There are a few nasty, widget-specific things called
<em>sublayouts</em> in the current implementation, which let you sometimes modify just
a single element, via configuring an option like <code>TButton.Label</code> (rather than
just <code>TButton</code>, the name of the style).</p>
</blockquote>
<blockquote>
<p>Some styles also provide additional configuration options that let you specify
what element the option affects. For example, the <code>TCheckbutton</code> style provides
a <code>background</code> option for the main part of the widget and an
<code>indicatorbackground</code> option for the box that shows whether it is checked.</p>
</blockquote>
<blockquote>
<p>Are the cases where you can do this documented? Is there some way to
introspect to determine when you can do this? The answer to both questions is
&quot;sometimes&quot; (believe it or not, this is an improvement; the answer to both used
to be a clear &quot;no&quot;). You can sometimes find <em>some</em> of the style's options by
calling the style's <code>configure</code> method without providing any new configuration
options. The reference manual pages for each themed widget now generally include
a <em>styling options</em> section that lists options that <em>may</em> be available to
change.</p>
</blockquote>
<blockquote>
<p>This is one area of the themed widget API that continues to evolve over time.</p>
</blockquote>
<p>The second difficulty is also related to modifying style options:</p>
<pre><code>Available options don't necessarily have an effect, and it's not an error to
modify a bogus option.
</code></pre>
<p>You'll sometimes try to change an option that is supposed to exist according to
element options, but it will have no effect. For example, you can't modify the
background color of a button in the <code>aqua</code> theme used by macOS. While there are
valid reasons for these cases, it's not easy to discover them, which can make
experimenting frustrating at times.</p>
<p>Perhaps more frustrating when you're experimenting is that specifying an
<code>incorrect</code> style name or option name does not generate an error. When doing a
<code>configure</code> or <code>lookup</code> you can provide an entirely arbitrary name for a style
or an option. So if you're bored with the <code>background</code> and <code>font</code> options, feel
free to configure a <code>dowhatimean</code> option. It may not do anything, but it's not
an error. Again, it may make it hard to know what you should be modifying and
what you shouldn't.</p>
<blockquote>
<p>This is one of the downsides of having a very lightweight and dynamic system.
You can create new styles by providing their name when configuring style options
without explicitly creating a style object. At the same time, this does open
itself to errors. It's also not possible to find out what styles currently exist
or are used. And remember that style options are really just a front end for
element options, and the elements in a style can change at any time. It's not
obvious that options should be restricted to those referred to by current
elements alone, which may themselves not all be introspectable.</p>
</blockquote>
<p>Finally, here is the last thing that makes styles and themes so difficult:</p>
<pre><code>The elements available, the names of those elements, which options are
available or affect each of those elements, and which are used for a
particular widget can be different in every theme.
</code></pre>
<p>So? Remember, the default theme for each platform (Windows, macOS, and Linux) is
different (which is a good thing). Some implications of this:</p>
<ol>
<li>
<p>If you want to define a new type of widget (or a variation of an existing
widget) for your application, you'll need to do it separately and differently
for each theme your application uses (i.e., at least three for a cross-platform
application).</p>
</li>
<li>
<p>As the elements and options available may differ for each theme/platform, you
may need a quite different customization approach for each theme/platform.</p>
</li>
<li>
<p>The elements, names, and element options available with each theme are not
typically documented (outside of reading the theme definition files themselves)
but are generally identified via theme introspection (which we'll see soon).
Because all themes aren't available on all platforms (e.g., <code>aqua</code> is only
available on macOS), you'll need ready access to every platform and theme you
need to run on. </p>
</li>
</ol>
<p>Consider trying to customize a button. You know it uses the <code>TButton</code> style. But
that style is implemented using a different theme on each platform. If you
examine the layout of that style in each theme, you'll discover each uses
different elements arranged differently. If you try to find the advertised
options available for each element, you see those are different too. And of
course, even if an option is nominally available, it may not have an effect).</p>
<p>The bottom line is that in classic Tk, where you could modify any of a large set
of attributes for an individual widget, you'd be able to do something on one
platform, and it would sorta-kinda work (but probably need tweaking) on others.
In themed Tk, the easy option just isn't there, and you're pretty much forced to
do it the right way if you want your application to work with multiple themes/
platforms. It's more work upfront.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-more-on-elements"><a class="header" href="#advanced-more-on-elements">Advanced: More on Elements</a></h1>
<p>While that's about as far as we're going to go on styles and themes in this
tutorial, for curious users and those who want to delve further into creating
new themes, we can provide a few more interesting tidbits about elements.</p>
<p>Because elements are the building blocks of styles and themes, it begs the
question of &quot;where do elements come from?&quot; Practically speaking, we can say that
elements are normally created in C code and conform to a particular API that the
theming engine understands.</p>
<p>At the very lowest level, elements come from something called an element
factory. At present, there is a default one, which most themes use, and uses Tk
drawing routines to create elements. A second allows you to create elements from
images and is accessible at the script level using the <code>Tk::element_create</code>
method (from Tcl). Any image format supported by Tk is available, including
scalable image formats like SVG, if you have the right extension. Finally, there
is a third, Windows-specific engine using the underlying &quot;Visual Styles&quot;
platform API.</p>
<p>If a theme uses elements created via a platform's native widgets, the calls to
use those native widgets will normally appear within that theme's element
specification code. Of course, themes whose elements depend on native widgets or
API calls can only run on the platforms that support them.</p>
<p>Themes will then take a set of elements and use those to assemble the styles
that are actually used by the widgets. And given the whole idea of themes is
that several styles can share the same appearance, it's not surprising that
different styles share the same elements.</p>
<p>So while the <code>TButton</code> style includes a <code>Button.padding</code> element, and the
<code>TEntry</code> style includes an <code>Entry.padding</code> element, underneath, these padding
elements are more than likely one and the same. They may appear differently, but
that's because of different configuration options, which, as we recall, are
stored in the style that uses the element.</p>
<p>It's also probably not surprising to find out that a theme can provide a set of
common options that are used as defaults for each style if the style doesn't
specify them otherwise. This means that if pretty much everything in an entire
theme has a green background, the theme doesn't need to explicitly say this for
each style. This uses a root style named <code>&quot;.&quot;</code>. If <code>Fun.TButton</code> can inherit
from <code>TButton</code>, why can't <code>TButton</code> inherit from <code>&quot;.&quot;</code>?</p>
<p>Finally, it's worth having a look at how existing themes are defined, both at
the C code level in Tk's C library and via the Tk scripts found in Tk's
&quot;library/ttk&quot; directory or in third-party themes. Search for
<code>Ttk_RegisterElementSpec</code> in Tk's C library to see how elements are specified.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
